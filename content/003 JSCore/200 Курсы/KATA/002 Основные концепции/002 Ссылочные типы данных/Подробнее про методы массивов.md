____

tags: #JavaScript #массив #splice #slice #concat #forEach #indexOf #lastIndexOf #includes #find #findIndex #filter #map #sort #reverse #splite #join #reduce #reduceRight #isArray #thisArg

links: [[2.6 Методы массивов|Методы массивов]] , [[4.1 Стрелочные функции|Стрелочные функции]]

### Кратко

Шпаргалка по методам массива:

-   Для добавления/удаления элементов:
    -   `push (...items)` – добавляет элементы в конец,
    -   `pop()` – извлекает элемент с конца,
    -   `shift()` – извлекает элемент с начала,
    -   `unshift(...items)` – добавляет элементы в начало.
    -   `splice(pos, deleteCount, ...items)` – начиная с индекса `pos`, удаляет `deleteCount` элементов и вставляет `items`.
    -   `slice(start, end)` – создаёт новый массив, копируя в него элементы с позиции `start` до `end` (не включая `end`).
    -   `concat(...items)` – возвращает новый массив: копирует все члены текущего массива и добавляет к нему `items`. Если какой-то из `items` является массивом, тогда берутся его элементы.

-   Для поиска среди элементов:
    -   `indexOf/lastIndexOf(item, pos)` – ищет `item`, начиная с позиции `pos`, и возвращает его индекс или `-1`, если ничего не найдено.
    -   `includes(value)` – возвращает `true`, если в массиве имеется элемент `value`, в противном случае `false`.
    -   `find/filter(func)` – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается `true`.
    -   `findIndex` похож на `find`, но возвращает индекс вместо значения.

-   Для перебора элементов:
    -   `forEach(func)` – вызывает `func` для каждого элемента. Ничего не возвращает.

-   Для преобразования массива:
    -   `map(func)` – создаёт новый массив из результатов вызова `func` для каждого элемента.
    -   `sort(func)` – сортирует массив «на месте», а потом возвращает его.
    -   `reverse()` – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
    -   `split/join` – преобразует строку в массив и обратно.
    -   `reduce/reduceRight(func, initial)` – вычисляет одно значение на основе всего массива, вызывая `func` для каждого элемента и передавая промежуточный результат между вызовами.

-   Дополнительно:
    -   `Array.isArray(arr)` проверяет, является ли `arr` массивом.

Обратите внимание, что методы `sort`, `reverse` и `splice` изменяют исходный массив.

Изученных нами методов достаточно в 99% случаев, но существуют и другие.
-   [arr.some(fn)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/some)/[arr.every(fn)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/every) проверяет массив.
    
    Функция `fn` вызывается для каждого элемента массива аналогично `map`. Если какие-либо/все результаты вызовов являются `true`, то метод возвращает `true`, иначе `false`.
    
    Эти методы ведут себя примерно так же, как операторы `||` и `&&`: если `fn` возвращает истинное значение, `arr.some()` немедленно возвращает `true` и останавливает перебор остальных элементов; если `fn` возвращает ложное значение, `arr.every()` немедленно возвращает `false` и также прекращает перебор остальных элементов.
    
    Мы можем использовать `every` для сравнения массивов:
    ```
	function arraysEqual(arr1, arr2) {   
		return arr1.length === arr2.length && arr1.every((value, index) => 
		value === arr2[index]); 
	}  
	
	alert( arraysEqual([1, 2], [1, 2])); // true`
    ```
    
-   [arr.fill(value, start, end)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) – заполняет массив повторяющимися `value`, начиная с индекса `start` до `end`.
-   [arr.copyWithin(target, start, end)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin) – копирует свои элементы, начиная со `start` и заканчивая `end`, в _собственную_ позицию `target` (перезаписывает существующие).
-   [arr.flat(depth)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)/[arr.flatMap(fn)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap) создаёт новый плоский массив из многомерного массива.

Полный список есть в [справочнике MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array).

На первый взгляд может показаться, что существует очень много разных методов, которые довольно сложно запомнить. Но это гораздо проще, чем кажется.

Внимательно изучите шпаргалку, представленную выше, а затем, чтобы попрактиковаться, решите задачи, предложенные в данной главе. Так вы получите необходимый опыт в правильном использовании методов массива.

Всякий раз, когда вам будет необходимо что-то сделать с массивом, а вы не знаете, как это сделать – приходите сюда, смотрите на таблицу и ищите правильный метод. Примеры помогут вам всё сделать правильно, и вскоре вы быстро запомните методы без особых усилий.

_____
## Введение

Массивы предоставляют множество методов. 
Чтобы было проще, в этой главе они разбиты на группы.

## Добавление/удаление элементов

Мы уже знаем методы, которые добавляют и удаляют элементы из начала или конца:
-   `arr.push(...items)` – добавляет элементы в конец,
-   `arr.pop()` – извлекает элемент из конца,
-   `arr.shift()` – извлекает элемент из начала,
-   `arr.unshift(...items)` – добавляет элементы в начало.

Есть и другие.

### #splice

Как удалить элемент из массива?

Так как массивы – это объекты, то можно попробовать `delete`:
```
let arr = ["I", "go", "home"];  
delete arr[1]; // удалить "go"  
alert( arr[1] ); // undefined  // теперь arr = ["I",  , "home"]; 
alert( arr.length ); // 3`
```

Вроде бы, элемент и был удалён, но при проверке оказывается, что массив всё ещё имеет 3 элемента `arr.length == 3`.

Это нормально, потому что всё, что делает `delete obj.key` – это удаляет значение с данным ключом `key`. Это нормально для объектов, но для массивов мы обычно хотим, чтобы оставшиеся элементы сдвинулись и заняли освободившееся место. Мы ждём, что массив станет короче.

Поэтому для этого нужно использовать специальные методы.

Метод [arr.splice(str)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.

Его синтаксис:
```
arr.splice(index[, deleteCount, elem1, ..., elemN])`
```

Он начинает с позиции `index`, удаляет `deleteCount` элементов и вставляет `elem1, ..., elemN` на их место. Возвращает массив из удалённых элементов.

Этот метод проще всего понять, рассмотрев примеры.

Начнём с удаления:
```
let arr = ["Я", "изучаю", "JavaScript"];  
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); // осталось ["Я", "JavaScript"]`
```

Легко, правда? Начиная с позиции `1`, он убрал `1` элемент.

В следующем примере мы удалим 3 элемента и заменим их двумя другими.
```
let arr = [_"Я"__, "изучаю", "JavaScript",_ "прямо", "сейчас"];  
// удалить 3 первых элемента и заменить их другими 

arr.splice(0, 3, "Давай", "танцевать");  
alert( arr ) // теперь [_"Давай", "танцевать"_, "прямо", "сейчас"]`
```

Здесь видно, что `splice` возвращает массив из удалённых элементов:
```
let arr = [_"Я"__, "изучаю",_ "JavaScript", "прямо", "сейчас"];  
// удалить 2 первых элемента \

let removed = arr.splice(0, 2);  
alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов`
```

Метод `splice` также может вставлять элементы без удаления, для этого достаточно установить `deleteCount` в `0`:
```
let arr = ["Я", "изучаю", "JavaScript"];  
// с позиции 2 // удалить 0 элементов // вставить "сложный", "язык" 

arr.splice(2, 0, "сложный", "язык");  
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"`
```

Отрицательные индексы разрешены

В этом и в других методах массива допускается использование отрицательного индекса. Он позволяет начать отсчёт элементов с конца, как тут:
```
let arr = [1, 2, 5];  
// начиная с индекса -1 (перед последним элементом) 
// удалить 0 элементов, 
// затем вставить числа 3 и 4 

arr.splice(-1, 0, 3, 4);  
alert( arr ); // 1,2,3,4,5`
```

### #slice

Метод [arr.slice](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) намного проще, чем похожий на него `arr.splice`.

Его синтаксис:

`arr.slice([start], [end])`

Он возвращает новый массив, в который копирует элементы, начиная с индекса `start` и до `end` (не включая `end`). Оба индекса `start` и `end` могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.

Это похоже на строковый метод `str.slice`, но вместо подстрок возвращает подмассивы.

Например:
```
let arr = ["t", "e", "s", "t"];  

alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)  
alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)`
```

Можно вызвать `slice` и вообще без аргументов: `arr.slice()` создаёт копию массива `arr`. Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.

### #concat

Метод [arr.concat](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

Его синтаксис:

`arr.concat(arg1, arg2...)`

Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.

В результате мы получаем новый массив, включающий в себя элементы из `arr`, а также `arg1`, `arg2` и так далее…

Если аргумент `argN` – массив, то все его элементы копируются. Иначе скопируется сам аргумент.

Например:
```
let arr = [1, 2];  // создать массив из: arr и [3,4] 

alert( arr.concat([3, 4]) ); 
// 1,2,3,4  // создать массив из: arr и [3,4] и [5,6] 

alert( arr.concat([3, 4], [5, 6]) ); 
// 1,2,3,4,5,6  // создать массив из: arr и [3,4], потом добавить значения 5 и 6

alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6`
```

Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:
```
let arr = [1, 2];  
let arrayLike = {   0: "что-то",   length: 1 };  
alert( arr.concat(arrayLike) ); // 1,2,[object Object]`
```

…Но если массивоподобный объект имеет специальное свойство `Symbol.isConcatSpreadable`, то он обрабатывается как массив, с помощью `concat`: вместо него добавляются его элементы:
```
let arr = [1, 2];  
let arrayLike = {   
	0: "что-то",   
	1: "ещё",   
	[Symbol.isConcatSpreadable]: true,_   
	length: 2 
};  

alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё`
```

## Перебор: #forEach

Метод [arr.forEach](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) позволяет запускать функцию для каждого элемента массива.

Его синтаксис:
`arr.forEach(function(item, index, array) {   // ... делать что-то с item });`

Например, этот код выведет на экран каждый элемент массива:
`// Вызов alert для каждого элемента ["Bilbo", "Gandalf", "Nazgul"].forEach(alert);`

А этот вдобавок расскажет и о своей позиции в массиве:

``["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {   alert(`${item} имеет позицию ${index} в ${array}`); });``

Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.

## Поиск в массиве

Далее рассмотрим методы, которые помогут найти что-нибудь в массиве.

### #indexOf / #lastIndexOf и #includes

Методы [arr.indexOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf), [arr.lastIndexOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf) и [arr.includes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/includes) имеют одинаковый синтаксис и делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:
-   `arr.indexOf(item, from)` ищет `item`, начиная с индекса `from`, и возвращает индекс, на котором был найден искомый элемент, в противном случае `-1`.
-   `arr.lastIndexOf(item, from)` – то же самое, но ищет справа налево.
-   `arr.includes(item, from)` – ищет `item`, начиная с индекса `from`, и возвращает `true`, если поиск успешен.

Например:
```
let arr = [1, 0, false];  

alert( arr.indexOf(0) ); // 1 
alert( arr.indexOf(false) ); // 2 
alert( arr.indexOf(null) ); // -1  
alert( arr.includes(1) ); // true`
```

Обратите внимание, что методы используют строгое сравнение === . Таким образом, если мы ищем `false`, он находит именно `false`, а не ноль.

Если мы хотим проверить наличие элемента, и нет необходимости знать его точный индекс, тогда предпочтительным является `arr.includes`.

Кроме того, очень незначительным отличием `includes` является то, что он правильно обрабатывает `NaN` в отличие от `indexOf/lastIndexOf`:
```
const arr = [NaN]; 

alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN) 

alert( arr.includes(NaN) );// true (верно)`
```

### #find и #findIndex

Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?

Здесь пригодится метод [arr.find](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/find).

Его синтаксис таков:
```
let result = arr.find(function(item, index, array) {   
	// если true - возвращается текущий элемент и перебор прерывается   
	// если все итерации оказались ложными, возвращается undefined 
});`
```

Функция вызывается по очереди для каждого элемента массива:
-   `item` – очередной элемент.
-   `index` – его индекс.
-   `array` – сам массив.

Если функция возвращает `true`, поиск прерывается и возвращается `item`. Если ничего не найдено, возвращается `undefined`.

Например, у нас есть массив пользователей, каждый из которых имеет поля `id` и `name`. Попробуем найти того, кто с `id == 1`:
```
let users = [   
	{id: 1, name: "Вася"},   
	{id: 2, name: "Петя"},   
	{id: 3, name: "Маша"} 
];  

let user = users.find(item => item.id == 1);  
alert(user.name); // Вася`
```

В реальной жизни массивы объектов – обычное дело, поэтому метод `find` крайне полезен.

Обратите внимание, что в данном примере мы передаём `find` функцию `item => item.id == 1`, с одним аргументом. Это типично, дополнительные аргументы этой функции используются редко.

Метод [arr.findIndex](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и `-1`, если ничего не найдено.

### #filter

Метод `find` ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт `true`.

На тот случай, если найденных элементов может быть много, предусмотрен метод [arr.filter(fn)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).

Синтаксис этого метода схож с `find`, но `filter` возвращает массив из всех подходящих элементов:
```
let results = arr.filter(function(item, index, array) {   
	// если true - элемент добавляется к результату, и перебор продолжается   
	// возвращается пустой массив в случае, если ничего не найдено 
});`
```

Например:
```
let users = [   
	{id: 1, name: "Вася"},   
	{id: 2, name: "Петя"},   
	{id: 3, name: "Маша"} 
];  // возвращает массив, состоящий из двух первых пользователей 

let someUsers = users.filter(item => item.id < 3);  
alert(someUsers.length); // 2`
```

## Преобразование массива

Перейдём к методам преобразования и упорядочения массива.

### #map

Метод [arr.map](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map) является одним из наиболее полезных и часто используемых.

Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

Синтаксис:
```
let result = arr.map(function(item, index, array) {   
	// возвращается новое значение вместо элемента });`
```

Например, здесь мы преобразуем каждый элемент в его длину:

`let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length); alert(lengths); // 5,7,6`

### #sort(fn)

Вызов [arr.sort()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) сортирует массив _на месте_, меняя в нём порядок элементов.

Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам `arr`.

Например:
```
let arr = [ 1, 2, 15 ];  
// метод сортирует содержимое arr 

arr.sort();  
alert( arr );  // _1, 15, 2_`
```

Не заметили ничего странного в этом примере?

Порядок стал `1, 15, 2`. Это неправильно! Но почему?

**По умолчанию элементы сортируются как строки.**

Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок, и действительно выходит, что `"2" > "15"`.

Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента `arr.sort()`.

Функция должна для пары значений возвращать:
```
function compare(a, b) {   
	if (a > b) return 1; 
	// если первое значение больше второго   
	
	if (a == b) return 0; // если равны   
	
	if (a < b) return -1; // если первое значение меньше второго 
}
```

Например, для сортировки чисел:
```
function compareNumeric(a, b) {   
	if (a > b) return 1;   
	if (a == b) return 0;   
	if (a < b) return -1; 
}  

let arr = [ 1, 2, 15 ];  
arr.sort(compareNumeric);

alert(arr);  // _1, 2, 15_`
```

Теперь всё работает как надо.

Давайте возьмём паузу и подумаем, что же происходит. Упомянутый ранее массив `arr` может быть массивом чего угодно, верно? Он может содержать числа, строки, объекты или что-то ещё. У нас есть набор _каких-то элементов_. Чтобы отсортировать его, нам нужна _функция, определяющая порядок_, которая знает, как сравнивать его элементы. По умолчанию элементы сортируются как строки.

Метод `arr.sort(fn)` реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает внутри (в большинстве случаев это оптимизированная [быстрая сортировка](https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0) или [Timsort](https://ru.wikipedia.org/wiki/Timsort)). Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Всё, что остаётся нам, это предоставить `fn`, которая делает это сравнение.

Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – ничто не мешает нам вывести их на экран:

`[1, -2, 15, 2, 0, 8].sort(function(a, b) {   alert( a + " <> " + b );   return a - b; });`

В процессе работы алгоритм может сравнивать элемент со множеством других, но он старается сделать как можно меньше сравнений.

Функция сравнения может вернуть любое число

На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».

Это позволяет писать более короткие функции:

`let arr = [ 1, 2, 15 ];  arr.sort(function(a, b) { return a - b; });  alert(arr);  // _1, 2, 15_`

Лучше использовать стрелочные функции

Помните [[4.1 Стрелочные функции]]? Можно использовать их здесь для того, чтобы сортировка выглядела более аккуратной:

`arr.sort( (a, b) => a - b );`

Будет работать точно так же, как и более длинная версия выше.

Используйте `localeCompare` для строк

Помните алгоритм сравнения [строк](https://learn.javascript.ru/string#correct-comparisons)? По умолчанию, он сравнивает буквы по их кодам.

Для многих алфавитов лучше использовать метод `str.localeCompare`, для правильной сортировки букв, таких как `Ö`.

Например, давайте отсортируем несколько стран на немецком языке:
```
let countries = ['Österreich', 'Andorra', 'Vietnam'];  

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); 
// Andorra, Vietnam, Österreich (неправильно)  

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); 
// Andorra,Österreich,Vietnam (правильно!)`
```

### #reverse

Метод [arr.reverse](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse) меняет порядок элементов в `arr` на обратный.

Например:

`let arr = [1, 2, 3, 4, 5]; arr.reverse();  alert( arr ); // 5,4,3,2,1`

Он также возвращает массив `arr` с изменённым порядком элементов.

### #split и #join

Ситуация из реальной жизни. Мы пишем приложение для обмена сообщениями, и посетитель вводит имена тех, кому его отправить, через запятую: `Вася, Петя, Маша`. Но нам-то гораздо удобнее работать с массивом имён, чем с одной строкой. Как его получить?

Метод [str.split(delim)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/split) именно это и делает. Он разбивает строку на массив по заданному разделителю `delim`.

В примере ниже таким разделителем является строка из запятой и пробела.
```
let names = 'Вася, Петя, Маша';  
let arr = names.split(', ');  

for (let name of arr) {   
	alert( `Сообщение получат: ${name}.` ); 
	// Сообщение получат: Вася (и другие имена) 
}
```

У метода `split` есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:
```
let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);  
alert(arr); // Вася, Петя`
```

Разбивка по буквам

Вызов `split(s)` с пустым аргументом `s` разбил бы строку на массив букв:
```
let str = "тест";  
alert( str.split('') ); // т,е,с,т`
```

Вызов [arr.join(glue)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join) делает в точности противоположное `split`. Он создаёт строку из элементов `arr`, вставляя `glue` между ними.

Например:
```
let arr = ['Вася', 'Петя', 'Маша'];  
let str = arr.join(';'); // объединить массив в строку через ;  
alert( str ); // Вася;Петя;Маша`
```

### #reduce / #reduceRight

Если нам нужно перебрать массив – мы можем использовать `forEach`, `for` или `for..of`.

Если нам нужно перебрать массив и вернуть данные для каждого элемента – мы используем `map`.

Методы [arr.reduce](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) и [arr.reduceRight](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight) похожи на методы выше, но они немного сложнее. Они используются для вычисления какого-нибудь единого значения на основе всего массива.

Синтаксис:
```
let value = arr.reduce(function(accumulator, item, index, array) {   // ... }, [initial]);`
```

Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

Аргументы:
-   `accumulator` – результат предыдущего вызова этой функции, равен `initial` при первом вызове (если передан `initial`),
-   `item` – очередной элемент массива,
-   `index` – его индекс,
-   `array` – сам массив.

При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент.

Звучит сложновато, но всё становится проще, если думать о первом аргументе как «аккумулирующем» результат предыдущих вызовов функции. По окончании он становится результатом `reduce`.

Этот метод проще всего понять на примере.

Тут мы получим сумму всех элементов массива всего одной строкой:
```
let arr = [1, 2, 3, 4, 5];  
let result = arr.reduce((sum, current) => sum + current, 0);  alert(result); // 15`
```

Здесь мы использовали наиболее распространённый вариант `reduce`, который использует только 2 аргумента.

Давайте детальнее разберём, как он работает.
1.  При первом запуске `sum` равен `initial` (последний аргумент `reduce`), то есть `0`, а `current` – первый элемент массива, равный `1`. Таким образом, результат функции равен `1`.
2.  При втором запуске `sum = 1`, и к нему мы добавляем второй элемент массива (`2`).
3.  При третьем запуске `sum = 3`, к которому мы добавляем следующий элемент, и так далее…

Поток вычислений получается такой:

![[Pasted image 20230119175431.png]]

Здесь отчётливо видно, как результат предыдущего вызова передаётся в первый аргумент следующего.

Мы также можем опустить начальное значение:
```
let arr = [1, 2, 3, 4, 5];  // убрано начальное значение (нет 0 в конце) 
let result = arr.reduce((sum, current) => sum + current);  
alert( result ); // 15`
```

Результат – точно такой же! Это потому, что при отсутствии `initial` в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Таблица вычислений будет такая же за вычетом первой строки.

Но такое использование требует крайней осторожности. Если массив пуст, то вызов `reduce` без начального значения выдаст ошибку.

Вот пример:
```
let arr = [];  
// Error: Reduce of empty array with no initial value 
// если бы существовало начальное значение, reduce вернул бы его для пустого массива. 

arr.reduce((sum, current) => sum + current);`
```

Поэтому рекомендуется всегда указывать начальное значение.

Метод [arr.reduceRight](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight) работает аналогично, но проходит по массиву справа налево.

## Array.isArray

Массивы не образуют отдельный тип языка. Они основаны на объектах.

Поэтому `typeof` не может отличить простой объект от массива:
```
alert(typeof {}); // object 
alert(typeof []); // тоже object`
```

…Но массивы используются настолько часто, что для этого придумали специальный метод: [Array.isArray(value)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray). Он возвращает `true`, если `value` массив, и `false`, если нет.
```
alert(Array.isArray({})); // false  
alert(Array.isArray([])); // true`
```

## Большинство методов поддерживают «thisArg»

Почти все методы массива, которые вызывают функции – такие как `find`, `filter`, `map`, за исключением метода `sort`, принимают необязательный параметр `thisArg`.

Этот параметр не объяснялся выше, так как очень редко используется, но для наиболее полного понимания темы мы обязаны его рассмотреть.

Вот полный синтаксис этих методов:
```
arr.find(func, thisArg); 
arr.filter(func, thisArg); 
arr.map(func, thisArg); // ... // thisArg - это необязательный последний аргумент`
```

Значение параметра `thisArg` становится `this` для `func`.

Например, вот тут мы используем метод объекта `army` как фильтр, и `thisArg` передаёт ему контекст:
```
let army = {   minAge: 18,   maxAge: 27,   canJoin(user) {     
	return user.age >= this.minAge && user.age < this.maxAge;   } 
};  

let users = [   {age: 16},   {age: 20},   {age: 23},   {age: 30} ];  
// найти пользователей, для которых army.canJoin возвращает true 

let soldiers = users.filter(army.canJoin, army);
alert(soldiers.length); // 2 

alert(soldiers[0].age); // 20 
alert(soldiers[1].age); // 23`
```

Если бы мы в примере выше использовали просто `users.filter(army.canJoin)`, то вызов `army.canJoin` был бы в режиме отдельной функции, с `this=undefined`. Это тут же привело бы к ошибке.

Вызов `users.filter(army.canJoin, army)` можно заменить на `users.filter(user => army.canJoin(user))`, который делает то же самое. Последняя запись используется даже чаще, так как функция-стрелка более наглядна.
