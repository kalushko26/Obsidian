____

tags: #browser #backend #rest #http

links: [[]]

youtube: 
1. 

keywords:

_____

# RESTful API для фронтенд разработчика

![](https://ymatuhin.ru/assets/img/rest_api/restful.png)

В [двух из трех](https://ymatuhin.ru/front-end/plan_for_frontend_developer/) вакансиях для фронтеда требуют знания **REST / RESTful API**. Разберемся что это и в чем разница.

## Что такое REST

**REST (Representational state transfer)** — общие принципы организации взаимодействия приложения/сайта с сервером по `HTTP`. Сервер не запоминает состояние пользователя между запросами. В запросах передаётся информация, идентифицирующая пользователя (например _токен_) и параметры для выполнения операции.

## Разница между REST и RESTful

**REST** — архитектурный стиль, а **RESTful** это сервис который следует этому стилю. Т.е если у вас на сервере _REST API_, а на клиенте вы делаете запросы к этому _API_, то у вас **RESTful** приложение/сайт.

## Как это работает

Взаимодействие с сервером сводится к 4 операциям (4 — необходимый и достаточный минимум):

1.  Получение данных (`JSON` или `XML`)
2.  Добавление новых данных
3.  Модификация данных
4.  Удаление данных

Получение данных не меняет состояния сервера. Каждый тип операции пользуется своим [HTTP методом](https://ru.wikipedia.org/wiki/HTTP#.D0.9C.D0.B5.D1.82.D0.BE.D0.B4.D1.8B):

1.  **GET** — Получение
2.  **POST** — Добавление
3.  **PUT** — Модификация
4.  **DELETE** — Удаление

## Пример REST API

В качества примера возьмем стандартное API для списка пользователей. Мы запрашиваем список пользователей, получаем информацию о пользователе, добавляем нового пользователя, изменяем информацию и удаляем пользователя. Если у нас на сервере REST API, то нам понадобятся следующие запросы:

1.  **GET** `/api/users` — получить список пользователей
2.  **GET** `/api/users/7` — получить информацию о пользователе с `ID=7`
3.  **POST** `/api/users` — добавить нового пользователя
4.  **PUT** `/api/users/7` — изменить информацию о пользователе с `ID=7`
5.  **DELETE** `/api/users/7` — удалить пользователя с `ID=7`

## Зачем это фронтенд разработчику

В работе это умение делать AJAX запросы и обрабатывать полученную информацию. Понимание принципов — дополнительный бонус, который позволяет догадаться какой метод использовать. Ну или подсказать серверному разработчику.

#### 5. Ref

##### Кратко

Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным (при рендеренге) в рендер-методе.
Чтобы модифицировать потомка (React-компонент или DOM-элемент), необходимо заново отрендерить его с новыми пропсами. 

Ref используется при управлении фокусом, вызове анимаций или интеграции со сторонними библиотеками. Не рекомендуется злоупотреблять ref ами потому что state должен хранится на верхнем уровне иерархии.

Рефы создаются с помощью `React.createRef()` и прикрепляются к React-элементам через `ref` атрибут. Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части компонента.

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();  }
  render() {
    return <div ref={this.myRef} />;  }
}
```

Когда реф передаётся элементу в методе `render`, ссылка на данный узел доступна через свойство рефа `current`.

```
const node = this.myRef.current;
```

##### Подробно

Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе.

В обычном потоке данных React родительские компоненты могут взаимодействовать с дочерними только через [пропсы](https://ru.reactjs.org/docs/components-and-props.html). Чтобы модифицировать потомка, вы должны заново отрендерить его с новыми пропсами. Тем не менее, могут возникать ситуации, когда вам требуется императивно изменить дочерний элемент, обойдя обычный поток данных. Подлежащий изменениям дочерний элемент может быть как React-компонентом, так и DOM-элементом. React предоставляет лазейку для обоих случаев.

##### Когда использовать рефы

Ситуации, в которых использование рефов является оправданным:

-   Управление фокусом, выделение текста или воспроизведение медиа.
-   Императивный вызов анимаций.
-   Интеграция со сторонними DOM-библиотеками.

Избегайте использования рефов в ситуациях, когда задачу можно решить декларативным способом.

Например, вместо того чтобы определять методы `open()` и `close()` в компоненте `Dialog`, лучше передавать ему проп `isOpen`.

##### Не злоупотребляйте рефами

Возможно, с первого взгляда вам показалось, что рефы применяются, когда нужно решить какую-то задачу в вашем приложении «во что бы то ни стало». Если у вас сложилось такое впечатление, сделайте паузу и обдумайте, где должно храниться конкретное состояние в иерархии компонентов. Часто становится очевидно, что правильным местом для хранения состояния является верхний уровень в иерархии. Подробнее об этом — в главе [Подъём состояния](https://ru.reactjs.org/docs/lifting-state-up.html).

> Примечание
> Приведённые ниже примеры были обновлены с использованием API-метода `React.createRef()` добавленного в React 16.3. Если вы используете более старую версию React, мы рекомендуем использовать [колбэк-рефы](https://ru.reactjs.org/docs/refs-and-the-dom.html#callback-refs).

##### Создание рефов

Рефы создаются с помощью `React.createRef()` и прикрепляются к React-элементам через `ref` атрибут. Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части компонента.

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();  }
  render() {
    return <div ref={this.myRef} />;  }
}
```

##### Доступ к рефам

Когда реф передаётся элементу в методе `render`, ссылка на данный узел доступна через свойство рефа `current`.

```
const node = this.myRef.current;
```

Значение рефа отличается в зависимости от типа узла:

-   Когда атрибут `ref` используется с HTML-элементом, свойство `current` созданного рефа в конструкторе с помощью `React.createRef()` получает соответствующий DOM-элемент.
-   Когда атрибут `ref` используется с классовым компонентом, свойство `current` объекта-рефа получает экземпляр смонтированного компонента.
-   **Нельзя использовать `ref` атрибут с функциональными компонентами**, потому что для них не создаётся экземпляров.

Представленные ниже примеры демонстрируют отличия в зависимости от типа узла.

###### Добавление рефа к DOM-элементу

В представленном ниже примере `ref` используется для хранения ссылки на DOM-элемент.

```
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // создадим реф в поле `textInput` для хранения DOM-элемента
    this.textInput = React.createRef();    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    // Установим фокус на текстовое поле с помощью чистого DOM API
    // Примечание: обращаемся к "current", чтобы получить DOM-узел
    this.textInput.current.focus();  }

  render() {
    // описываем, что мы хотим связать реф <input>
    // с `textInput` созданным в конструкторе
    return (
      <div>
        <input
          type="text"
          ref={this.textInput} />        <input
          type="button"
          value="Фокус на текстовом поле"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
```

React присвоит DOM-элемент свойству `current` при монтировании компонента и присвоит обратно значение `null` при размонтировании. Обновление свойства `ref` происходит перед вызовом методов `componentDidMount` и `componentDidUpdate`.

###### Добавление рефа к классовому компоненту

Для того чтобы произвести имитацию клика по `CustomTextInput` из прошлого примера сразу же после монтирования, можно использовать реф, чтобы получить доступ к пользовательскому `<input>` и явно вызвать его метод `focusTextInput`:

```
class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();  }

  componentDidMount() {
    this.textInput.current.focusTextInput();  }

  render() {
    return (
      <CustomTextInput ref={this.textInput} />    );
  }
}
```

Обратите внимание, что это сработает только в том случае, если `CustomTextInput` объявлен как классовый компонент:

```
class CustomTextInput extends React.Component {  // ...
}
```

###### Рефы и функциональные компоненты

По умолчанию **нельзя использовать атрибут `ref` с функциональными компонентами**, потому что для них не создаётся экземпляров:

```
function MyFunctionComponent() {  return <input />;
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();  }
  render() {
    // Данный код *не будет* работать!
    return (
      <MyFunctionComponent ref={this.textInput} />    );
  }
}
```

Если вам нужен реф на функциональный компонент, можете воспользоваться [`forwardRef`](https://ru.reactjs.org/docs/forwarding-refs.html) (возможно вместе с [`useImperativeHandle`](https://ru.reactjs.org/docs/hooks-reference.html#useimperativehandle)), либо превратить его в классовый компонент.

Тем не менее, можно **использовать атрибут `ref` внутри функционального компонента** при условии, что он ссылается на DOM-элемент или классовый компонент:

```
function CustomTextInput(props) {
  // textInput должна быть объявлена здесь, чтобы реф мог иметь к ней доступ  const textInput = useRef(null);
  function handleClick() {
    textInput.current.focus();  }

  return (
    <div>
      <input
        type="text"
        ref={textInput} />      <input
        type="button"
        value="Фокус на поле для ввода текста"
        onClick={handleClick}
      />
    </div>
  );
}
```

##### Передача DOM-рефов родительским компонентам

В редких случаях вам может понадобиться доступ к дочернему DOM-узлу из родительского компонента. В общем случае, такой подход не рекомендуется, т. к. ведёт к нарушению инкапсуляции компонента, но иногда он может пригодиться для задания фокуса или измерения размеров, или положения дочернего DOM-узла.

Несмотря на то, что можно было бы [добавить реф к дочернему компоненту](https://ru.reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-class-component), такое решение не является идеальным, т. к. вы получите экземпляр компонента вместо DOM-узла. Кроме того, это не сработает с функциональными компонентами.

Если вы работаете с React 16.3 или новее, мы рекомендуем использовать [перенаправление рефов](https://ru.reactjs.org/docs/forwarding-refs.html) для таких случаев. **Перенаправление рефов позволяет компонентам осуществлять передачу рефа любого дочернего компонента как своего собственного**. Вы можете найти детальные примеры того, как передать дочерний DOM-узел родительскому компоненту [в документации по перенаправлению рефов](https://ru.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components).

Если вы используете React версии 16.2 или ниже, или если вам нужно решение более гибкое, чем перенаправление рефов, вы можете использовать [данный альтернативный подход](https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509) и явно передавать реф как проп с другим именем.

По возможности, мы советуем избегать передачи DOM-узлов, но это может быть полезной лазейкой. Заметим, что данный подход требует добавления кода в дочерний компонент. Если у вас нет никакого контроля над реализацией дочернего компонента, последним вариантом является использование [`findDOMNode()`](https://ru.reactjs.org/docs/react-dom.html#finddomnode), но такое решение не рекомендуется и не поддерживается в [`StrictMode`](https://ru.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage).

##### Колбэк-рефы

Кроме того, React поддерживает другой способ определения рефов, который называется «колбэк-рефы» и предоставляет более полный контроль над их присвоением и сбросом.

Вместо того, чтобы передавать атрибут `ref` созданный с помощью `createRef()`, вы можете передать функцию. Данная функция получит экземпляр React-компонента или HTML DOM-элемент в качестве аргумента, которые потом могут быть сохранены или доступны в любом другом месте.

Представленный ниже пример реализует общий паттерн: использование колбэка в `ref` для хранения ссылки на DOM-узел в свойстве экземпляра.

```
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);

    this.textInput = null;
    this.setTextInputRef = element => {      this.textInput = element;    };
    this.focusTextInput = () => {      // Устанавливаем фокус на текстовом поле ввода с помощью чистого DOM API      if (this.textInput) this.textInput.focus();    };  }

  componentDidMount() {
    // устанавливаем фокус на input при монтировании
    this.focusTextInput();  }

  render() {
    // Используем колбэк в `ref`, чтобы сохранить ссылку на DOM-элемент
    // поля текстового ввода в поле экземпляра (например, this.textInput).
    return (
      <div>
        <input
          type="text"
          ref={this.setTextInputRef}        />
        <input
          type="button"
          value="Focus the text input"
          onClick={this.focusTextInput}        />
      </div>
    );
  }
}
```

React вызовет `ref` колбэк с DOM-элементом при монтировании компонента, а также вызовет его со значением `null` при размонтировании. Рефы будут хранить актуальное значение перед вызовом методов `componentDidMount` или `componentDidUpdate`.

Вы можете передавать колбэк-рефы между компонентами точно так же, как и объектные рефы, созданные через `React.createRef()`.

```
function CustomTextInput(props) {
  return (
    <div>
      <input ref={props.inputRef} />    </div>
  );
}

class Parent extends React.Component {
  render() {
    return (
      <CustomTextInput
        inputRef={el => this.inputElement = el}      />
    );
  }
}
```

В представленном выше примере, `Parent` передаёт свой колбэк-реф как проп `inputRef` компоненту `CustomTextInput`, а `CustomTextInput` передаёт ту же самую функцию как специальный атрибут `ref` элементу `<input>`. В итоге свойство `this.inputElement` компонента `Parent` будет хранить значение DOM-узла, соответствующего элементу `<input>` в `CustomTextInput`.

##### Устаревший API: строковые рефы

Если вы уже работали с React ранее, возможно вы знакомы с более старым API, в котором атрибут `ref` является строкой, например`"textInput"`, а DOM-узел доступен в `this.refs.textInput`. Мы не советуем пользоваться таким решением, т. к. у строковых рефов есть [некоторые недостатки](https://github.com/facebook/react/pull/8333#issuecomment-271648615), они являются устаревшими и **будут удалены в одном из будущих релизов**.

> Примечание
> 
> Если вы используете `this.refs.textInput` для доступа к рефам в своих проектах, мы рекомендуем перейти к использованию [паттерна с колбэком](https://ru.reactjs.org/docs/refs-and-the-dom.html#callback-refs) или [`createRef` API](https://ru.reactjs.org/docs/refs-and-the-dom.html#creating-refs).

##### Предостережения насчёт колбэк-рефов

Если `ref` колбэк определён как встроенная функция, колбэк будет вызван дважды во время обновлений: первый раз со значением `null`, а затем снова с DOM-элементом. Это связано с тем, что с каждым рендером создаётся новый экземпляр функции, поэтому React должен очистить старый реф и задать новый. Такого поведения можно избежать, если колбэк в `ref` будет определён с привязанным к классу контекстом, но, заметим, что это не будет играть роли в большинстве случаев.



