const arr = [10, 12, 15, 21]; for (var i = 0; i < arr.length; i++) { setTimeout(function() { console.log('Index: ' + i + ', element: ' + arr[i]); }, 3000); }
https://habr.com/ru/company/ruvds/blog/340194/

JS является динамическим и компилируемым языком.
Он проходит через 3 фазы обработки:
1. Лексический анализ (разбиение на токены)
2. Разбор - преобразование токенов в дерево вложенных элементов, которые в совокупности представляют грамматическую структуру программы
3. Генерирование кода - процесс преобразования AST в исполняемый код.

Участники процесса:
* Движок
* Компилятор
* Область видимости
	Собирает и ведет список всех объявленных идентификаторов (переменных) и устранавливает строгий набор правил их доступности для кода.

Объявим переменную var a = 2
1. Обнаружив var a, компилятор обращается к области видимости, чтобы узнать изм. переменной в наборе конкретной области видимости, если существует , то компилятор игнорирует обьявление и движок движется дальше.
2. Компилятор генерирует код для последующего выполнения движком обработки присваивания a=2
	если переменная доступна, то она используется для цели. Если нет, то движок ищет в другом месте.


## 1 Как создать элемент и добавить его на страницу?  
Ответ на вопрос:  [[0006 Создание, вставка и удаление элементов в JavaScript]]

### Создание элемента

Если записать результат работы **createElement** в переменную, то в этой переменной будет такой элемент, как будто бы мы получили его через **querySelector** или **getElementById**.  
  
Существует простой способ **задать класс элементу** через свойство **className** через обычное присваивание.

#### **createElement:  

Создание элемента в JavaScript выполняется с помощью метода **createElement:  
Например:**_  
// $elem – переменная, в которую сохраним созданный элемент  
(const $elem = document.createElement('tag');  
_**Вместо tag** необходимо указать тег того элемента, который нужно создать _(например <__p__>)_

Создание текстового элемента - метод **createTextNode:  
Например:  
**_const text = document.createTextNode('text');_
В аргументе **createTextNode** необходимо поместить текст, который должен иметь этот текстовый узел _(например: «Я новый текстовый узел»)_

### Вставить элемент

Чтобы созданный элемент (или текстовый узел) появился в нужном месте страницы его необходимо туда вставить.  
Существует множество методов. Одни из самых старых – **appendChild** и **insertBefore**.

#### **appendChild**
**appendChild** предназначен для вставки узла в конец элемента (т.е. после последнего его дочернего узла) для которого этот метод вызывается**_: ($elem.appendChild($node)_**;  
_Пример, можно добавить новый li в конец ol

#### **insertBefore**
**insertBefore** предназначен для вставки узла node перед **nextSibling в $elem:  
**_($elem.insertBefore(node, nextSibling);_

Если в качестве **nextSibling** передать **null**, **то данный метод вставит node** после последнего дочернего узла $elem. Т.е. выполнит действия аналогично appendChild.

**В качестве результата метод insertBefore возвращает вставленный узел.**

_Например, можно вставить новый элемент li перед третьим._


### **Современные методы вставки и замены  
 
JavaScript имеются следующие современные методы для вставки элементов и строк:

1. node.append – для добавления узлов или строк в конец node;
2. node.prepend – для вставки узлов или строк в начало node;
3. node.before – для вставки узлов или строк до node;
4. node.after – для вставки узлов или строк после node.

В JavaScript имеется набор методов **insertAdjacent**, которые позволяют вставить один или несколько узлов в указанную позицию **position** относительно **$elem.  
**Всего существует 3 таких метода:  
  
1. $elem.insertAdjacentElement(position, element) – для вставки элемента (element);  
2. $elem.insertAdjacentHTML(position, htmlString) – для вставки строки (htmlString) как HTML;  
3. $elem.insertAdjacentText(position, string) – для вставки строки (string);

Значение position, может быть, одним из следующих:  
1. 'beforebegin' – непосредственно перед $elem;  
2. 'afterbegin' – перед первым дочерним узлом $elem;  
3. 'beforeend' – после последнего дочернего узла $elem;  
4. 'afterend' – сразу после $elem;


### **DocumentFragment** 
**DocumentFragment** – это облегчённая версия Document. Он используется в качестве обёртки для временного хранения HTML элементов.

**DocumentFragment** в основном используется, когда необходимо вставить множество элементов на страницу, а также для элемента **template.  
**_(Например, переместить все четные li в новый ul

**Использование DocumentFragment** в подобных сценариях может значительно ускорить ваш сайт. Т.к. изменение DOM — это очень затратная операция. А с помощью DocumentFragment это можно сделать всего за одну операцию.

**DocumentFragment** не является частью видимой DOM. Изменения, внесенные во фрагмент, не влияют на документ и производительность страницы.

При использовании современных методов для вставки элементов можно не использовать **DocumentFragment**, т.к. в отличие от **appendChild и insertBefore** они позволяют вставлять сразу массив элементов.

**DocumentFragment** используется крайне редко, хотя он иногда незаменим, например, при создании шаблона документа.

### **Замена и клонирование узлов  

**Замену одних узлов другими в JavaScript можно выполнить с помощью методов **replaceChild** (когда нужна поддержка «старых» браузеров) и **replaceWith.**

#### **replaceChild**
**replaceChild** предназначен **для замены** одного дочернего узла **parentNode другим.  

Где: 1. newChild – элемент, которым необходимо заменить oldChild;  
       2. parentNode – родительский узел по отношению oldChild.
       
#### **node.replaceWith**

**node.replaceWith** позволяет node заменить заданными узлами или строками: (node.replaceWith(...nodes, strings)

**cloneNode** – клонирование узла
loneNode предназначен для создания копии узла:
let copy = node.cloneNode(deep);

1. node – узел, который нужно клонировать;  
2. copy – переменная, в которую нужно поместить новый узел, который будет копией node;  
3. deep – глубина клонирования (по умолчанию false, т.е. выполняется клонирование только самого элемента node без детей); если установить true, то node будет скопирован со всеми его детьми.

### Удаление узла из DOM

**Удалить узел из DOM** можно в JavaScript с помощью методов:  
1. **removeChild** (считается устаревшим) - необходимо вызвать метод removeChild у родительского элемента и передать ему в качестве аргумента его сам (node).  
2. **Remove** (Когда мы вставляем элементы, они удаляются со старых мест.)


### Добавить содержимое

![[Pasted image 20221216111750.png]]

### document.querySelector()

[`Document`](https://developer.mozilla.org/ru/docs/Web/API/Document) метод **`querySelector()`** возвращает первый элемент ([`Element`](https://developer.mozilla.org/ru/docs/Web/API/Element)) документа, который соответствует указанному селектору или группе селекторов. Если совпадений не найдено, возвращает значение `null`.

### document.getElementById()
Возвращает ссылку на элемент по его идентификатору ([ID (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Element/id "Currently only available in English (US)")); идентификатор является строкой, которая может быть использована для идентификации элемента; она может быть определена при помощи атрибута `id` в HTML или из скрипта.
element = document.getElementById(id);

### Свойство `innerHTML`

Свойство `innerHTML` позволяет считать содержимое элемента в виде HTML-строки или установить новый HTML.

Новое значение HTML необходимо передавать в виде строки и оно заменит текущее содержимое элемента. При передаче невалидной HTML-строки будет выброшена [ошибка](https://doka.guide/js/errors/). 
HTML-строкой является строка, которая содержит валидную HTML-разметку, в `innerHTML` нельзя передать DOM-элемент.

### Свойство `children` у DOM элемента
Свойство `children` хранит в себе [псевдомассив](https://www.code.mu/ru/javascript/manual/page/pseudo-array/) дочерних элементов. Дочерними элементами считаются все теги, которые непосредственно расположены внутри блока.
Давайте переберем в цикле всех потомков элемента и выведем их содержимое:
~~~
<div id="parent">
	<p>1</p>
	<p>2</p>
	<p>3</p>
	<p>4</p>
	<p>5</p>
</div>
let parent = document.querySelector('#parent');
let elems = parent.children;

for (let elem of elems) {
	console.log(elem.innerHTML);
}
~~~
Свойство `childNodes` хранит в себе [псевдомассив](https://www.code.mu/ru/javascript/manual/page/pseudo-array/) дочерних узлов элемента (теги, комментарии и текстовые узлы).

## 2 Какая полезная информация хранится в объекте события? 
Ответ на вопрос:  [[0010 Объект события]]

**Объект Event** описывает событие, произошедшее на странице. 
Одной из причин возникновения событий являются действия пользователя, такие как клики мышкой **MouseEvent** или ввод с клавиатуры **KeyboardEvent**. 
	Существует множество различных событий с разным набор информации.

Самый простой и широко распространённый **способ использования событий** — это отслеживание срабатывания кликов по каким-либо элементам на странице.

**Каждое событие может содержать дополнительные свойства** в зависимости от его типа, но список ниже есть у всех.  
  ### Свойства  
1. bubbles – является ли данное событие [всплывающим](https://doka.guide/js/events/#vsplytie-sobytiy).
2. cancelable – является ли событие отменяемым.
3. **currentTarget**– указывает на элемент, на котором установлен обработчик события. 
4. defaultPrevented – отменено ли поведение события по умолчанию.
5. eventPhase – указывает на фазу срабатывания события.
6. isTrusted – указывает на происхождение события, будет в значении true, если событие инициировано действиями пользователя. false - если событие инициировано из кода с помощью dispatchEvent().
7. **target** – ссылка на объект, которым было инициировано событие. 
   Например, если событие произошло на поле ввода, мы получим ссылку на этот DOM элемент.
8. timeStamp – время возникновения события в миллисекундах.
9. type – тип события.

### Методы  
1. composedPath() – вернёт массив элементов, на которых сработает событие.
2. preventDefault() – предотвращает дефолтное поведение события. Если вызвать этот метод на событии клика по ссылке, то переход по ссылке не произойдёт, но событие продолжит всплытие.
3. stopPropagation() – предотвращает всплытие события.
4. stopImmediatePropagation() – делает то же самое, что и stopPropagation, но в том числе предотвращает вызов обработчиков события, которые были установлены на этом же элементе.

**Обработчики событий, установленные на элемент, вызываются по порядку их установки.**


### В чем разница между event.target и event.currentTarget? 

JavaScript свойство **currentTarget** объекта [**Event**](https://basicweb.ru/javascript/js_event.php "Интерфейс Event") соответствует текущему элементу DOM, в котором в настоящий момент обрабатывается событие. Свойство доступно только для чтения.

Свойство **currentTarget** в отличие от [**target**](https://basicweb.ru/javascript/js_event_target.php "JavaScript свойство target объекта Event") объекта [**Event**](https://basicweb.ru/javascript/js_event.php "Интерфейс Event") всегда ссылается на элемент, к которому был присоединен обработчик события, а не на элемент, в котором произошло событие.

### Что добавляется в объект при обработке события клавиш?  

Бывают следующие типы событий клавиатуры:  
**1. keydown:** возникает при нажатии клавиши клавиатуры и длится, пока нажата клавиша  
**2. keyup:** возникает при отпускании клавиши клавиатуры  
**3. keypress:** возникает при нажатии клавиши клавиатуры, но после события keydown и до события keyup. Надо учитывать, что данное событие генерируется только для тех клавиш, которые формируют вывод в виде символов, например, при печати символов. Нажатия на остальные клавиши, например, на Alt, не учитываются.

Для работы с событиями клавиатуры определен объект **KeyboardEvent,** который добавляет к свойствам объекта **Event** ряд специфичных для клавиатуры свойств:  
1. altKey: возвращает true, если была нажата клавиша Alt во время генерации события  
2. key: возвращает символ нажатой клавиши, например, при нажатии на клавишу "T" это свойство будет содержать "T". А если нажата клавиша "Я", то это свойство будет содержать "Я"  
3. code: возвращает строковое представление нажатой клавиши физической клавиатуры QWERTY, например, при нажатии на клавишу "T" это свойство будет содержать "KeyT", а при нажатии на клавишу ";" (точка запятой), то свойство возвратит "Semicolon".

При использовании этого свойства следует учитывать ряд момент. Прежде всего используется клавиатура QWERTY. То есть мы переключим раскладку, к примеру, на русскоязычную и нажмем на клавишу "Я", то значением будет "KeyZ" - на клавиатуре QWERTY клавиша Z представляет ту же клавишу, что и на русскоязычной раскладке "Я"  
  

Другой момент - учитывается именно физическая клавитура. Если нажата клавиша на виртуальной клавиатуре, то возвращаемое значение будет устанавливаться браузером исходя из того, какой клавише на физической клавиатуре соответствовало нажатие.  
1. ctrlKey: возвращает true, если была нажата клавиша Ctrl во время генерации события  
2. metaKey: возвращает true, если была нажата во время генерации события метаклавиша клавиатуры  
3. shiftKey: возвращает true, если была нажата клавиша Shift во время генерации события


## 3 Какие есть события ?
Ответ на вопрос: [[0011 Виды событий]]

**Я могу назвать самые часто используемые** **DOM****-события:

**1. События мыши:**
1. click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
2. contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
3. mouseover / mouseout – когда мышь наводится на / покидает элемент.
4. mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
5. mousemove – при движении мыши.

**2. События на элементах управления:**
* submit – пользователь отправил форму form.
* focus – пользователь фокусируется на элементе, например нажимает на input.

**3. Клавиатурные события:**
* keydown и keyup – когда пользователь нажимает / отпускает клавишу.

**4. События документа:**
* DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

**5. CSS events:**
* *ransitionend – когда CSS-анимация завершена.

**Событию** можно назначить **_обработчик_**, то есть функцию, которая сработает, как только событие произошло.  
Именно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.:  
Есть три способа **назначения обработчиков событий:**

1. Атрибут HTML: onclick="...".
2. DOM-свойство: elem.onclick = function.
3. Специальные методы: elem.addEventListener(event, handler[, phase]) для добавления, removeEventListener для удаления.

**HTML-атрибуты** используются редко потому, что **JavaScript в HTML-теге** выглядит немного странно. К тому же много кода там не напишешь.

#### addEventListener

**addEventListener** — это способ зарегистрировать обработчик события.

**Сигнатура функции выглядит следующим образом:**

element.addEventListener(eventType (строка с названием страницы) , handler(функция, которую вызовет событие, options (дополнительные свойства))  

1. element — любой [HTMLElement](https://doka.guide/js/element/) на странице.  
2. eventType — строка, содержащая название события. Наиболее популярные события ['click'](https://doka.guide/js/element-click/), 'change', 'submit', ['keydown'](https://doka.guide/js/element-keydown-keyup/), 'mousemove', 'mouseenter', 'mouseleave'.  
3. handler — функция, которая будет вызвана, когда событие произойдёт.  
4. Options
* once: если true, тогда обработчик будет автоматически удалён после выполнения.
* capture**: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе [Всплытие и погружение](https://learn.javascript.ru/bubbling-and-capturing). Так исторически сложилось, что options может быть false/true, это то же самое, что {capture: false/true}.
* passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом будет рассказано в главе [Действия браузера по умолчанию](https://learn.javascript.ru/default-browser-action)

![[Pasted image 20221216133028.png]]
![[Pasted image 20221216133155.png]]

### Генерация пользовательских событий: Метод dispatchEvent
После того, как объект события создан, мы должны запустить его на элементе, вызвав метод `elem.dispatchEvent(event)`.

Затем обработчики отреагируют на него, как будто это обычное браузерное событие. 
Если при создании указан флаг `bubbles`, то оно будет всплывать.

В примере ниже событие `click` инициируется JavaScript-кодом так, как будто кликнули по кнопке:
~~~
<button id="elem" onclick="alert('Клик!');">Автоклик</button>

<script>
  let event = new Event("click");
  elem.dispatchEvent(event);
</script>
~~~
Свойство `event.isTrusted` принимает значение `true` для событий, порождаемых реальными действиями пользователя, и `false` для генерируемых кодом.

### Пользовательские события
Для генерации событий совершенно новых типов, таких как `"hello"`, следует использовать конструктор `new CustomEvent`. Технически [CustomEvent](https://dom.spec.whatwg.org/#customevent) абсолютно идентичен `Event` за исключением одной небольшой детали.

У второго аргумента-объекта есть дополнительное свойство `detail`, в котором можно указывать информацию для передачи в событие.

Например:
~~~
<h1 id="elem">Привет для Васи!</h1>

<script>
  // дополнительная информация приходит в обработчик вместе с событием
  elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "Вася" }
  }));
</script>
~~~

Свойство `detail` может содержать любые данные. Надо сказать, что никто не мешает и в обычное `new Event` записать любые свойства. Но `CustomEvent` предоставляет специальное поле `detail` во избежание конфликтов с другими свойствами события.

Кроме того, класс события описывает, что это за событие, и если оно не браузерное, а пользовательское, то лучше использовать `CustomEvent`, чтобы явно об этом сказать.

#### **Какие значения он принимает

**DOM-свойства** вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события. Во многих случаях с этим ограничением можно мириться.

Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, к примеру transitionend и DOMContentLoaded. Также addEventListener поддерживает объекты в качестве обработчиков событий. В этом случае вызывается метод объекта handleEvent.


## 4 Что происходит при возникновении события (всплытие/погружения)? 

Когда некоторый объект инициирует событие, то оно не просто возникает на нём, а распространяется в документе определённым образом.

Согласно стандарту, оно делится на 3 фазы:

1.  Фаза погружения или захвата – от `window` к родителю цели (цель – это объект, который инициировал это событие).
2.  Фаза цели – событие на цели.
3.  Фаза всплытия – обратно, от родителя цели к `window`.

Самое главное для нас, когда событие путешествует по документу, то браузер вызывает обработчики элементов, через которые оно проходит.

### Если коротко
В HTML DOM существует два способа распространения события - всплытие и погружение:

UseCapture - По умолчанию этот параметр имеет значение false, что задает _всплытие_ события. Если задать ему значение true, то будет использоваться _перехват_.

При _всплытии_ первым обрабатывает событие самый вложенный элемент, затем его родитель и т.д.: таким образом сначала обрабатывать событие "click" будет элемент p, а затем элемент div.

При _перехвате_ все происходит наоборот — сначала событие обрабатывает самый внешний элемент, в нашем случае div, а затем вложенный, т. е. элемент p.

### Подробнее:  [[0009 Всплытие и погружение событий]]
1. Задали значение btn
2. Задали const buttons и выбрали все элементы этих кнопок, вывели в консоль
![[Pasted image 20221216133344.png]]
Для того, чтобы повесить обработчик событий на наши кнопки, мы используем цикл.
И будем вешать обработчик событий для каждой кнопки. Используем for each
![[Pasted image 20221216133606.png]]
В консоль выводятся все клики на все кнопки. Возникает вопрос, как понять на какую кнопку нажимает пользователь. Используем объект event внутри нашей функции, которую мы передаем в метод addEvenListiner
![[Pasted image 20221216133818.png]]


### Какое поведение по умолчанию, как манипулировать?  

Действий браузера по умолчанию достаточно много:

* mousedown – начинает выделять текст (если двигать мышкой).
* click на <input type="checkbox"> – ставит или убирает галочку в input.
* submit – при нажатии на <input type="submit"> или при нажатии клавиши Enter в форме данные отправляются на сервер.
* keydown – при нажатии клавиши в поле ввода появляется символ.
* contextmenu – при правом клике показывается контекстное меню браузера.
* …и многие другие…

**Чтобы отменить действие браузера по умолчанию:**  
1. **Основной способ** – это воспользоваться объектом event. Для отмены действия браузера существует стандартный метод event.preventDefault().  
2. Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика.  
  
Опция passive: true для addEventListener сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных устройствах, таких как touchstart и touchmove, чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а ему следует сразу приступать к выполнению действия по умолчанию, например, к прокрутке.

Если событие по умолчанию отменено, то значение event.defaultPrevented становится true, иначе false.

### Для каких событий нельзя отменить действия по умолчанию? (preventDefault)
Ответ на вопрос: [[0015 Зачем нужен метод preventdefault]]

Не для всех событий можно отменить действие по умолчанию. 

Например, событие прокручивания страницы `scroll` проигнорирует попытки отменить его. 
Чтобы узнать, можно отменить действие по умолчанию или нет, нужно обратиться к свойству `cancelable` объекта `Event`. Оно будет равно `true`, если событие можно отменить, и `false` — в обратном случае.

## 5 Замыкания 
Ответ на вопрос:  [[0019 Замыкание]]

[Замыкание](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. Все функции изначально являются замыканиями  
	Другими словами – замыкание возникает в том случае, если мы из одной функции возвращаем новую функцию. Тогда мы говорим, что новая функция замкнута на область видимости родительской.
		Еще проще это функция внутри другой функции

![[Pasted image 20221216134913.png]]
42 000
Функция 1 отработала и вернула нам новую функцию 2, тк 2ая функция была вызвана в контексте 1ой, то переменная n была замкнута в той функции, которую мы возвращаем.
Поэтому в функции 8 хранится значение n. Её замкнуло. Поэтому, мы получаем доступ к этой функции.

![[Pasted image 20221216135256.png]]
1+10

## 6 Области видимости var/let? (Изучите поподробнее)  
Ответ на вопрос:  [[0016 Var, let или const]]

Области видимости объекта (переменной или функции) определяет набор функций или модулей, внутри которых допустимо использование имени этого объекта. Область видимости объекта начинается в точке объявления объекта. 

Все , что объявлено внутри функции -снаружи не видно, а все, что объявлено снаружи - может быть доступно изнутри функции, если внутри нее нет такой переменноq

#### Локальные и глобальные переменные
Глобальными называют объекты, объявление которых дано вне функции. 
Они доступны (видимы) во всем файле, в котором они объявлены. В течение всего времени выполнения программы с глобальным объектом ассоциирована некоторая ячейка памяти.  


Локальными называют объекты, объявление которых дано внутри блока или функции. 
Эти объекты доступны только внутри того блока, в котором они объявлены. 
Объектам с локальным временем жизни выделяется новая ячейка памяти каждый раз при осуществлении описания внутри блока. Когда выполнение блока завершается, память, выделенная под локальный объект, освобождается, и объект теряет своё значение.
![[Pasted image 20221216141003.png]]
is not defined
![[Pasted image 20221216141103.png]]
100
![[Pasted image 20221216141402.png]]
100

#### Блочная область видимости
  
Блок кода в JavaScript определяет область видимости переменных, объявленных с помощью ключевых слов const и let:  
  
```
if (true) {
    // область видимости блока if
    const message = 'Hello'
    console.log(message) // 'Hello'
}
console.log(message) // ReferenceError
```
 
Первый console.log() благополучно выводит значение переменной message в консоль, поскольку доступ к этой переменной осуществляется в той области видимости, в которой она определена.  
  
Однако вызов второго console.log() приводит к возникновению ошибки, поскольку переменная message недоступна во внешней по отношению к ней области видимости: в текущем контексте message не существует.  

##### if, for, while
В инструкциях if, for, while также создается блочная область видимости.  
  Например:  
  
```
for (const color of ['green', 'red', 'blue']) {
    // область видимости блока for
    const message = 'Hi'
    console.log(color) // 'green', 'red', 'blue'
    console.log(message) // 'Hi', 'Hi', 'Hi'
}
console.log(color) // ReferenceError
console.log(message) // ReferenceError
```

  Переменные color и message существуют только внутри блока for.  

##### while 
Тоже самое справедливо для инструкции while:  
  ```
while (/* условие */) {
    // область видимости блока while
    const message = 'Hi'
    console.log(message) // 'Hi'
}
console.log(message) // ReferenceError
```
 
message, определенная в while, доступна только внутри данного цикла.  
  
В JavaScript вы можете создавать самостоятельные блоки кода. 
Они также определяют собственную область видимости:  
  
```
{
    const message = 'Hi'
    console.log(message) // 'Hi'
}
console.log(message) // ReferenceError
```

#### Область видимости функции

Функции в JavaScript создают область видимости для всех переменных, независимо от того, с помощью какого ключевого слова они объявлены (var, const или let).  
  
Например:  
  ```
function run() {
    // область видимости функции run()
    var message = 'Беги, Форрест, беги!'
    console.log(message)
}
run() // 'Беги, Форрест, беги!'
console.log(message) // ReferenceError
```
  
Функция run() создает область видимости. Переменная message доступна внутри функции, но недоступна снаружи.  
  
Аналогичным образом функция создает область видимости для переменных, объявленных с помощью const и let, и даже для других функций и функциональных выражений:  
  ```
function run() {
    // область видимости функции run()
    const two = 2
    let one = 1
    function run2() {}
    var run3 = () => {}

    console.log(two)
    console.log(one)
    console.log(run2)
    console.log(run3)
}
run() // 2 1 ƒ run2() {} () => {}
console.log(two) // ReferenceError
console.log(one) // ReferenceError
console.log(run2) // ReferenceError
console.log(run3) // ReferenceError
```

#### Область видимости модуля
  
Модули ES6 также создают область видимости для переменных, функций и классов.  
  Модуль circle создает константу pi (для внутреннего использования):  
  ```
// область видимости модуля circle
const pi = 3.14

console.log(pi) // 3.14

// использование pi
```

Переменная pi объявляется внутри модуля circle и не экспортируется из него.  
  Затем модуль circle импортируется:  
  
```
import './circle'

console.log(pi) // ReferenceError
```

  Переменная pi недоступна за пределами модуля circle (до тех пор, пока она не будет экспортирована с помощью export).  
  
Модульная область видимости инкапсулирует модули. 
Это означает, что частные переменные (которые не экспортируются) используются для собственных нужд модуля и защищены от доступа извне.  
  
Таким образом, можно сказать, что область видимости — это механизм инкапсуляции для блоков кода, функций и модулей.

### О создании переменных let, const, var

Переменные в **JavaScript** можно создавать тремя способами — c помощью ключевых слов var, let и const. 

Они выполняют одну и ту же функцию (объявляют о создании именованной ячейки в памяти), но работают немного по-разному.  

**Область видимости** по существу своему указывает на то, где данные переменные доступны для использования.

### VAR

1. Любая переменная, объявленная через **var** вне блока функции, доступна для использования во всем окне.  
2. **Var** является локальной, когда объявлена внутри функции. Это означает, что она доступна и к ней можно обращаться только изнутри этой функции.
3. Переменные **var** могут быть объявлены повторно или обновлены
4.  Переменные **var** поднимаются в верхнюю часть своей области видимости и инициализируются со значением undefined

**Поднятие var:** переменные var поднимаются в верхнюю часть своей области видимости и инициализируются со значением undefined.

### LET

1. **let** выступает в качестве улучшения объявления через **var**
2. let имеет блочную область видимости (т.е переменная, объявленная в блоке через let, будет доступна только внутри этого блока)
3. Переменные let могут быть обновлены, но не объявлены повторно (в отличие от var, let-переменные нельзя повторно объявить внутри области видимости)

**Поднятие** let Точно так же, как в случае с var, объявления через let перемещаются вверх. Но в отличие от var-переменных, которые инициализируются как undefined, ключевое слово для let не инициализируется. Так что если вы попытаетесь использовать переменную let до того, как она будет объявлена, то получите ошибку обращения к переменной **ReferenceError.**

### CONST

1. Переменные, объявленные через const, сохраняют постоянные значения. Объявления через const имеют некоторое сходство с объявлениями через let.
2. **const имеет блочную область видимости**
3. Переменные const не могут быть ни обновлены, ни объявлены повторно

**Поднятие const:** точно так же, как и let, объявления через const перемещаются вверх, но не инициализируются.  
  
### **Отличия

1. Переменные, объявленные через **var**, могут быть глобальными или иметь область видимости в рамках функции; **let** и **const** имеют блочную область видимости.  
2. **var**-переменные могут быть как обновлены, так и переопределены внутри области видимости; **let**-переменные можно обновлять, но не переопределять; **const**-переменные нельзя ни обновлять, ни переопределять.  
3. Со всеми ними осуществляется поднятие наверх области видимости. Но если **var**-переменные при этом инициализируются как **undefined**, let и const не инициализируются.  
4. В то время как **var** и **let** можно объявить, но не инициализировать, **const** необходимо инициализировать во время объявления.

## 7 Явное и неявное преобразование  
Ответ на вопрос: [[1.4.2 Подробнее про преобразование типов]]

**Существуют** **простые** **и** **сложные** **типы** **данных****.**

Простые:  
1. **number** для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).  
2. **bigint** для целых чисел произвольной длины.  
3. **string** для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.  
4. **boolean** для true/false.  
5. **null** для неизвестных значений – отдельный тип, имеющий одно значение null.  
6. **undefined** для неприсвоенных значений – отдельный тип, имеющий одно знач. **undefined.**  
7. **symbol** для уникальных идентификаторов.

Сложные: 1. **Array** 2. **Object

В JavaScript типы можно преобразовывать явно и неявно.
Когда мы вызываем функцию, чтобы получить конкретный тип — это явное преобразование:

Такая типизация, при которой тип значения определяется во время присвоения, а по ходу программы может меняться, — называется [динамической](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F).

Неявное преобразование происходит, когда мы заставляем JavaScript работать со значениями разных типов. Например, если мы хотим «сложить» число и строку:

```
5 + '3' === '53'
5 - '3' === 2
5 + '-3' === '5-3'
5 - +3 === 2
5 + -3 === 2

// Из-за этого же появилась и такая шутка:
Array(16).join('wat' - 1) + ' Batman!'
// 'NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!'
```

