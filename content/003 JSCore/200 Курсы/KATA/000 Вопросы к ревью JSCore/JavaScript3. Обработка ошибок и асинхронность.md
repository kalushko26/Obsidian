[Интересный цикл статей про работу JS](https://habr.com/ru/company/ruvds/blog/340508/)

# Асинхронность
#### 1. Что такое #асинхронность? 

`// загрузит и выполнит скрипт loadScript('/my/script.js');`

#Асинхронность это модель поведения. 
Например,  у нас есть две строчки кода, первая за второй. Первая строка это код которому нужно время. Итак, первая строка начинает запуск в фоновом режиме, позволяя второй строке запуститься без ожидания завершения первой строки.

	Такие функции называют «асинхронными», потому что действие (загрузка скрипта) будет завершено не сейчас, а потом.

#### 2. Где исполняются асинхронные функции?

При вызове какой-то функции она попадает в так называемый стек вызовов.

#stack  — это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым _(LIFO: last in, first out)._ Стек похож на стопку книг: та книга, которую мы кладём последней, находится сверху.

В стеке вызовов хранятся функции, до которых дошёл интерпретатор, и которые надо выполнить.

Теперь посмотрим, как ведёт себя стек вызовов при работе с асинхронным кодом:
~~~
function main() {   
	setTimeout(function greet() {     
		console.log('Hello!')   }, 2000)    
	
	console.log('Bye!') }  main()`
~~~
Вызываем функцию `main()`. 
Стек: `main();`

Вызываем `setTimeout()`. 
Стек: `setTimeout(); main();`

`setTimeout` завершился, он выходит из стека:
`main();`

Вызываем `console.log('Bye!')`:
`console.log('Bye!'); main();`
Его вызов завершён, он выходит из стека:

`main();`
Вызов `main()` тоже завершён, стек становится пуст.

Проходит около 2 секунд, вызывается функция `greet()`, она попадает в стек:
`greet();`

Она вызывает `console.log('Hello!')`:
`console.log('Hello!'); greet();`

Отработав, она уходит из стека:
`greet();`

После выполнения всего блока стек снова становится пустым.

#### 3. Сколько потоков исполнения у JS? 
Подробнее: https://otus.ru/journal/java-script-i-potoki-poleznaya-informaciya-o-mnogopotochnosti/

JavaScript сам по себе однопоточный, что означает то, что только один блок кода может запускаться за раз. 
Так как движок JS выполняет наш код, обрабатывая строку за строкой, он использует один стек вызова, чтобы продолжать отслеживать код, который выполняется в соответствии с установленным порядком. Тоже самое, что и делает стек — структура данных, которая записывает строки выполняемых инструкций и выполняет их в стиле `LIFO`, то есть `Last In First Out`, что переводится как, “последний пришел — первый обслужен”. 

Давайте посмотрим на живом примере как это происходит и работает, вот `function foo() { foo()` отправляется в стек и затем, когда выполнение `foo()` доходит до `return;} foo()` прекращается и выкидывается из стека вызовов.

![](https://stasonmars.ru/wp/wp-content/uploads/2021/02/1_k62uibx1CIMcNkKwCq38iA.png)

Что происходит в **Exercise 1**: Итак, схема выше показывает нам типичное линейное выполнение кода. Когда код из трех `console.log` объявлений отдается в JS.

Шаг 1: `console.log("Print 1")` отправляется в стек вызовов и выполняется, после того, как процесс завершится, он будет выкинут из стека. Теперь стек пуст и готов к следующим инструкциям на выполнение.

Шаг 2: Следующей инструкцией на выполнение является `console.log("Print 2");`, который также отправляется в стек и после выполнения оттуда также выкидывается. Всё повторяется до тех пор, пока не останется ничего для выполнения.  

#### 4. #Многопоточность против асинхронного программирования
###### Коротко о главном

Из приведенных нами определений мы можем видеть, что **многопоточное программирование - это одновременное выполнение различных функций. Асинхронное программирование - это неблокирующее выполнение между функциями**, и мы можем применять асинхронность при однопоточном или многопоточном программировании.

Итак, многопоточность - это одна из форм асинхронного программирования.

Давайте проведем простую аналогию; у вас есть друг, и вы решили вместе приготовить ужин.

Асинхронность - это когда вы говорите своему другу: “Ты идешь в магазин и покупаешь макароны. **Дай мне знать, когда вернешься**, чтобы вместе приготовить ужин. **Тем временем я приготовлю соус и напитки** ”.

Многопоточность - это “вы кипятите воду. Я подогрею томатный соус. Пока вода кипит, спросите меня, и я положу макароны. Когда соус остынет, можно добавить сыр. Когда оба будут сделаны, я сяду, а вы подадите ужин. Затем мы едим ”. **В аналогии с потоками мы можем видеть последовательность событий “Когда, сделай”, которые представляют последовательный набор инструкций для каждого пользователя (потока).**

Из этой аналогии мы можем сделать вывод, что **_многопоточность_ касается рабочих, _асинхронность_ - задач.**

**Выбор между двумя моделями программирования зависит в основном от _производительности_.**

Учитывая все возможные комбинации между синхронизацией / асинхронностью и однопоточностью / многопоточностью, какая модель должна работать лучше?

**В двух словах, для крупномасштабных приложений с большим количеством операций ввода-вывода и различных вычислений, использование асинхронного многопоточного потока программирования будет использовать вычислительные ресурсы и заботиться о неблокирующих функциях.**Это модель программирования любой ОС!

С большей мощностью приходит больше ответственности! Итак, если мы решили реализовать эту модель, мы должны позаботиться о различных проблемах, таких как состояние гонки, взаимоблокировки, общие ресурсы и события обратного вызова.

###### Конкурентность (concurrency)

Конкурентность (*) #concurrency - это наиболее общий термин, который говорит, что одновременно выполняется более одной задачи. Например, вы можете одновременно смотреть телевизор и комментить фоточки в фейсбуке. Винда, даже 95-я могла (**) одновременно играть музыку и показывать фотки.

(*) К сожалению, вменяемого русскоязычного термина я не знаю. Википедия говорит, что concurrent computing - это параллельные вычисления, но как тогда будет parallel computing по русски?

(**) Да, вспоминается анекдот про Билла Гейтса и многозадачность винды, но, _теоретически_ винда могла делать несколько дел одновременно. Хотя и не любых.

Конкурентное исполнение - это самый общий термин, который не говорит о том, каким образом эта конкурентность будет получена: путем приостановки некоторых вычислительных элементов и их переключение на другую задачу, путем действительно одновременного исполнения, путем делегации работы другим устройствам или еще как-то. Это не важно.

_Конкурентное исполнение_ говорит о том, что за определенный промежуток времени будет решена более, чем одна задача. Точка.

###### Параллельное исполнение

Параллельное исполнение (parallel computing) подразумевает наличие более одного вычислительного устройства (например, процессора), которые будут _одновременно_ выполнять несколько задач.

Параллельное исполнение - это строгое подмножество конкурентного исполнения. Это значит, что на компьютере с одним процессором параллельное программирование - невозможно;)

###### Многопоточность

#Многопоточность - это один из способов реализации конкурентного исполнения путем выделения абстракции "рабочего потока" (worker thread).

Потоки "абстрагируют" от пользователя низкоуровневые детали и позволяют выполнять более чем одну работу "параллельно". Операционная система, среда исполнения или библиотека прячет подробности того, будет многопоточное исполнение конкурентным (когда потоков больше чем физических процессоров), или параллельным (когда число потоков меньше или равно числу процессоров и несколько задач физически выполняются одновременно).

###### Асинхронное исполнение

#Асинхронность (asynchrony) подразумевает, что операция может быть выполнена кем-то на стороне: удаленным веб-узлом, сервером или другим устройством за пределами текущего вычислительного устройства.

Основное свойство таких операций в том, что начало такой операции требует значительно меньшего времени, чем основная работа. Что позволяет выполнять множество асинхронных операций одновременно даже на устройстве с небольшим числом вычислительных устройств.

###### CPU-bound и IO-Bound операции

Еще один важный момент, с точки зрения разработчика - разница между CPU-bound и IO-bound операциями. CPU-Bound операции нагружают вычислительные мощности текущего устройства, а IO-Bound позволяют выполнить задачу вне текущей железки.

Разница важна тем, что число одновременных операций зависит от того, к какой категории они относятся. Вполне нормально запустить параллельно сотни IO-Bound операций, и надеяться, что хватит ресурсов обработать все результаты. Запускать же параллельно слишком большое число CPU-bound операций (больше, чем число вычислительных устройств) бессмысленно.

---

Возвращаясь к исходному вопросу: нет смысла выполнять в 1000 потоков метод `Calc`, если он является CPU-Intensive (нагружает центральный процессор), поскольку это приведет к падению общей эффективности вычислений. ОС-ке придется переключать несколько доступных ядер для обслуживания сотен потоков. А этот процесс не является дешевым.

Самым простым и эффективным способом решения CPU-Intensive задачи, заключается в использовании идиомы Fork-Join: задачу (например, входные данные) нужно разбить на определенное число подзадач, которые можно выполнить параллельно. Каждая подзадача должна быть независимой и не обращаться к разделяемым переменным/памяти. Затем, нужно собрать промежуточные результаты и объединить их.

Именно на этом принципе основан PLINQ. О чем можно почитать тут: [Джозеф Албахари. Параллельное программирование](http://sergeyteplyakov.blogspot.com/2010/09/51.html).

Выглядит это очень интересно:

```csharp
IEnumerable<Data> yourData = GetYourData();
var result = yourData.AsParallel() // начинаем обрабатывать параллельно
  .Select(d => ComputeMD5(d)) // Вычисляем параллельно
  .Where(md5 => IsValid(md5))
  .ToArray(); // Возврвщаемся к синхронной модели
```

В этом случае, число потоков будет контролироваться библиотечным кодом в недрах CLR/TPL и метод `ComputeMD5` будет вызван параллельно N-раз на компьютере с N-процессорами (ядрами).


#### 5. Что такое #Eventloop, очередь задач, #microtask и #macrotask?  
Подробнее: [[1.1.1 Событийный цикл. Микрозадачи и макрозадачи]] , [[1.5.3 Объяснение работы EventLoop в JavaScript]]  ,  [Интересная статья про EventLoop](https://habr.com/ru/post/461401/)

Единственное место, через которое задачи могут попасть в #CallStack и выполниться — это #EventLoop.
	Задачи могут быть трех типов:
	* #microtask 
	* #macrotask (приоритетенее)
	* обработка через рендер (визуализация сайта)

![[Pasted image 20230218194535.png]]

Идея #событийный-цикл очень проста.
Есть бесконечный цикл, в котором движок JavaScript ожидает задачи (реагирование на движение мыши, обработка событий мыши, загрузка внешнего скрипта, setTimeout и др), исполняет их и снова ожидает появления новых.

Очередь, которую формируют такие задачи, называют #очередь-макрозадач
![[Pasted image 20230218132810.png]]
_Рисунок 2 Очередь макрозадач и событийный цикл

Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл». Когда браузер заканчивает выполнение скрипта, он обрабатывает событие `mousemove`, затем выполняет обработчик, заданный `setTimeout`, и так далее.

Помимо _макрозадач, существуют микрозадачи.

Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь `PromiseJobs`, более известную как #очередь-микрозадач (microtask queue)».

Микрозадачи приходят только из кода. Обычно они создаются #promise : выполнение обработчика `.then/catch/finally` становится микрозадачей. Микрозадачи также используются «под капотом» `await`, т.к. это форма обработки промиса.

Также есть специальная функция `queueMicrotask(func)`, которая помещает `func` в очередь микрозадач.

Если у кого-то из заказчиков не оказалось задач, то Event Loop просто идет к следующему. 
И, наоборот, если у заказчика задачи занимают много времени, то остальные заказчики будут ждать своей очереди. А если задачи от какого-то заказчика оказались бесконечными, то #CallStack переполняется, и браузер начинает ругаться:

![[Pasted image 20230218195348.png]]
_Рисунок 3 Страница не отвечает

Есть код: 

~~~
`let promise = Promise.resolve();  
promise.then(() => alert("промис выполнен"));  
alert("код выполнен"); // этот alert показывается первым`
~~~

Или, проще говоря, когда промис выполнен, его обработчики `.then/catch/finally` попадают в #очередь-микрозадач. Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.

Вот почему сообщение «код выполнен» в примере выше будет показано первым.

На основе этой схемы строится вся работа Event Loop.

###### Упрощенный алгоритм 

1.  Выбрать и исполнить старейшую задачу из очереди _макрозадач_ (например, «script»).
2.  Исполнить все _микрозадачи_:
    -   Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
3.  Отрисовать изменения страницы, если они есть.
4.  Если очередь макрозадач пуста – подождать, пока появится макрозадача.
5.  Перейти к шагу 1.

#### 6. Как работают таймеры #setTimeout / #setInterval? Зачем делать рекурсивный таймер? В чём отличие в работе межу setInterval и рекурсивным setTimeout? Как отменять таймеры и зачем это нужно?
Подробнее: [[1.1.2 Планирование setTimeout и setInterval]]

Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. 
Это называется «планирование вызова».

Для этого существуют два метода:
-   #setTimeout позволяет вызвать функцию **один раз** через определённый интервал времени.
-   #setInterval  позволяет вызывать функцию **регулярно**, повторяя вызов через определённый интервал времени.

###### setTimeout

Синтаксис:  `let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);`

Параметры:
`func|code`  Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.

`delay` Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.

`arg1`, `arg2`…  Аргументы, передаваемые в функцию

Например, данный код вызывает `sayHi()` спустя одну секунду:
~~~
`function sayHi() {   
	alert('Привет'); }  _
	setTimeout(sayHi, 1000);_`
~~~
С аргументами:
~~~
`function sayHi(phrase, who) {   
	alert( phrase + ', ' + who ); }  _
	setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон_`
~~~
Если первый аргумент является строкой, то JavaScript создаст из неё функцию.

###### setInterval

Метод `setInterval` имеет такой же синтаксис как `setTimeout`:
`let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);`

Все аргументы имеют такое же значение. Но отличие этого метода от `setTimeout` в том, что функция запускается не один раз, а периодически через указанный интервал времени.

###### Рекурсивный setTimeout

Применение вложенного `setTimeout`:
~~~
`let i = 1; 
setTimeout(function run() {   
	func(i);   
	setTimeout(run, 100); }, 100);`
~~~

Ниже представлено изображение, показывающее процесс работы рекурсивного `setTimeout`:
![[Pasted image 20230219222937.png]]

**Вложенный`setTimeout` гарантирует фиксированную задержку (здесь 100 мс).**
Это потому, что новый вызов планируется в конце предыдущего.

###### Отличие setInterval и рекурсивного setTimeout

Применение  `setInterval`:
~~~
`let i = 1; 
setInterval(function() {   
	func(i); }, 100);`
~~~

Для `setInterval` внутренний планировщик будет выполнять `func(i)` каждые 100 мс:
![[Pasted image 20230219222917.png]]
**Реальная задержка между вызовами `func` с помощью `setInterval` меньше, чем указано в коде!**
Это нормально, потому что время, затраченное на выполнение `func`, использует часть заданного интервала времени.

Вполне возможно, что выполнение `func` будет дольше, чем мы ожидали, и займёт более 100 мс.
В данном случае движок ждёт окончания выполнения `func` и затем проверяет планировщик и, если время истекло, _немедленно_ запускает его снова.

###### Как отменять таймеры и зачем это нужно?

Вызов `setTimeout` возвращает «идентификатор таймера» `timerId`, который можно использовать для отмены дальнейшего выполнения.

Синтаксис для отмены:
`let timerId = setTimeout(...); clearTimeout(timerId);`

В коде ниже планируем вызов функции и затем отменяем его (просто передумали). 
В результате ничего не происходит:
~~~
let timerId = setTimeout(() => alert("ничего не происходит"), 1000); 
alert(timerId); // идентификатор таймера  
clearTimeout(timerId); 
alert(timerId); // тот же идентификатор (не принимает значение null после отмены)`
~~~
Как мы видим из вывода `alert`, в браузере идентификатором таймера является число. В других средах это может быть что-то ещё. Например, Node.js возвращает объект таймера с дополнительными методами.

Повторюсь, что нет единой спецификации на эти методы, поэтому такое поведение является нормальным.

Для браузеров таймеры описаны в [разделе таймеров](https://www.w3.org/TR/html5/webappapis.html#timers) стандарта HTML5.

#### 7. Что такое #callback функция? Почему возникает callback hell?
Подробнее: [[1.2 CallBack функции]]

###### Что такое callback функция?

#CallBack — это функция, которая должна быть выполнена после того, как другая функция завершит работу. Создадим собственную функцию обратного вызова.  
  
Для начала — откройте консоль разработчика Chrome (`Ctrl + Shift + J` в Windowsи введите следующее:  

```
function doHomework(subject) {
  alert(`Starting my ${subject} homework.`);
}
```

Тут мы объявили функцию `doHomework()`. Эта функция принимает одну переменную — название предмета, по которому некто делает домашнюю работу. Вызовите функцию, введя в консоли следующее:  
  
```
doHomework('math');
// Выводит сообщение: Starting my math homework.
```

Теперь добавим, в качестве второго аргумента функции `doHomework()`, параметр `callback`, который будем использовать для того, чтобы передать `doHomework()` функцию обратного вызова. Теперь код будет выглядеть так:  
  
```
function doHomework(subject, callback) {
  alert(`Starting my ${subject} homework.`);
  callback();
}
```

Вызовем обновлённую функцию следующими образом:  
  
```
doHomework('math', function() {
  alert('Finished my homework');
});
```

Сначала будет выведено сообщение с текстом `Starting my math homework.`, потом — с текстом `Finished my homework`.  
  
Функции обратного вызова совсем необязательно создавать непосредственно при вызове функций, которым они передаются. Такую функцию можно объявить и где-нибудь в коде:  
  
```
function doHomework(subject, callback) {
  alert(`Starting my ${subject} homework.`);
  callback();
}
function alertFinished(){
  alert('Finished my homework');
}
doHomework('math', alertFinished);
```

После вызова функции `doHomework()` всё будет выглядеть точно так же, как в предыдущем примере. Различия заключаются лишь в том, как мы работаем с функцией обратного вызова.  
  
###### Почему возникает callback hell?

#Callback может выполнять асинхронные действий: то есть действия, которые выполняются друг за другом.

~~~
loadScript('1.js', function(error, script) {    
	if (error) {     
		handleError(error);   
	} else {     // ...     
		loadScript('2.js', 
		function(error, script) {       
			if (error) {         
				handleError(error);       
			} else {         // ...         
				loadScript('3.js', 
				function(error, script) {           
					if (error) {             
						handleError(error);           
						} else {   // ...и так далее, пока все скрипты не будут загружены (*)
						}         });        }     })   } });`
~~~

В примере выше:
1.  Мы загружаем `1.js`. Продолжаем, если нет ошибок.
2.  Мы загружаем `2.js`. Продолжаем, если нет ошибок.
3.  Мы загружаем `3.js`. Продолжаем, если нет ошибок. И так далее `(*)`.

Чем больше вложенных вызовов, тем наш код будет иметь всё большую вложенность, которую сложно поддерживать, особенно если вместо `...` у нас код, содержащий другие цепочки вызовов, условия и т.д.
Иногда это называют «адом колбэков» или «адской пирамидой колбэков».

`Такой подход к написанию кода не приветствуется`
Лучший способ избежать применения #callback-hell использовать #promise .




#### 8. Что такое #promise? Как они решают проблему callback hell?

#Promise – это специальный объект в JS, который связывает «создающий» и «потребляющий» коды вместе. 

Синтаксис создания `Promise`:
~~~
let promise = new Promise(function(resolve, reject) {   
// функция-исполнитель (executor)   // "певец" });`
~~~
Функция, переданная в конструкцию `new Promise`, называется _исполнитель_ (executor). Когда `Promise` создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.
Её аргументы `resolve` и `reject` – это колбэки, которые предоставляет сам JavaScript. 
Наш код – только внутри исполнителя.

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
-   `resolve(value)` — если работа завершилась успешно, с результатом `value`.
-   `reject(error)` — если произошла ошибка, `error` – объект ошибки.

Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать `resolve` или `reject`.

У объекта `promise`, возвращаемого конструктором `new Promise`, есть внутренние свойства:
-   `state` («состояние») — вначале `"pending"` («ожидание»), потом меняется на `"fulfilled"` («выполнено успешно») при вызове `resolve` или на `"rejected"` («выполнено с ошибкой») при вызове `reject`.
-   `result` («результат») — вначале `undefined`, далее изменяется на `value` при вызове `resolve(value)` или на `error` при вызове `reject(error)`.

Так что исполнитель по итогу переводит `promise` в одно из двух состояний:
![[Pasted image 20230218150041.png]]

У нас есть функция `loadScript` для загрузки скрипта из предыдущей главы.
Давайте вспомним, как выглядел вариант с колбэками:
~~~
``function loadScript(src, callback) {   
	let script = document.createElement('script');   
	script.src = src;    
	script.onload = () => callback(null, script);   
	script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));    
	document.head.append(script); }``
~~~
Теперь перепишем её, используя `Promise`.

Новой функции `loadScript` более не нужен аргумент `callback`. 
Вместо этого она будет создавать и возвращать объект `Promise`, который перейдет в состояние «успешно завершён», когда загрузка закончится. Внешний код может добавлять обработчики («подписчиков»), используя `.then`:
~~~
``function loadScript(src) {   
	return new Promise(function(resolve, reject) {     
		let script = document.createElement('script');     
		script.src = src;      
		script.onload = () => resolve(script);     
		script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));      
		document.head.append(script);   }); }``
~~~
Применение:
~~~
``
let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");  
promise.then(   
	script => alert(`${script.src} загружен!`),   
	error => alert(`Ошибка: ${error.message}`) );  
	promise.then(script => alert('Ещё один обработчик...'));``
~~~
Сразу заметно несколько преимуществ перед подходом с использованием колбэков:

###### Промисы

1. Промисы позволяют делать вещи в естественном порядке. Сперва мы запускаем `loadScript(script)`, и затем (`.then`) мы пишем, что делать с результатом.
2. Мы можем вызывать `.then` у `Promise` столько раз, сколько захотим. Каждый раз мы добавляем нового «фаната», новую функцию-подписчика в «список подписок». Больше об этом в следующей главе: [Цепочка промисов](https://learn.javascript.ru/promise-chaining).

Таким образом, промисы позволяют улучшить порядок кода и дают нам гибкость. Но это далеко не всё. Мы узнаем ещё много полезного в последующих главах.

###### Колбэки

У нас должна быть функция`callback` на момент вызова `loadScript(script, callback)`. Другими словами, нам нужно знать что делать с результатом _до того_, как вызовется `loadScript`.

Колбэк может быть только один.


#### 9. Можно ли изменять состояние #promise?

Пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:
~~~
let promise = new Promise(function(resolve, reject) {   
// спустя одну секунду будет сообщено, что задача выполнена с ошибкой   
setTimeout(() => _reject__(new Error("Whoops!"))_, 1000); });`
~~~

![[Pasted image 20230218150248.png]]

Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает `resolve` или `reject`, чтобы изменить состояние соответствующего `Promise`.

Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».

	Может быть что-то одно: либо результат, либо ошибка

Исполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние промиса может быть изменено только один раз.

Все последующие вызовы `resolve` и `reject` будут проигнорированы:
~~~
`let promise = new Promise(function(resolve, reject) {   _
	resolve("done");_    
	reject(new Error("…")); // игнорируется   
	setTimeout(() => resolve("…")); // игнорируется });`
~~~
Идея в том, что задача, выполняемая исполнителем, может иметь только один итог: результат или ошибку.

Также заметим, что функция `resolve`/`reject` ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.

###### Вызывайте `reject` с объектом `Error`

В случае, если что-то пошло не так, мы должны вызвать `reject`. Это можно сделать с аргументом любого типа (как и `resolve`), но рекомендуется использовать объект `Error` (или унаследованный от него). Почему так? Скоро нам станет понятно.

###### Вызов `resolve`/`reject` сразу

Обычно исполнитель делает что-то асинхронное и после этого вызывает `resolve`/`reject`, то есть через какое-то время. Но это не обязательно, `resolve` или `reject` могут быть вызваны сразу:
~~~
let promise = new Promise(function(resolve, reject) {   
// задача, не требующая времени   
resolve(123); // мгновенно выдаст результат: 123 });`
~~~
Это может случиться, например, когда мы начали выполнять какую-то задачу, но тут же увидели, что ранее её уже выполняли, и результат закеширован.

Такая ситуация нормальна. Мы сразу получим успешно завершённый `Promise`.

###### Свойства `state` и `result` – внутренние

Свойства `state` и `result` – это внутренние свойства объекта `Promise` и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы `.then`/`.catch`/`.finally`, про них речь пойдёт дальше.


#### 10. Что такое #then? Что передаётся первым аргументом в колбек? Что возвращает then?

Объект `Promise` служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов `.then` и `.catch`.

Наиболее важный и фундаментальный метод – `.then`.

Синтаксис:
~~~
promise.then(   
	function(result) { _/* обработает успешное выполнение */_ },   
	function(error) { _/* обработает ошибку */_ } );`
~~~
1. Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
2. Второй аргумент `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

Например, вот реакция на успешно выполненный промис:
~~~
let promise = new Promise(function(resolve, reject) {   
	setTimeout(() => resolve("done!"), 1000); });  // 
	resolve запустит первую функцию, переданную в .then promise.then(   _
	
	result => alert(result), // выведет "done!" через одну секунду_   
	error => alert(error) // не будет запущена );`
~~~
* Выполнилась первая функция.

А в случае ошибки в промисе – выполнится вторая:
~~~
let promise = new Promise(function(resolve, reject) {   
	setTimeout(() => reject(new Error("Whoops!")), 1000); });  
	// reject запустит вторую функцию, переданную в .then promise.then(   
	result => alert(result), // не будет запущена   _
	error => alert(error) // выведет "Error: Whoops!" спустя одну секунду_ );`
~~~
Если мы заинтересованы только в результате успешного выполнения задачи, то в `then` можно передать только одну функцию:
~~~
let promise = new Promise(resolve => {   
	setTimeout(() => resolve("done!"), 1000); });  _
	promise.then(alert); // выведет "done!" спустя одну секунду_`
~~~

#### 11. Как обрабатывать ошибки в промисах?
Подробнее: [[1.3.3 Promise. Обработка ошибок]]

Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок.

Например, в представленном ниже примере для `fetch` указана неправильная ссылка (сайт не существует), и `.catch` перехватывает ошибку:
~~~
`_
fetch('https://no-such-server.blabla') // ошибка_   
.then(response => response.json())   
.catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)`
~~~
Как видно, `.catch` не обязательно должен быть сразу после ошибки, он может быть далее, после одного или даже нескольких `.then`

Самый лёгкий путь перехватить все ошибки – это добавить `.catch` в конец цепочки.
Если все в порядке, то такой `.catch` вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.

###### Неявный try…catch

Вокруг функции промиса и обработчиков находится "невидимый `try..catch`". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.

Например, этот код:
~~~
`new Promise((resolve, reject) => {   _
	throw new Error("Ошибка!");_ })
.catch(alert); // Error: Ошибка!`
~~~
…Работает так же, как и этот:
~~~
`new Promise((resolve, reject) => {   _
	reject(new Error("Ошибка!"));_ })
	.catch(alert); // Error: Ошибка!`
~~~
"Невидимый `try..catch`" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.

Это работает не только в функции промиса, но и в обработчиках. Если мы бросим ошибку (`throw`) из обработчика (`.then`), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.

Пример:
~~~
new Promise((resolve, reject) => {   
	resolve("ок"); }).then((result) => {   _
	throw new Error("Ошибка!"); // генерируем ошибку_ })
.catch(alert); // Error: Ошибка!`
~~~
Это происходит для всех ошибок, не только для тех, которые вызваны оператором `throw`. 

Например, программная ошибка:
~~~
`new Promise((resolve, reject) => {   
	resolve("ок"); }).then((result) => {   _blabla(); // нет такой функции_ })
.catch(alert); // ReferenceError: blabla is not defined`
~~~
Финальный `.catch` перехватывает как промисы, в которых вызван `reject`, так и случайные ошибки в обработчиках.

###### Пробрасывание ошибок

Как мы уже заметили, `.catch` ведёт себя как `try..catch`. Мы можем иметь столько обработчиков `.then`, сколько мы хотим, и затем использовать один `.catch` в конце, чтобы перехватить ошибки из всех обработчиков.

Если мы пробросим (`throw`) ошибку внутри блока `.catch`, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик `.then`.

В примере ниже `.catch` успешно обрабатывает ошибку:
~~~
`// the execution: catch -> then new Promise((resolve, reject) => {    
	throw new Error("Ошибка!");  }).catch(function(error) {    
		alert("Ошибка обработана, продолжить работу");  })
		.then(() => alert("Управление перейдёт в следующий then"));`
~~~
Здесь блок `.catch` завершается нормально. Поэтому вызывается следующий успешный обработчик `.then`.

В примере ниже мы видим другую ситуацию с блоком `.catch`. Обработчик `(*)` перехватывает ошибку и не может обработать её (например, он знает как обработать только `URIError`), поэтому ошибка пробрасывается далее:
~~~
``// the execution: 
catch -> catch -> then new Promise((resolve, reject) => {    
	throw new Error("Ошибка!");  })
	.catch(function(error) { // (*)    
	
	if (error instanceof URIError) {     // обрабатываем ошибку   
	} else {     alert("Не могу обработать ошибку");      _
	throw error; // пробрасывает эту или другую ошибку в следующий catch_   }  })
	.then(function() {   /* не выполнится */ }).catch(error => { // (**)    
	alert(`Неизвестная ошибка: ${error}`);   // ничего не возвращаем => выполнение продолжается в нормальном режиме  });``
~~~
Управление переходит от первого блока `.catch` `(*)` к следующему `(**)`, вниз по цепочке.

###### Необработанные ошибки

Что произойдёт, если ошибка не будет обработана? Например, мы просто забыли добавить `.catch` в конец цепочки, как здесь:
~~~
`new Promise(function() {   
	noSuchFunction(); // Ошибка (нет такой функции) })   
	.then(() => {     // обработчики .then, один или более   }); // без .catch в самом конце!`
~~~
В случае ошибки выполнение должно перейти к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. Поэтому ошибка как бы «застревает», её некому обработать.

Что происходит, когда обычная ошибка не перехвачена `try..catch`? Скрипт умирает с сообщением в консоли. Похожее происходит и в случае необработанной ошибки промиса.

JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. Вы можете увидеть её в консоли, если запустите пример выше.

В браузере мы можем поймать такие ошибки, используя событие `unhandledrejection`:
~~~
`_
window.addEventListener('unhandledrejection', function(event) {   // объект события имеет два специальных свойства:   
	alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку   
	alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана });_  
	new Promise(function() {   throw new Error("Ошибка!"); }); // нет обработчика ошибок`
~~~
Это событие является частью [стандарта HTML](https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections).

Если происходит ошибка, и отсутствует её обработчик, то генерируется событие `unhandledrejection`, и соответствующий объект `event` содержит информацию об ошибке.

Обычно такие ошибки неустранимы, поэтому лучше всего – информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.

В не-браузерных средах, таких как Node.js, есть другие способы отслеживания необработанных ошибок.

#### 12. Promise.all, Promise.allSettled, Promise.any, Promise.race

###### Promise.all
Подробнее: https://doka.guide/js/promise-all/

Метод `all()` — это один из статических методов объекта `Promise`. Метод `all()` используют, когда нужно запустить несколько промисов параллельно и дождаться их выполнения.

Практика:
* Успешное выполнение нескольких промисов
* Один из промисов завершился ошибкой
* Не промисы в массиве промисов

🛠 Довольно частое использование — это преобразование массива с данными в массив с промисами с помощью [`map()`](https://doka.guide/js/array-map/). В `map()` для каждого элемента создаётся промис, а затем полученный массив передаётся в `Promise.all()`. Это позволит дождаться выполнения всех промисов, а затем обработать результат.

[Интересный пример практического применения](https://doka.guide/js/promise-all/#nastavnik-praktikuma-boris-yuzhakov-otvechaet)

###### Promise.allSettled
Подробнее: https://doka.guide/js/promise-allsettled/

Метод `allSettled()` — это один из статических методов объекта `Promise`. Его используют, когда нужно запустить несколько промисов параллельно и дождаться их выполнения.

`Promise.allSettled()` очень похож на метод [`Promise.all()`](https://doka.guide/js/promise-all/), но работает немного по-другому. В отличие от [`Promise.all()`](https://doka.guide/js/promise-all/#odin-iz-promisov-zavershilsya-oshibkoy), `Promise.allSettled()` ждёт выполнения всех промисов, при этом неважно, завершились они успешно или с ошибкой.

На практике:
* *🛠 Метод применяется для запросов к API. Он особенно удобен, когда запросы независимы и ошибка в одном не влияет на другие, так как `Promise.allSettled()` дождётся завершения всех запросов. Если же запросы зависимы, то лучше использовать метод [`Promise.all()`](https://doka.guide/js/promise-all/#na-praktike).
* 🛠 Метод `Promise.allSettled()` появился в спецификации языка недавно, а именно [ES2020](https://262.ecma-international.org/11.0/#sec-promise.allsettled), возможно вам понадобится [полифил](https://www.npmjs.com/package/promise.allsettled).

###### Promise.any
Подробнее: https://doka.guide/js/promise-any/

Метод `any` — это один из статических методов объекта `Promise`. Его используют, когда нужно запустить несколько промисов параллельно и дождаться первого успешного разрешённого.

Практика:
* Успешное выполнение нескольких промисов
* Массив промисов пустой
* Один из промисов завершился ошибкой
* Все промисы завершились ошибкой
* Не промисы в массиве промисов

###### Promise.race
Подробнее: https://doka.guide/js/promise-race/

Метод `race()` — это один из статических методов объекта `Promise`. Его используют, чтобы запустить несколько промисов и дождаться того, который выполнится быстрее.

```
Promise.race(iterable)
```

Практика:
* Самый быстрый промис завершается успешно
* Самый быстрый промис завершается с ошибкой
* Пустой список промисов

Отличие от `Promise.any()`

Как мы уже знаем, `Promise.race()` завершится, когда завершится самый быстрый из всех переданных промисов. Даже если он завершается _с ошибкой_. [`Promise.any()`](https://doka.guide/js/promise-any/) завершится, когда _без ошибки_ завершится самый быстрый из всех переданных промисов.

В консоль запишется результат выполнения `fast`, так как он выполнился быстрее всех и без ошибки. Этот же пример, но с использованием `Promise.race()` попадает в [`catch()`](https://doka.guide/js/promise-catch/).



#### 13. Что такое #async / #await?
Подробнее: [[1.4 ASync. await]]

Существует специальный синтаксис для работы с промисами, который называется «async/await». 

##### Async

Начнём с ключевого слова `async`. Оно ставится перед функцией, вот так:
~~~
async function f() {   
	return 1; }`
~~~

###### Что возвращает async функция? А если явно возвращать примитивное значение?

У слова `async` один простой смысл: эта функция всегда возвращает промис. 
Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом `1`:
~~~
async function f() {   
	return 1; }  
f().then(alert); // 1`
~~~
Можно и явно вернуть промис, результат будет одинаковым:
~~~
async function f() {   
	return Promise.resolve(1); }  
f().then(alert); // 1`
~~~
Так что ключевое слово `async` перед функцией гарантирует, что эта функция в любом случае вернёт промис. 


##### Await

Синтаксис:  `// работает только внутри async–функций let value = await promise;`

Ключевое слово `await` заставит интерпретатор JS ждать до тех пор, пока промис справа от `await` не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

В этом примере промис успешно выполнится через 1 секунду:
~~~
async function f() {    
	let promise = new Promise((resolve, reject) => {     
		setTimeout(() => resolve("готово!"), 1000)   });    _
	let result = await promise; // будет ждать, пока промис не выполнится (*)_    
	alert(result); // "готово!" }  
f();`
~~~
В данном примере выполнение функции остановится на строке `(*)` до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную `result` будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».

Обратите внимание, хотя `await` и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем `promise.then`.

###### Можно ли использовать await без async?

`Await` можно использовать только внутри `async`-функций.

#####  Как использовать async/await в коде? 

`await` нельзя использовать в обычных функциях
Если мы попробуем использовать `await` внутри функции, объявленной без `async`, получим синтаксическую ошибку:
~~~
`function f() {   
	let promise = Promise.resolve(1);   _
	let result = await promise; // SyntaxError_ }`
~~~
Ошибки не будет, если мы укажем ключевое слово `async` перед объявлением функции. 
Как было сказано раньше, `await` можно использовать только внутри `async`–функций.

Давайте перепишем пример `showAvatar()` из раздела [Цепочка промисов](https://learn.javascript.ru/promise-chaining) с помощью `async/await`:

1.  Нам нужно заменить вызовы `.then` на `await`.
2.  И добавить ключевое слово `async` перед объявлением функции.
~~~
async function showAvatar() {    
// запрашиваем JSON с данными пользователя   
	let response = await fetch('/article/promise-chaining/user.json');   
	let user = await response.json();    // запрашиваем информацию об этом пользователе из github   
	let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);   
	let githubUser = await githubResponse.json();    // отображаем аватар пользователя   
	let img = document.createElement('img');   
	img.src = githubUser.avatar_url;   
	img.className = "promise-avatar-example";   
	document.body.append(img);    // ждём 3 секунды и затем скрываем аватар   
	
	await new Promise((resolve, reject) => setTimeout(resolve, 3000));    
	img.remove();    
	return githubUser; }  showAvatar();``
~~~
Получилось очень просто и читаемо, правда? Гораздо лучше, чем раньше.

`await` нельзя использовать на верхнем уровне вложенности

Программисты, узнав об `await`, часто пытаются использовать эту возможность на верхнем уровне вложенности (вне тела функции). Но из-за того, что `await` работает только внутри `async`–функций, так сделать не получится:
~~~
`// SyntaxError на верхнем уровне вложенности 
let response = await fetch('/article/promise-chaining/user.json'); 
let user = await response.json();`
~~~
Можно обернуть этот код в анонимную `async`–функцию, тогда всё заработает:
~~~
`(async () => {   
	let response = await fetch('/article/promise-chaining/user.json');   
	let user = await response.json();   ... })();`
~~~

`await` работает с #thenable–объектами

Как и `promise.then`, `await` позволяет работать с промис–совместимыми объектами. Идея в том, что если у объекта можно вызвать метод `then`, этого достаточно, чтобы использовать его с `await`.

В примере ниже, экземпляры класса `Thenable` будут работать вместе с `await`:
~~~
`class Thenable {   
	constructor(num) {     
	this.num = num;   
	}   then(resolve, reject) {     
		alert(resolve);     // выполнить resolve со значением this.num * 2 через 1000мс     
		setTimeout(() => resolve(this.num * 2), 1000); // (*)   } };  

async function f() {   // код будет ждать 1 секунду,   // после чего значение result станет равным 2   
	let result = await new Thenable(1);   
	alert(result); }  f();`
~~~
Когда `await` получает объект с `.then`, не являющийся промисом, JavaScript автоматически запускает этот метод, передавая ему аргументы – встроенные функции `resolve` и `reject`. Затем `await` приостановит дальнейшее выполнение кода, пока любая из этих функций не будет вызвана (в примере это строка `(*)`). После чего выполнение кода продолжится с результатом `resolve` или `reject` соответственно.

###### Асинхронные методы классов

Для объявления асинхронного метода достаточно написать `async` перед именем:
~~~
class Waiter {   _
	async wait() {_     
		return await Promise.resolve(1);   } }  

new Waiter()   
.wait()   
.then(alert); // 1`
~~~
Как и в случае с асинхронными функциями, такой метод гарантированно возвращает промис, и в его теле можно использовать `await`.







#### 14. Как обрабатывать ошибки в async/await?

Когда промис завершается успешно, `await promise` возвращает результат. 
Когда завершается с ошибкой – будет выброшено #исключение. Как если бы на этом месте находилось выражение `throw`.

Такой код:
~~~
async function f() {   
	await Promise.reject(new Error("Упс!"));_ }`
~~~
Делает то же самое, что и такой:
~~~
`async function f() {   
	throw new Error("Упс!");_ }`
~~~
Но есть отличие: на практике промис может завершиться с ошибкой не сразу, а через некоторое время. В этом случае будет задержка, а затем `await` выбросит исключение.

Такие ошибки можно ловить, используя `try..catch`, как с обычным `throw`:
~~~
async function f() {    
	try {     
		let response = await fetch('http://no-such-url');   
	} catch(err) {     _
		alert(err); // TypeError: failed to fetch_   } }  f();`
~~~
В случае ошибки выполнение `try` прерывается и управление прыгает в начало блока `catch`. Блоком `try` можно обернуть несколько строк:
~~~
async function f() {    
	try {     
		let response = await fetch('/no-user-here');     
		let user = await response.json();   
	} catch(err) {     // перехватит любую ошибку в блоке try: и в fetch, и в response.json     
	alert(err);   } }  f();`
~~~
Если у нас нет `try..catch`, асинхронная функция будет возвращать завершившийся с ошибкой промис (в состоянии `rejected`). В этом случае мы можем использовать метод `.catch` промиса, чтобы обработать ошибку:
~~~
async function f() {   
	let response = await fetch('http://no-such-url'); }  // f() вернёт промис в состоянии rejected _
	f().catch(alert); // TypeError: failed to fetch // (*)_`
~~~
Если забыть добавить `.catch`, то будет сгенерирована ошибка «Uncaught promise error» и информация об этом будет выведена в консоль. Такие ошибки можно поймать глобальным обработчиком, о чём подробно написано в разделе [[1.3.3 Promise. Обработка ошибок]]

###### `async/await` и `promise.then/catch`

При работе с `async/await`, `.then` используется нечасто, так как `await` автоматически ожидает завершения выполнения промиса. В этом случае обычно (но не всегда) гораздо удобнее перехватывать ошибки, используя `try..catch`, нежели чем `.catch`.

Но на верхнем уровне вложенности (вне `async`–функций) `await` использовать нельзя, поэтому `.then/catch` для обработки финального результата или ошибок – обычная практика.

Так сделано в строке `(*)` в примере выше.

###### `async/await` отлично работает с `Promise.all`

Когда необходимо подождать несколько промисов одновременно, можно обернуть их в `Promise.all`, и затем `await`:
~~~
// await будет ждать массив с результатами выполнения всех промисов 
let results = await Promise.all([   
	fetch(url1),   fetch(url2),   ... ]);`
~~~
В случае ошибки она будет передаваться как обычно: от завершившегося с ошибкой промиса к `Promise.all`. А после будет сгенерировано исключение, которое можно отловить, обернув выражение в `try..catch`.





# _Обработка ошибок

#### 15. Как отлавливать и обрабатывать ошибки #try-catch ?
Подробнее: [[1.1 Методы try..catch]]

Есть синтаксическая конструкция `try..catch`, которая позволяет «ловить» ошибки и вместо падения делать что-то более осмысленное.

Конструкция `try..catch` состоит из двух основных блоков: `try`, и затем `catch`:
~~~
try {    // код...  
	} catch (err) {    // обработка ошибки  }`
~~~

Работает она так:
1.  Сначала выполняется код внутри блока `try {...}`.
2.  Если в нём нет ошибок, то блок `catch(err)` игнорируется: выполнение доходит до конца `try` и потом далее, полностью пропуская `catch`.
3.  Если же в нём возникает ошибка, то выполнение `try` прерывается, и поток управления переходит в начало `catch(err)`. Переменная `err` (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.

![[Pasted image 20230211171640.png]]

Таким образом, при ошибке в блоке `try {…}` скрипт не «падает», и мы получаем возможность обработать ошибку внутри `catch`.

#### 16. Что попадает в блок #catch?

Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. 
Затем этот объект передаётся как аргумент в блок `catch`:
~~~
try {   // ... 
} catch(err) { // <-- объект ошибки, можно использовать другое название вместо err   // ... }`
~~~
Для всех встроенных ошибок этот объект имеет два основных свойства:

`name` Имя ошибки. Например, для неопределённой переменной это `"ReferenceError"`.

`message` Текстовое сообщение о деталях ошибки.

#### 17. Можно ли создавать свой объект ошибок #error ?
Подробнее: [[1.2 Пользовательские ошибки, расширение Error]]

JavaScript позволяет вызывать `throw` с любыми аргументами, то есть технически наши классы ошибок не нуждаются в наследовании от `Error`. Но если использовать наследование, то появляется возможность идентификации объектов ошибок посредством `obj instanceof Error`. Так что лучше применять наследование.

По мере роста приложения, наши собственные ошибки образуют иерархию, например, `HttpTimeoutError` может наследовать от `HttpError` и так далее.

сс `Error` встроенный, вот его примерный код, просто чтобы мы понимали, что расширяем:
~~~
`// "Псевдокод" встроенного класса Error, определённого самим JavaScript 

class Error {   
	constructor(message) {     
		this.message = message;     
		this.name = "Error"; // (разные имена для разных встроенных классов ошибок)     
		this.stack = <стек вызовов>; // нестандартное свойство, но обычно поддерживается   } }`
~~~
Теперь давайте унаследуем от него `ValidationError` и попробуем новый класс в действии:
~~~
`_class ValidationError extends Error {_   
	constructor(message) {     
		super(message); // (1)     
		this.name = "ValidationError"; // (2)   } }  
		
function test() {   
	throw new ValidationError("Упс!"); }  

try {   test(); 
} catch(err) {   
	alert(err.message); // Упс!   
	alert(err.name); // ValidationError   
	alert(err.stack); // список вложенных вызовов с номерами строк для каждого }`
~~~
Обратите внимание: в строке `(1)` вызываем родительский конструктор. JavaScript требует от нас вызова `super` в дочернем конструкторе, так что это обязательно. Родительский конструктор устанавливает свойство `message`.

Родительский конструктор также устанавливает свойство `name` для `"Error"`, поэтому в строке `(2)` мы сбрасываем его на правильное значение.

Попробуем использовать его в `readUser(json)`:
~~~
`class ValidationError extends Error {   
	constructor(message) {     
		super(message);     
		this.name = "ValidationError";   } }  // Использование function 
readUser(json) {   
	let user = JSON.parse(json);    
	if (!user.age) {     
		throw new ValidationError("Нет поля: age");   }  
	if (!user.name) {     
		throw new ValidationError("Нет поля: name");   }    
	return user; }  // Рабочий пример с try..catch  
	
try {   
	let user = readUser('{ "age": 25 }'); 
} catch (err) {   
	if (err instanceof ValidationError) {     _
		alert("Некорректные данные: " + err.message); // Некорректные данные: Нет поля: name_   
	} else if (err instanceof SyntaxError) { // (*)     
		alert("JSON Ошибка Синтаксиса: " + err.message);   
	} else {     
		throw err; // неизвестная ошибка, пробросить исключение (**)   } }`
~~~

Блок `try..catch` в коде выше обрабатывает и нашу `ValidationError`, и встроенную `SyntaxError` из `JSON.parse`.

###### Итого

-   Мы можем наследовать свои классы ошибок от `Error` и других встроенных классов ошибок, но нужно позаботиться о свойстве `name` и не забыть вызвать `super`.
-   Мы можем использовать `instanceof` для проверки типа ошибок. Это также работает с наследованием. Но иногда у нас объект ошибки, возникшей в сторонней библиотеке, и нет простого способа получить класс. Тогда для проверки типа ошибки можно использовать свойство `name`.
-   Обёртывание исключений является распространённой техникой: функция ловит низкоуровневые исключения и создаёт одно «высокоуровневое» исключение вместо разных низкоуровневых. Иногда низкоуровневые исключения становятся свойствами этого объекта, как `err.cause` в примерах выше, но это не обязательно.

#### 18. Что такое #исключение?

Чтобы `try..catch` работал, код должен быть выполнимым. Другими словами, это должен быть корректный JavaScript-код.

Он не сработает, если код синтаксически неверен, например, содержит несовпадающее количество фигурных скобок:

`try {   {{{{{{{{{{{{ } catch(e) {   alert("Движок не может понять этот код, он некорректен"); }`

JavaScript-движок сначала читает код, а затем исполняет его. Ошибки, которые возникают во время фазы чтения, называются ошибками парсинга. Их нельзя обработать (изнутри этого кода), потому что движок не понимает код.

Таким образом, `try..catch` может обрабатывать только ошибки, которые возникают в корректном коде. Такие ошибки называют «ошибками во время выполнения», а иногда «исключениями».

Исключение, которое произойдёт в коде, запланированном «на будущее», например в `setTimeout`, `try..catch` не поймает:
~~~
`try {   
	setTimeout(function() {     
	noSuchVariable; // скрипт упадёт тут   }, 1000); 
} catch (e) {   
alert( "не сработает" ); }`
~~~
Это потому, что функция выполняется позже, когда движок уже покинул конструкцию `try..catch`.

Чтобы поймать исключение внутри запланированной функции, `try..catch` должен находиться внутри самой этой функции:
~~~
`setTimeout(function() {   
	try {     
		noSuchVariable; // try..catch обрабатывает ошибку!   
	} catch {     
		alert( "ошибка поймана!" );   } }, 1000);`
~~~

#### 19. Что будет если не обработать исключение?

Если во время работы скрипта возникла ошибка и она не была обработана, то выполнение останавливается, и программа больше не работает.

#### 20. Как сделать проброс исключения? Куда попадает ошибка и как с ней работать дальше?

А что, если в блоке `try {...}` возникнет _другая неожиданная ошибка_? 
Например, программная (неопределённая переменная) или какая-то ещё, а не ошибка, связанная с некорректными данными.

Пример:
~~~
let json = '{ "age": 30 }'; // данные неполны  

try {   
	user = JSON.parse(json); // <-- забыл добавить "let" перед user    // ... 
} catch(err) {   
	alert("JSON Error: " + err); // JSON Error: ReferenceError: user is not defined   // (не JSON ошибка на самом деле) }`
~~~

**Блок `catch` должен обрабатывать только те ошибки, которые ему известны, и «пробрасывать» все остальные.**

Техника «проброс исключения» выглядит так:

1.  Блок `catch` получает все ошибки.
2.  В блоке `catch(err) {...}` мы анализируем объект ошибки `err`.
3.  Если мы не знаем как её обработать, тогда делаем `throw err`.

В коде ниже мы используем проброс исключения, `catch` обрабатывает только `SyntaxError`:
~~~
`let json = '{ "age": 30 }'; // данные неполны 

try {    
	let user = JSON.parse(json);    
	if (!user.name) {     
		throw new SyntaxError("Данные неполны: нет имени");   }    _
	blabla(); // неожиданная ошибка_    
	alert( user.name );  
} catch(e) {    _
	if (e.name == "SyntaxError") {     
		alert( "JSON Error: " + e.message );   
	} else {     
		throw e; // проброс (*)   }_  }`
~~~
Ошибка в строке `(*)` из блока `catch` «выпадает наружу» и может быть поймана другой внешней конструкцией `try..catch` (если есть), или «убьёт» скрипт.

Таким образом, блок `catch` фактически обрабатывает только те ошибки, с которыми он знает, как справляться, и пропускает остальные.
