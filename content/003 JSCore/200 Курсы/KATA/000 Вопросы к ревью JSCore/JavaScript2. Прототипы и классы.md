#### 21. Что такое #this?  

В JavaScript #this – это ссылка на объект, а обьект на который ссылаются - ключевое слово.

#### 19. Когда определяется this? От чего зависит this? 

В большинстве случаев значение `this` определяется тем, каким образом вызвана функция. 

~~~
Значение `this` не может быть установлено путём присваивания во время исполнения кода и может иметь разное значение при каждом вызове функции. 
~~~

Оно может неявно варьироваться в зависимости от методов-прототипов: #bind, #call и #apply.

##### [Значение](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this#%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)
Свойство контекста выполнения кода ( #global, #function или #eval), которое в нестрогом режиме всегда является ссылкой на объект, а в строгом режиме может иметь любое значение.

То есть, оно зависит от контекста в пределах которого его вызвали:
##### 1 [Global контекст](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this#global_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82)
В глобальном контексте выполнения (за пределами каких-либо функций) `this` ссылается на глобальный объект вне зависимости от режима (строгий или нестрогий).
```
// В браузерах, объект window также является объектом global:
console.log(this === window); // true

a = 37;
console.log(window.a); // 37

this.b = "MDN";
console.log(window.b)  // "MDN"
console.log(b)         // "MDN"
```

##### 2 [Function контекст](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this#function_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82)
В пределах функции значение `this` зависит от того, каким образом вызвана функция.

###### [Простой вызов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B9_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2)
В простом вызове по умолчанию будет использоваться объект #global, которым в браузере является #window.

```
function f1(){
  return this;
}

// В браузере:
f1() === window; // window - глобальный объект в браузере

// В Node:
f1() === global; // global - глобальный объект в Node
```

###### Строгий вызов
В строгом режиме, если значение `this` не установлено в контексте выполнения, оно остаётся `undefined`, как показано в следующем примере:

```
function f2(){
  "use strict"; // см. strict mode
  return this;
}

f2() === undefined; // true
```

Для того, чтобы при вызове функции установить `this` в определённое значение, используйте [`call()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call) или [`apply()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)

#### 18. Что такое потеря контекста?  

Грубо говоря, `this` — это ссылка на некий объект, к свойствам которого можно получить доступ внутри вызова функции. Этот `this` — и есть _контекст выполнения_.

Потеря контекста определяется тем, как вызван #this, а не тем, где она определена.

Если мы попытаемся вызвать метод в рамках объекта, у которого нет нужных свойств, то будет ошибка Это называется потеря контекста. Reference Type

Рассмотрим пример.
```javascript
let car = {
  maxSpeed: 10,
  chargingHours: 5,
  getMaxDistance() {
    return this.maxSpeed * this.chargingHours;
  }
}

let maxDistance = car.getMaxDistance;

console.log(maxDistance()); // Ошибка
```
В переменную maxDistance мы присвоили не результат функции, а ссылку на эту функцию (Reference Type), так как функция является объектом.

##### Способы избежать потери контекста
###### #1 Обернуть в анонимную функцию.

Обернуть вызов в анонимную функцию. Тут сработало замыкание. При передаче функции в очередь, движок также передал туда все видимые переменные в рамках области видимости, в том числе объект car.

```javascript
setTimeout(function() {
  car.getMaxDistance();
}, 1000) // 50
```

Но тут есть нюанс, если до выполнения функции в setTimeout измениться объект car, то это отразится на результате его выполнения.

```javascript
setTimeout(function() {
  car.getMaxDistance();
}, 1000) // 45 мы можем не узнать о том, что с объектом, что-то произошло

// Выполнится раньше чем setTimeout
car.getMaxDistance = function() {
  console.log(this.maxSpeed * this.chargingHours * 0.9);
}
```

###### #2 Привязываем контекст с помощью #bind

bind возвращает специальный метод, который сохраняет функциональность, но строго привязывает ее к определенному объекту.

```javascript
let carMaxDistance = car.getMaxDistance.bind(car);

setTimeout(carMaxDistance, 1000) // 50

// Выполнится раньше чем setTimeout, но нам уже все равно
car.getMaxDistance = function() {
  console.log(this.maxSpeed * this.chargingHours * 0.9);
}
```

Теперь мы можем гарантировать, что метод выполнится корректно по отношению к объекту

###### #3 Использовать стрелочные функции

Особенность стрелочной функции в том, что у нее вообще нет контекста. Он определяется в момент создания.

```javascript
const showContext = () => {
  console.log(this); // undefined
}
```

Пример потери контекста с обычной функцией

```javascript
function Car() {
  // В конструкторе Person() `this` указывает на себя.
  this.speed = 0;
  
  // Каждую секунду увеличиваем скорость
  setInterval(function incrementSpeed() {
    this.speed++; // Нет доступа к свойству
    console.log(this.speed); // NaN
  }, 1000);
}

let car = new Car();
```

Решение с помощью стрелочной функции

```javascript
function Car() {
  this.speed = 0;

  setInterval(() => {
    this.speed++;
    console.log(this.speed);
  }, 1000);
}

let car = new Car();
```

Так как у стрелочной функции контекст определяется в момент создания, то мы запомнили свойство speed в контексте вызова функции.

###### Подведем итог

-   У обычной функции контекст создается в момент вызова. Вне объекта он равен window
-   Когда мы вызываем функцию через точку object.method(), то контекстом является объект до точки object
-   Стрелочная функция не имеет контекста и сохраняет его в момент создания
-   метод bind помогает привязать контекст выполнения к функции

#### 16. Что делает #bind? Что возвращает bind? Какие параметры есть у bind? 

`bind() `Метод создает новую функцию, которая при вызове имеет `this` ключевое слово, равное указанному значению, с заданной последовательностью аргументов, предшествующих любому, предоставленному при вызове новой функции.

```
bind(thisArg)
bind(thisArg, arg1)
bind(thisArg, arg1, arg2)
bind(thisArg, arg1, arg2, /* …, */ argN)
```

##### Параметры
`thisArg` Значение, которое будет передано в качестве `this`параметра целевой функции `func`при вызове связанной функции. Если функция не находится в [строгом режиме](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode), [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null)и [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined)будет заменен глобальным объектом, и примитивные значения будут преобразованы в объекты. Значение игнорируется, если связанная функция создается с использованием [`new`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new)оператора.

`arg1, …, argN`  Аргументы для добавления к аргументам, предоставляемым связанной функции при вызове `func`.

##### Возвращаемое значение
Копия данной функции с указанным `this`значением и начальными аргументами (если они указаны).

##### Подробнее
Существует тонкая разница между стрелочной функцией => и обычной функцией, вызванной с `.bind(this)`:

-   `.bind(this)` создаёт «связанную версию» функции.
-   Стрелка => ничего не привязывает. У функции просто нет `this`. При получении значения `this` – оно, как обычная переменная, берётся из внешнего лексического окружения.

Функция [`bind`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) возвращает **новую** _привязанную_ функцию. Значение _this_ внутри созданной функции _всегда_ то, которое передали при вызове [`bind`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).

* ***Важная особенность:** при использовании привязанной функции в качестве конструктора, значение _this_ все равно будет указывать на создаваемый объект, как описано выше.
* **Важная особенность:** в _НЕ strict mode_ при передаче в качестве параметра _this_ значений `null` и `undefined` - этот параметр будет проигнорирован и _this_ будет установлен в глобальный объект.

```javascript
function A(){console.log(typeof this,'is window', this === window);}
console.log('execute with null');
A.bind(null)();
console.log('execute with undefined');
A.bind(undefined)();

function A1(){'use strict'; console.log(typeof this, this);}
console.log('execute with null');
A1.bind(null)();
console.log('execute with undefined');
A1.bind(undefined)();
```

* ***Важная особенность:** значение _this_ у созданной функции **нельзя** переопределить используя функции [`call`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call) и [`apply`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) описанные выше.

```javascript
function A(){console.log(this);}

var B = A.bind({o:'object'});
console.log('execute binded');
B();
console.log('execute with call');
B.call({another: 'some new object'});

console.log('execute as constructor');
new B();
```

bind - возвращает функции( привязать контектс)
call / apply - возвращает результат этой функции.

#### 15. Чем отличаются this в стрелочных функциях и в обычных? 
Подробнее: [[Контекст (this) в JS]]

-Контекстом вызова

##### This в обычных функциях 

Контекст обычной функции устанавливается в момент вызова функции. 
Это называется "поздним связыванием".

###### Подробнее
Если при вызове **слева от названия функции нет точки**, то контекстом функции является **глобальный контекст** (undefined в strict моде и window без него). Если же при вызове функции **слева от её названия есть точка**, то контекстом функции будет являться **объект, находящийся слева от точки**.

```js
obj /* <-- контекст функции*/
  .fn();
fn(); // контекст равен глобальному контексту (undefined в strict моде и window без него)
```

[1] Если **метод присвоить в переменную**, а затем функцию вызвать из этой переменной, **контекст будет потерян**, потому что слева от точки при вызове ничего не будет

```js
const obj = {
    fn() {
        console.log(this)
    },
};
obj.fn(); // obj

const fn = obj.fn;
fn() // глобальный контекст (undefined в strict моде и window без него)
```

[2] Если обычную функцию, при вызове которой контекст был равен глобальному контексту, **присвоить в объект**, а затем вызвать эту функцию как метод объекта, **контекстом функции станет этот объект**, потому что слева от точки при вызове функции будет расположен этот объект

```js
function fn() {
    console.log(this);
}

fn(); // глобальный контекст (undefined в strict моде и window без него)

const obj = {};
obj.fn = fn;

obj.fn(); // obj
```

[3] Если передать **ссылку на метод** в функцию и **вызвать его внутри неё**, то он будет вызван как обычная функция, а не как метод объекта, поэтому его **контекст будет утерян**.

```js
const someFn = (callback) => {
 callback(); // любая функция/метод, переданная сюда, будет вызвана без точки слева,
 // т.е. не от имени объекта. Это означает, что её контекст будет утерян
};

const obj = {
 method: function() {
  console.log(this);
 },
};

someFn(obj.method) // this будет равен undefined при use strict и window без него
```

Тем не менее мы можем **избежать** такого поведения, **обернув вызов** нашего метода в обычную или стрелочную функцию:

```js
const someFn = (callback) => {
 callback();
 /*
  Контекст все равно будет утерян, но утерян он будет у переданной функции,
  т.е. у нашей функции-обертки

  Вызов же метода в этой функции-обертке все равно делается через точку,
  т.е. от имени объекта.

  Благодаря этому, мы избегаем потери контекста
 */
};

const obj = {
    method: function() {
        console.log(this);
    },
};

someFn(() => obj.method()); // this в методе будет равен obj
someFn(function() { obj.method() }); // this в методе будет равен obj
```





##### This в стрелочных функциях

Контекст стрелочной функции устанавливается в момент объявления функции. 
Это называется **"ранним связыванием".**

###### Подробнее

Это также означает то, что **bind/apply/call** не дадут никакого результата при вызове на стрелочной функции.

```js
const fn = () => console.log(this); // this должен быть глобальным контекстом
// (undefined в strict моде и window без него)
fn.call({
  name: 'новый контекст',
}); /* Вызов через call должен принудительно привязать
 новый контекст к функции, но тем не менее this все равно равен глобальному контексту
 (undefined в strict моде и window без него) */
```

**Стрелочная функция не создает собственный контекст**, она берет его из внешнего лексического окружения:

[1] Если вы объявляете стрелочную функцию в глобальном контексте (не внутри функций/методов, но при этом сама стрелочная функция может быть методом), то контекстом этой стрелочной функции является глобальный контекст (undefined в strict моде и window без него)

```js
const fn = () => console.log(this);
const obj = {
  fn: () => console.log(this) /* контекст создают только функции,
   поэтому даже если стрелочная функция сама является
   методом объекта (не обернутого в функцию),
   контекстом для этой функции будет глобальный контекст
   (undefined в strict моде и window без него) */,
};

fn(); // глобальный контекст (undefined в strict моде и window без него)
obj.fn(); // глобальный контекст (undefined в strict моде и window без него)
```

[2] Если вы объявляете стрелочную функцию внутри другой функции/метода, то контекстом этой стрелочной функции будет контекст функции/метода, в котором эта стрелочная функция объявлена.

```js
const obj = {
  fn() {
    /* <-- стрелочная функция возьмет контекст этой функции,
      // а он равен obj, если вызывать ее через obj */
    const arrowFn = () => console.log(this);
    arrowFn();
  },
};

obj.fn(); // obj
```

[3] Исходя из пункта [1] и [2] можно сделать следующий совмещенный пример, чтобы глубже понять, как это работает:

```js
const obj = {
  // <-- контекст метода fn будет равен obj1,
  // если вызвать этот метод через точку (obj1.fn())
  fn1() {
    // <-- контекст стрелочной функции будет определен этой функцией,
    // т.к. она является ближайшей для него функцией
    return {
      fn2: () => {
        // функция возьмет контекст ближайшей внешней функции
        console.log(this);
      },
    };
  },
};

obj.fn1().fn2(); // this стрелочной функции = obj. fn1 возвращает внутренний объект,
// на котором вызывается метод fn2. Метод fn2 берет контекст ближайшей к нему функции -
// fn1, а та, в свою очередь, вызвана как метод объекта,
// значит ее контекстом и контекстом стрелочной функции будет obj
```







##### - This в цепочке object's prototype

Это же представление справедливо и для методов, определённых где-либо в цепочке object's prototype. Если метод находится в цепочке прототипов, то `this` ссылается на объект, на котором был вызван метод, т.е. так, словно метод является методом самого объекта, а не прототипа.

```
var o = {f:function(){ return this.a + this.b; }};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5
```

В этом примере объект, который присвоен переменной `p`, не имеет собственного свойства `f`, а наследует это свойство от своего прототипа. Однако, совершенно неважно, что поиск свойства f в конце концов обнаружит его на объекте `o`. Поскольку поиск начался с `p.f`, то и свойство `this` внутри функции `f` будет ссылаться на объект `p`. Таким образом, если `f` вызывается как метод `p`, то и `this` относится к `p`. Это полезная особенность прототипного наследования JS.

##### - This с геттерами/сеттерами

Все те же утверждения справедливы, если функция вызывается из геттера или сеттера. Для функции, которая используется как геттер или сеттер `this` привязан к объекту, свойство которого необходимо извлечь через геттер/сеттер.

```
function modulus(){
  return Math.sqrt(this.re * this.re + this.im * this.im);
}

var o = {
  re: 1,
  im: -1,
  get phase(){
    return Math.atan2(this.im, this.re);
  }
};

Object.defineProperty(o, 'modulus', {
    get: modulus, enumerable:true, configurable:true});

console.log(o.phase, o.modulus); // logs -0.78 1.4142
```

##### - This в конструкторе

Когда функция используется как конструктор (с ключевым словом [`new`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) ), `this` связано с создаваемым новым объектом.

Примечание: по умолчанию конструктор возвращает объект, на который ссылается `this`, но он может вернуть и другой объект (если возвращаемое значение не является объектом, тогда будет возвращён объект с `this`).

```
/*
 * Конструктор работает таким образом:
 *
 * function MyConstructor(){
 *   // фактический код, составляющий тело функции.
 *   // создание свойств с |this| по
 *   // желанию, определяя их значения; например,
 *   this.fum = "nom";
 *   // и т.д.
 *
 *   // Если функция возвращает выражение,
 *   // возвращающее объект, этот объект будет
 *   // результатом выражения |new|. В обратном случае,
 *   // результат выражения - объект,
 *   // в данный момент привязанный к |this|
 *   // (т.е. наиболее часто встречающийся случай).
 * }
 */

function C() {
  this.a = 37;
}

var o = new C();
console.log(o.a); // logs 37


function C2() {
  this.a = 37;
  return {a: 38};
}

o = new C2();
console.log(o.a); // logs 38
```

В последнем примере (`C2`), из-за того, что конструктор вернул объект, новый объект, к которому было привязано `this`, был просто отброшен. (Это фактически делает выражение "`this.a = 37;`" "мёртвым" кодом. Он не является буквально нерабочим, так как он выполняется, но он может быть изъят без каких-либо внешних эффектов.)


#### 20. На что ссылается this внутри функции, вызванной как метод объекта? А что если это стрелочная функция?  

###### Внутри function()

Если метод находится в цепочке прототипов, то `this` ссылается на объект, на котором был вызван метод, т.е. так, словно метод является методом самого объекта, а не прототипа.

```
var o = {f:function(){ return this.a + this.b; }};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5
```

В этом примере объект, который присвоен переменной `p`, не имеет собственного свойства `f`, а наследует это свойство от своего прототипа. Однако, совершенно неважно, что поиск свойства f в конце концов обнаружит его на объекте `o`. Поскольку поиск начался с `p.f`, то и свойство `this` внутри функции `f` будет ссылаться на объект `p`. Таким образом, если `f` вызывается как метод `p`, то и `this` относится к `p`.  Это полезная особенность прототипного наследования JS.

##### Стрелочные функции

В [`стрелочных функциях`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions), `this` привязан к окружению, в котором была создана функция. В глобальной области видимости `this` будет указывать на глобальный объект.

```
var globalObject = this;
var foo = (() => this);
console.log(foo() === globalObject); // true
```

###### Подробнее

Неважно, как стрелочная функция `foo()` будет вызвана, её значение this будет указывать на глобальный объект. `this` будет сохранять своё значение, даже если функция `foo()` будет вызвана как метод объекта (что в обычных функциях связывает `this` с объектом вызова) или с использованием методов `call`, `apply` или `bind`:

```
// Вызов функции как метода объекта
var obj = {foo: foo};
console.log(obj.foo() === globalObject); // true

// Попытка установить this с помощью call
console.log(foo.call(obj) === globalObject); // true

// Попытка установить this с помощью bind
foo = foo.bind(obj);
console.log(foo() === globalObject); // true
```

Несмотря ни на что, `this` стрелочной функции `foo()` имеет то же значение, что и при создании функции (глобальный объект в примере выше). То же самое касается стрелочных функций, созданных внутри других функций: их `this` будет привязан к окружению.

```
// Создаём объект obj, содержащий метод bar, который возвращает функцию,
// которая возвращает свой this. Возвращаемая функция создана
// как стрелочная функция, таким образом её this постоянно замкнут
// на this функции, в которой она создана. Значение bar может быть установлено
// в вызове, который, в свою очередь, устанавливает значение возвращаемой функции.

var obj = { bar : function() {
                    var x = (() => this);
                    return x;
                  }
          };

// Вызываем bar как метод объекта obj, устанавливая его this на obj
// Присваиваем ссылку возвращаемой функции переменной fn

var fn = obj.bar();

// Вызываем fn без установки this, что в обычных функциях указывало бы
// на глобальный объект или undefined в строгом режиме.

console.log(fn() === obj); // true

// Но будьте осторожны, если вы ссылаетесь на метод obj, не вызывая его
var fn2 = obj.bar;
// Вызов this стрелочной функции изнутри метода bar вернёт теперь window,
// потому что он следует за this из fn2.
console.log(fn2()() == window); // true
```

В примере выше, функция (назовём её анонимной функцией A), присвоенная методу `obj.bar`, возвращает другую функцию (назовём её анонимной функцией B) которая создана как стрелочная функция. 
В результате, `this функции B при вызове замкнут на` `this,` принадлежащий `obj.bar` (функции A). `this` функции B всегда будет иметь то значение, которое он получил при создании. В примере выше, `this функции B` указывает на `this функции A,которым является` obj, таким образом this будет равен `obj` даже тогда, когда будет вызван методом, который в нормальных условиях устанавливал бы значение this равным `undefined` или глобальному объекту (или любым другим методом, как в предыдущем примере в глобальном контексте выполнения).


#### 1. Что делают #call / #apply?  
Подробнее: [[2.3 Декораторы и переадресация вызова, сall и apply]]

##### Метод #Call
Метод функции [func.call(context, …args)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call)  позволяет вызывать функцию, явно устанавливая `this`.

Синтаксис: `func.call(context, arg1, arg2, ...)

`thisArg` Значение `this`, предоставляемое для вызова функции _`fun`_. 
Обратите внимание, что `this` может не быть реальным значением, видимым этим методом: если метод является функцией в [нестрогом режиме (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode "Currently only available in English (US)"), значения [`null`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/null) и [`undefined`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined) будут заменены глобальным объектом, а примитивные значения будут упакованы в объекты.

`arg1, arg2, ...` Аргументы для объекта.
`
Он запускает функцию `func`, используя первый аргумент как её контекст `this`, а последующие – как её аргументы.

Проще говоря, эти два вызова делают почти то же самое:
`func(1, 2, 3); func.call(obj, 1, 2, 3)`
Они оба вызывают `func` с аргументами `1`, `2` и `3`. Единственное отличие состоит в том, что `func.call` ещё и устанавливает `this` равным `obj`.

В приведенном ниже коде, мы вызываем функцию sayHi в контексте различных обьектов.
~~~
`function sayHi() {   
	alert(this.name); }  

let user = { 
	name: "John" }; 

let admin = { 
	name: "Admin" };  // используем 'call' для передачи различных объектов в качестве 'this' 
	
sayHi.call( user ); // John 
sayHi.call( admin ); // Admin`
~~~

##### Метод #Apply
Синтаксис встроенного метода [func.apply](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply): `func.apply(context, args)`

Он выполняет `func`, устанавливая `this=context` и принимая в качестве списка аргументов псевдомассив `args`.
Единственная разница в синтаксисе между `call` и `apply` состоит в том, что `call` ожидает список аргументов, в то время как `apply` принимает псевдомассив.

Эти два вызова почти эквивалентны:
`func.call(context, ...args); // передаёт массив как список с оператором расширения func.apply(context, args);   // тот же эффект`

Есть только одна небольшая разница:
-   Оператор расширения `...`  ( #spread)позволяет передавать _перебираемый_ объект `args` в виде списка в `call`.
-   А `apply` принимает только _псевдомассив_ `args`.

Так что эти вызовы дополняют друг друга. 
Для перебираемых объектов сработает `call`, а где мы ожидаем псевдомассив – `apply`.

#### 2. Как работает #instanceof ?  

Оператор **`instanceof`** проверяет, принадлежит ли объект к определённому классу. 
Другими словами, `object instanceof constructor` проверяет, присутствует ли объект `constructor.prototype` в цепочке прототипов `object`.
~~~
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const auto = new Car('Honda', 'Accord', 1998);

console.log(auto instanceof Car);
// Expected output: true

console.log(auto instanceof Object);
// Expected output: true
~~~

`object` Проверяемый объект.
`constructor` Функция-конструктор, на которую идёт проверка.

##### [Описание](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof#%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5)
Оператор `instanceof` проверяет, присутствует ли объект `constructor.prototype` 
в цепочке прототипов `object`

Что если нам нужно определить конкретный класс экземпляра? Для этого можно использовать свойство constructor:  
  
```
writer.constructor === ContentWriter // true
writer.constructor === User // false
// или
writer.__proto__ === ContentWriter.prototype // true
writer.__proto__ === User.prototype // false
```

#### 3. Что такое #super?  

Ключевое слово **super** используется для вызова функций, принадлежащих родителю объекта.

Выражения `super.prop` и `super[expr]` действительны в любом [определении метода](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Method_definitions) в [классах](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes) и в [литералах объекта](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Object_initializer).

```
super([arguments]); // вызов родительского конструктора.
super.functionOnParent([arguments]);
```

##### [Описание](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/super#%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5)
В конструкторе ключевое слово `super()` используется как функция, вызывающая родительский конструктор. Её необходимо вызвать до первого обращения к ключевому слову `this` в теле конструктора. Ключевое слово `super` также может быть использовано для вызова функций родительского объекта.

Используется для получения доступа к родительскому конструктору или экземпляру.

###### 3.1. Родительский конструктор: super() в constructor()
  
Для того, чтобы вызвать конструктор родительского класса в дочернем классе, следует использовать специальную функцию super(), доступную в конструкторе дочернего класса.  
  
Пусть конструктор ContentWriter вызывает родительский конструктор и инициализирует поле posts:  
  
```
class User {
    name

    constructor(name) {
        this.name = name
    }

    getName() {
        return this.name
    }
}

class ContentWriter extends User {
    posts = []

    constructor(name, posts) {
        super(name)
        this.posts = posts
    }
}

const writer = new ContentWriter('Лермонтов', ['Герой нашего времени'])
writer.name // Лермонтов
writer.posts // ['Герой нашего времени']
```
  
super(name) в дочернем классе ContentWriter вызывает конструктор родительского класса User.  
  
Обратите внимание, что в дочернем конструкторе перед использованием ключевого слова this вызывается super(). Вызов super() «привязывает» родительский конструктор к экземпляру.  
  
```
class Child extends Parent {
    constructor(value1, value2) {
        // не работает!
        this.prop2 = value2
        super(value1)
    }
}
```

###### 3.2. Родительский экземпляр: super в методах

  Для того, чтобы получить доступ к родительскому методу внутри дочернего класса, следует использовать специальное сокращение super:  
  
```
class User {
    name

    constructor(name) {
        this.name = name
    }

    getName() {
        return this.name
    }
}

class ContentWriter extends User {
    posts = []

    constructor(name, posts) {
        super(name)
        this.posts = posts
    }

    getName() {
        const name = super.getName()
        if (name === '') {
            return 'Имярек'
        }
        return name
    }
}

const writer = new ContentWriter('', ['Герой нашего времени'])
writer.getName() // Имярек
```

getName() дочернего класса ContentWriter вызывает метод getName() родительского класса User.  
Это называется переопределением метода.  
Обратите внимание, что super можно использовать и для статических методов родительского класса.

#### '-----'
#### 8. Что делает оператор #new? Чему будет равен this внутри класса? 
Подробнее: [[2.2 Конструкторы, создание объектов через new]]

1. При помощи функции-конструктора и оператора #new мы можем создать множество похожих, однотипных обьектов, в то время как обычный синтаксис {...} позволяет создать только один обьект.

Когда функция вызывается как `new User(...)`, происходит следующее:
1.  Создаётся новый пустой объект, и он присваивается `this`.
2.  Выполняется тело функции. Обычно оно модифицирует `this`, добавляя туда новые свойства.
3.  Возвращается значение `this`.

Другими словами, `new User(...)` делает что-то вроде:
~~~
`function User(name) {   _// 
	this = {};  (неявно)_    // добавляет свойства к this   
	this.name = name;   
	this.isAdmin = false;    _// 
	
	return this;  (неявно)_ 
}`
~~~
Таким образом, `let user = new User("Jack")` возвращает тот же результат, что и:

`let user = {   name: "Jack",   isAdmin: false };`

2. This является экземпляром класса, который вы создаете с помощью new, и устанавливается в момент создания этого экземпляра:
	this определяет значение this.name = name / имя 

````
```js
class Test {
  constructor(name) {
    // this = объекту, который мы создаем после объявления класса.
    // Устанавливается в момент вызова new
    this.name = name;
  }
}

const test = new Test('Имя, которое установится в поле name созданного объекта')
// Объект, который записался в test, во время создания
// экземпляра был в this класса Test, поэтому мы смогли установить его поле name
```
````

this в конструкторе указывает на создаваемый экземпляр.  
  
Аргумент, используемый для создания экземпляра класса, становится параметром его конструктора:  
  
```
class User {
    constructor(name) {
        name // Печорин
        this.name = name
    }
}

const user = new User('Печорин')
```
  
Параметр name внутри конструктора имеет значение 'Печорин'.  

#### 14. Что такое цепочка прототипов?
Подробнее: https://habr.com/ru/post/120193/ , [[2.1 Прототипы, наследования]]

Цепь прототипов (prototype chain) — это конечная цепь объектов, которая используется для организации наследования и разделяемых (shared) свойств.

Тк каждый обьект имеет собственные свойства и ссылку на обьект-прототип, в свою очередь прототип тоже имеет собственные свойства и ссылку на прототип, прототип прототипа тоже имеет собственные свойства и ссылку на прототип ну и так далее, пока ссылка на прототип не будет null — эта структура называется цепочка прототипов.

При попытке обратиться к свойству объекта (через точку или скобки) выполняется поиск указателя по имени: сперва проверяется есть ли указатель с таком-то именем с списке собственных свойств (если есть, то возвращается), если его нет, то идет поиск в собственном прототипе (если есть, то возвращается), если его нет, то идет поиск в прототипе прототипа и так далее, пока прототип прототипа не станет null в этом случае возвращается undefined.  
  
Некоторые реализации JavaScript используют свойство __proto__ для представления следующего объекта в цепочке прототипов.  
  
Поиск свойства на чтение можно описать следующей функцией:  

```
function getProperty(obj, prop) {
  if (obj.hasOwnProperty(prop))
    return obj[prop]
 
  else if (obj.__proto__ !== null)
    return getProperty(obj.__proto__, prop)
 
  else
    return undefined
}
```

#### 12. Как установить прототип объекту? Можно ли замыкать цепочку прототипов (объект А ссылается на В, а В ссылается на А)?  

Современные способы установки и прямого доступа к прототипу это:

-   [Object.create(proto[, descriptors])](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create) – создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto` (может быть `null`), и необязательными дескрипторами свойств.
-   [Object.getPrototypeOf(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object.getPrototypeOf) – возвращает свойство `[[Prototype]]` объекта `obj` (то же самое, что и геттер `__proto__`).
-   [Object.setPrototypeOf(obj, proto)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object.setPrototypeOf) – устанавливает свойство `[[Prototype]]` объекта `obj` как `proto` (то же самое, что и сеттер `__proto__`).

Замыкать цепочку прототипов нельзя, потому что это вызовет ошибку.

#### 11. Можно ли изменять прототип после создания объекта?  

Метод Object.setPrototypeOf()  изменяет прототип (внутреннее свойство [[Prototype]]) указанного объекта на другой объект или на null.

##### Синтаксис метода Object.setPrototypeOf():
Object.setPrototypeOf(obj, prototype);

##### Параметры метода Object.setPrototypeOf():
obj - объект, которому устанавливается новый прототип prototype.

Возвращаемое значение: новый прототип объекта (объект или null).
~~~
const car = { brand: "Nissan" };
const airplane = { brand: "Su" };

let newCar = Object.create(car);
Object.getPrototypeOf(newCar); // {brand: "Nissan"}
Object.setPrototypeOf(newCar, airplane); // установим новый прототип
Object.getPrototypeOf(newCar); // {brand: "Su"}
~~~

> ВАЖНО! Изменение прототипа [[Prototype]] объекта является очень медленной операцией, это справедливо для любого браузера и движка JavaScript. Изменение прототипов может распространяться на любой код, который имеет доступ к любому объекту, чей прототип [[Prototype]] был изменён. Если вы заботитесь о производительности, вы никогда не должны изменять прототип [[Prototype]] объекта. Вместо этого создайте объект с нужным прототипом [[Prototype]] с помощью метода Object.create().

#### 13. Что произойдет при вызове несуществующего свойства у объекта?  

Например, что случится, если мы обращаемся к `iceCream.taste`, а в объекте есть только свойство `flavor`? 
Если ответить на этот вопрос, не вдаваясь в детали, то можно сказать, что, попытавшись обратиться к несуществующему свойству, мы получим особое значение `undefined`. 

Если дать на этот вопрос развёрнутый ответ, то начать надо с того, что большинство объектов в JavaScript имеют так называемый «прототип». 
Прототип объекта можно воспринимать как «скрытое» свойство, которое указывает системе на то, где нужно искать запрашиваемое свойство в том случае, если в самом объекте его нет. В нашем примере, когда оказывается, что в объекте `iceCream` нет свойства `taste`, JavaScript будет искать это свойство в прототипе объекта, который тоже является объектом. 

А если и там его не найдёт — то в прототипе прототипа, и так далее. 

Значение `undefined` будет выдано только тогда, когда будет достигнут конец «цепочки прототипов», и при этом свойство `.taste` так и не будет найдено. Вам редко придётся напрямую работать с этим механизмом, но, зная о прототипах, можно понять то, почему у объекта `iceCream` есть метод `toString`, который мы никогда не объявляли. Этот метод берётся из прототипа объекта.

#### 10. Что такое класс и для чего он нужен?  

 #класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).

Class - это функциональное выражение.

Базовый синтаксис выглядит так:
~~~
`class MyClass {   // методы класса   
	constructor() { ... }   
	method1() { ... }   
	method2() { ... }   
	method3() { ... }   ... }`
~~~
Затем используйте вызов `new MyClass()` для создания нового объекта со всеми перечисленными методами.

При этом автоматически вызывается метод `constructor()`, в нём мы можем инициализировать объект.

Например:
~~~
`class User {    
	constructor(name) {     
		this.name = name;   }    
	sayHi() {     
		alert(this.name);   }  }  // Использование: let user = new User("Иван"); user.sayHi();`
~~~
Когда вызывается `new User("Иван")`:

1.  Создаётся новый объект.
2.  `constructor` запускается с заданным аргументом и сохраняет его в `this.name`.

Классы используются для создания экземпляров. 
Экземпляр — это объект, содержащий данные и логику класса.

#### 9. Что такое конструктор класса?  

#constructor(param1, param2, ...) — это специальный метод внутри класса, служащий для инициализации экземпляра. Это то место, где устанавливаются начальные значения полей экземпляра и осуществляется его настройка.  
  
В следующем примере конструктор устанавливает начальное значение поля name:  

```
class User {
    constructor(name) {
        this.name = name
    }
}
```

Конструктор принимает один параметр — name, который используется для установки начального значения поля this.name.  
  
#this в конструкторе указывает на создаваемый экземпляр.  

#### 17. Что такое метод, что такое свойство объекта?  

1. #метод — это функция, ассоциированная с объектом или, проще говоря, метод — это свойство объекта, являющееся функцией. Методы определяются так же, как и обычные функции, за тем исключением, что они присваиваются свойству объекта. Например вот так:

```
objectName.methodname = function_name;

var myObj = {
  myMethod: function(params) {
    // ...do something
  }
};
```
где `objectName` — это существующий объект, `methodname` — это имя, которое вы присваиваете методу, и `function_name` — это имя самой функции.

Затем вы можете вызвать метод в контексте объекта следующим образом:

```
object.methodname(params);
```

Вы можете определять методы для типа объекта, включая определение метода в функцию конструктора объекта. Например, вы можете определить функцию, которая форматирует и отображает свойства до этого определённых объектов `car`. Например,

```
function displayCar() {
  var result = "A Beautiful " + this.year + " " + this.make
    + " " + this.model;
  pretty_print(result);
}
```

2. Свойство объекта можно понимать как переменную, закреплённую за объектом. 
   Свойства объекта в сущности являются теми же самыми переменными JavaScript, за тем исключением, что они закреплены за объектом. Свойства объекта определяют его характеристики. Получить доступ к свойству объекта можно с помощью точечной записи:

```
objectName.propertyName
```

Начиная с [ECMAScript 5](https://developer.mozilla.org/ru/docs/JavaScript/ECMAScript_5_support_in_Mozilla "This is a link to an unwritten page"), есть три способа перечислить все свойства объекта (получить их список):

-   циклы [for...in (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in "Currently only available in English (US)") Этот метод перебирает все перечисляемые свойства объекта и его цепочку прототипов
-   [Object.keys(o) (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys "Currently only available in English (US)") Этот метод возвращает массив со всеми собственными (те, что в цепочке прототипов, не войдут в массив) именами перечисляемых свойств объекта `o`.
-   [Object.getOwnPropertyNames(o) (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames "Currently only available in English (US)") Этот метод возвращает массив содержащий все имена своих свойств (перечисляемых и неперечисляемых) объекта `o`.

#### 6. Что такое статические методы/свойства? Чем отличаются от обычных свойств и методов?  

Статические методы — это функции, принадлежащие самому классу. 
Они определяют логику класса, а не его экземпляров.  
  
Для создания статического метода используется ключевое слово #static перед названием метода: static myStaticMethod().  

При работе со статическими методами, следует помнить о двух простых правилах (особенностях):  
1.  Статический метод имеет доступ к статическим полям
2.  Он не имеет доступа к полям экземпляров

Создадим статический метод для проверки того, что пользователь с указанным именем уже создан:  

```
class User {
    static #takenNames = []

    static isNameTaken(name) {
        return User.#takenNames.includes(name)
    }

    name = 'Имярек'

    constructor(name) {
        this.name = name
        User.#takenNames.push(name)
    }
}

const user = new User('Печорин')

User.isNameTaken('Печорин') // true
User.isNameTaken('Грушницкий') // false
```

isNameTaken() — статический метод, использующий частное статическое поле User.#takenNames для определения использованных имен.  
  
Статические методы также могут быть частными: static myPrivateStaticMethod(). Такие методы могут вызываться только внутри класса.

#### 7. Что такое getter / setter?  

Геттеры и сеттеры — это аксессоры или вычисляемые свойства. Это методы, имитирующие поля, но позволяющие читать и записывать данные.  
  
#getter  используются для получения данных, #setter— для их изменения.  
  
Для установки запрета на присвоение полю name пустой строки, обернем частное поле #nameValue в геттер и сеттер:  
  
```
class User {
    #nameValue

    constructor(name) {
        this.name = name
    }

    get name() {
        return this.#nameValue
    }

    set name(name) {
        if (name === '') {
            throw new Error('Имя пользователя не может быть пустым')
        }
        this.#nameValue = name
    }
}

const user = new User('Печорин')
user.name // вызывается геттер, Печорин
user.name = 'Бэла' // вызывается сеттер

user.name = '' // Имя пользователя не может быть пустым
```

#### 4. Где хранятся методы/свойства объявленные в конструкторе и за конструктором, но внутри класса?  
Подробнее: [[2.5 Класс. базовый синтаксис]]

Методы/свойства обьявленные в конструкторе внутри класса хранятся в прототипе данного класса `User.prototype`.
~~~
`class User {   
	constructor(name) { 
		this.name = name; }   
	sayHi() { 
		alert(this.name); } }  // доказательство: User - это функция _

alert(typeof User); // function_`
~~~

Методы/свойства обьявленные за конструктором внутри класса не устанавливаются 
в `User.prototype`. Вместо этого оно создаётся оператором `new` перед запуском конструктора, это именно свойство объекта.
~~~
``class User {   _
	name = "Аноним";_    
	sayHi() {     
		alert(`Привет, ${this.name}!`);   } }  
	new User().sayHi();``
~~~

#### 5. Расскажи про наследование классов? Можно ли наследоваться от нескольких классов?  

Наследование классов – это способ расширения одного класса другим классом.
Классы в JavaScript поддерживают наследование с помощью ключевого слова #extends.  

#extends позволяет расширить родительский класс дочерним. При этом дочерний класс наследует от родительского конструктор, поля и методы

В выражении class Child extends Parent { } класс Child наследует от класса Parent конструктор, поля и методы.  

Создадим дочерний класс ContentWriter, расширяющий родительский класс User:  
  
```
class User {
    name

    constructor(name) {
        this.name = name
    }

    getName() {
        return this.name
    }
}

class ContentWriter extends User {
    posts = []
}

const writer = new ContentWriter('Лермонтов')

writer.name // Лермонтов
writer.getName() // Лермонтов
writer.posts // []
```

ContentWriter наследует от User конструктор, метод getName() и поле name. В самом ContentWriter определяется новое поле posts.  
  
Обратите внимание, что частные поля и методы родительского класса не наследуются дочерними классами.

#### '-----'
#### 22. Что такое MapWeak / SetWeak?  
Подробнее: https://learn.javascript.ru/weakmap-weakset
##### #WeakMap
#WeakMap – предотвращает удаление обьектов сборщиком мусора, когда эти обьекты выступают в качестве ключей.

1. В основном, `WeakMap` используется в качестве _дополнительного хранилища данных_.
2. Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его. 
   Для хранения результатов мы можем использовать `Map`

##### #WeakSet
Коллекция `WeakSet` ведёт себя похоже:

-   Она аналогична `Set`, но мы можем добавлять в `WeakSet` только объекты (не примитивные значения).
-   Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
-   Как и `Set`, она поддерживает `add`, `has` и `delete`, но не `size`, `keys()` и не является перебираемой.

Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве `WeakSet` может что-то сказать нам об объекте.

##### Итого
`WeakMap` – это `Map`-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.
`WeakSet` – это `Set`-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.
`WeakMap` и `WeakSet` используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в `WeakMap` или в `WeakSet`, то он будет удалён автоматически.

#### 23. Что такое #Set, в каком виде хранится информация, какие методы для работы с ним существуют?  
Подробнее: [[1.4 Методы map и set]]

Объект #Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:
-   [`new Set(iterable)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/Set) – создаёт `Set`, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый `Set`.
-   [`set.add(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект `set`.
-   [`set.delete(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/delete) – удаляет значение, возвращает `true`, если `value` было в множестве на момент вызова, иначе `false`.
-   [`set.has(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has) – возвращает `true`, если значение присутствует в множестве, иначе `false`.
-   [`set.clear()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/clear) – удаляет все имеющиеся значения.
-   [`set.size`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/size) – возвращает количество элементов в множестве.

Основная «изюминка» – это то, что при повторных вызовах `set.add()` с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

Например, мы ожидаем посетителей, и нам необходимо составить их список. Но повторные визиты не должны приводить к дубликатам. Каждый посетитель должен появиться в списке только один раз.

Множество `Set` – как раз то, что нужно для этого:
~~~
`let set = new Set();  
let john = { name: "John" }; 
let pete = { name: "Pete" }; 
let mary = { name: "Mary" };  // считаем гостей, некоторые приходят несколько раз 

set.add(john); 
set.add(pete); 
set.add(mary); 
set.add(john); 
set.add(mary);  // set хранит только 3 уникальных значения 

alert(set.size); // 3  
	for (let user of set) {   
		alert(user.name); // John (потом Pete и Mary) }`
~~~

##### Перебор обьекта #set

Мы можем перебрать содержимое объекта set как с помощью метода `for..of`, так и используя `forEach`:
~~~
`let set = new Set(["апельсин", "яблоко", "банан"]);  

for (let value of set) 
	alert(value);  // то же самое с forEach: 

set.forEach((value, valueAgain, set) => {   
	alert(value); });`
~~~

Заметим забавную вещь. Функция в `forEach` у `Set` имеет 3 аргумента: значение `value`, потом _снова то же самое значение_ `valueAgain`, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом `Map`, в котором колбэк `forEach` имеет 3 аргумента. Выглядит немного странно, но в некоторых случаях может помочь легко заменить `Map` на `Set` и наоборот.

`Set` имеет те же встроенные методы, что и `Map`:
-   [`set.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/keys) – возвращает перебираемый объект для значений,
-   [`set.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/values) – то же самое, что и `set.keys()`, присутствует для обратной совместимости с `Map`
-   [`set.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/entries) – возвращает перебираемый объект для пар вида `[значение, значение]`, присутствует для обратной совместимости с `Map`.

Перебор `Map` и `Set` всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.

#### 24. Что из себя представляет объект #Map, в каком виде он хранит данные, чем может быть ключ? Какие методы для работы с ним существуют? Чем Map отличается от объекта?  
Подробнее: [[1.4 Методы map и set]]

#Map  – коллекция пар ключ-значение.
Объект содержит пары ключ-значение и запоминает исходный порядок вставки ключей. Любое значение (как объекты, так и [примитивные значения](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)) может использоваться либо как ключ, либо как значение.

Map хранит в себе данные, где в виде ключа могут быть: строки, цифры, булево значение.

Например:
~~~
let map = new Map();  
map.set("1", "str1");    // строка в качестве ключа 
map.set(1, "num1");      // цифра как ключ 
map.set(true, "bool1");  // булево значение как ключ  
// помните, обычный объект Object приводит ключи к строкам? // Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения: 

alert(map.get(1)); // "num1" 
alert(map.get("1")); // "str1"  
alert(map.size); // 3`
~~~

Методы и свойства:

-   [`new Map([iterable])`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/Map) – создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар `[ключ,значение]` для инициализации.
-   [`map.set(key, value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set) – записывает по ключу `key` значение `value`.
-   [`map.get(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get) – возвращает значение по ключу или `undefined`, если ключ `key` отсутствует.
-   [`map.has(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has) – возвращает `true`, если ключ `key` присутствует в коллекции, иначе `false`.
-   [`map.delete(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete) – удаляет элемент по ключу `key`.
-   [`map.clear()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear) – очищает коллекцию от всех элементов.
-   [`map.size`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size) – возвращает текущее количество элементов.

Отличия от обычного объекта `Object`:
-   Что угодно может быть ключом, в том числе и объекты.
-   Есть дополнительные методы, свойство `size`.
Как мы видим, в отличие от объектов, ключи не были приведены к строкам. Можно использовать любые типы данных для ключей.

##### Особенности использования map[key]

`map[key]` это не совсем правильный способ использования `Map`

Хотя `map[key]` также работает, например, мы можем установить `map[key] = 2`, в этом случае`map` рассматривался бы как обычный JavaScript объект, таким образом это ведёт ко всем соответствующим ограничениям (только строки/символьные ключи и так далее).
Поэтому нам следует использовать методы `map`: `set`, `get` и так далее.

###### **Map может использовать объекты в качестве ключей.**
Например:
~~~
let john = { name: "John" };  // давайте сохраним количество посещений для каждого пользователя let visitsCountMap = new Map();  // объект john - это ключ для значения в объекте 
Map visitsCountMap.set(john, 123);  
alert(visitsCountMap.get(john)); // 123`
~~~

Использование объектов в качестве ключей – одна из наиболее заметных и важных функций `Map`. Это то что невозможно для `Object`. Строка в качестве ключа в `Object` – это нормально, но мы не можем использовать другой `Object` в качестве ключа в `Object`.

Давайте попробуем заменить `Map` на `Object`:
~~~~
let john = { name: "John" }; let ben = { name: "Ben" }; 
let visitsCountObj = {}; // попробуем использовать объект  visitsCountObj[ben] = 234; // пробуем использовать объект ben в качестве ключа visitsCountObj[john] = 123; // пробуем использовать объект john в качестве ключа, при этом объект ben будет замещён  _// Вот что там было записано! 
alert( visitsCountObj["[object Object]"] ); // 123_`
~~~~
Так как `visitsCountObj` является объектом, он преобразует все ключи `Object`, такие как `john` и `ben`, в одну и ту же строку `"[object Object]"`. Это определенно не то, чего мы хотим.

###### Как объект `Map` сравнивает ключи

Чтобы сравнивать ключи, объект `Map` использует алгоритм [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero). Это почти такое же сравнение, что и === , с той лишь разницей, что `NaN` считается равным `NaN`. Так что `NaN` также может использоваться в качестве ключа.

Этот алгоритм не может быть заменён или модифицирован.

###### Цепочка вызовов

Каждый вызов `map.set` возвращает объект map, так что мы можем объединить вызовы в цепочку:
~~~
`map.set("1", "str1")   
	.set(1, "num1")   
	.set(true, "bool1");`
~~~

Для перебора коллекции `Map` есть 3 метода:
-   [`map.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys) – возвращает итерируемый объект по ключам,
-   [`map.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values) – возвращает итерируемый объект по значениям,
-   [`map.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries) – возвращает итерируемый объект по парам вида `[ключ, значение]`, этот вариант используется по умолчанию в `for..of`.

Например:
~~~
let recipeMap = new Map([   ["огурец", 500],   ["помидор", 350],   ["лук",    50] ]);  
// перебор по ключам (овощи) 
	for (let vegetable of recipeMap.keys()) {   

alert(vegetable); // огурец, помидор, лук 
}  // перебор по значениям (числа) 
	
	for (let amount of recipeMap.values()) {   

alert(amount); // 500, 350, 50 
}  // перебор по элементам в формате [ключ, значение] 

	for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()   

alert(entry); // огурец,500 (и так далее) 
}
~~~

###### Используется порядок вставки

В отличие от обычных объектов `Object`, в `Map` перебор происходит в том же порядке, в каком происходило добавление элементов.

Кроме этого, `Map` имеет встроенный метод `forEach`, схожий со встроенным методом массивов `Array`:
~~~
``// выполняем функцию для каждой пары (ключ, значение) 

recipeMap.forEach((value, key, map) => {   
	alert(`${key}: ${value}`); // огурец: 500 и так далее });``
~~~

#### 25. Что такое #деструктуризация? 
Подробнее: [[1.3 Деструктуризация]]

_Деструктурирующее присваивание_ – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.
~~~
Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.
~~~
-   Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.
    
-   Полный синтаксис для объекта:
    ~~~
    `let {
	    prop : varName = default, ...rest} = object` }
    ~~~
    Cвойство `prop` объекта `object` здесь должно быть присвоено переменной `varName`. 
    Если в объекте отсутствует такое свойство, переменной `varName` присваивается значение по умолчанию.
    
    Свойства, которые не были упомянуты, копируются в объект `rest`.
    
-   Полный синтаксис для массива:
    ~~~
    `let [item1 = default, item2, ...rest] = array`
    ~~~
    Первый элемент отправляется в `item1`; второй отправляется в `item2`, все остальные элементы попадают в массив `rest`.
    
-   Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и правая.

##### Деструктуризация массива
~~~~
`// у нас есть массив с именем и фамилией 
	let arr = ["Ilya", "Kantor"];  _// деструктурирующее присваивание // записывает 
	
	firstName = arr[0] // и 
	surname = arr[1] 
	
	let [firstName, surname] = arr;_  
	alert(firstName); // Ilya 
	alert(surname);  // Kantor`
~~~~
Теперь мы можем использовать переменные вместо элементов массива.

##### Деструктуризация обьекта

Деструктурирующее присваивание также работает с объектами.

Синтаксис:
`let {var1, var2} = {var1:…, var2:…}`

У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в `{...}`.

Например:
~~~
`let options = {   
	title: "Menu",   width: 100,   height: 200 };  _

let {title, width, height} = options;_  

alert(title);  // Menu 
alert(width);  // 100 
alert(height); // 200`
~~~

Свойства `options.title`, `options.width` и `options.height` присваиваются соответствующим переменным.

Порядок не имеет значения.

#### 26. Что такое #rest и #spread? В чём их разница? Какой тип данных у rest? Как с помощью spred сделать копию или конкатенацию массива / объекта?  
Подробнее: [[1.2 Остаточные параметры и оператор расширения]]
##### spread
Подробнее: [Синтаксис Spread](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

#Spread  позволяет расширить доступные для итерации элементы (например, массивы или строки) в местах

-   для функций: где ожидаемое количество аргументов для вызовов функций равно нулю или больше нуля;
-   для элементов (литералов массива);
-   для выражений объектов: в местах, где количество пар "ключ-значение" должно быть равно нулю или больше (для объектных литералов);

###### Практическое применение (с массивом)
	
1.  [... a] создаёт копию массива
2.  [...a, ...b] обьединяет массивы
3.  [...a, 'x', ...b] обьединяет массивы

###### Практическое применение (с обьектом)

НЕ ПРИМЕНЯЕТСЯ ТАК!
. ...{какая-то переменная} // TypeError (найден невызываемый итераторт)

ПРИМЕНЯЕТСЯ:
1. ({...obj1}) 
2. ({...obj1, ...obj2})  // Копирует обьект из двух
	При обьединении обьектов, где совпадают наименования ключей, но их значения различны, за итоговый принимается тот, который последний при перечислении).

###### Практика

1. Хотим найти максимальное число с массива
Math.max(values: 5, 37, 42, 17) // 42
2. Есть массив [...] 
	Math.max(numbers) // Nan      !!! неверная формулировка
	Применим Spread
	Math.max(...numbers) // 42

##### rest
Подробнее: [Синтаксис Rest](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)

Синтаксис параметра #rest позволяет функции принимать неопределенное количество аргументов в виде массива, обеспечивая способ представления [переменных функций](https://en.wikipedia.org/wiki/Variadic_function) в JavaScript.

Основное отличие rest от spread в области применения.

Например:
~~~
function sum (a, b) {
return a + b
}

const numbers = [1, 2, 3, 4, 5]
console.log(sum(...numbers)) // 3 // Был использован Spread 

Была произведена сумма чисел 1 и 2. Числа 3, 4, 5 были проигнорированы, потому что нехватило операторов для их вычислений.

Используем Rest

function sum (a, b, ...rest)
console.log(rest) // Были собраны оставшиеся параметры в массив

1. Просуммируем все элементы массива

function sum (a, b, ...rest) {
return a + b + rest.reduce((a, i) => a + i, 0) // 15
}

2. Получим значение из массива

const a = numbers[0];
const b = numbers[1]
console.log(a, b)

Проведём деструктуризацию [[3 Деструктуризация]]
const [a, b] = numbers;
const [a, b, ...others] = numbers;
console.log(a, b, others) // Выведется 3 массива(обьекта) с числами.
~~~

##### В чем разница между rest и spread

Основное отличие rest от spread в области применения:
1.  #spread извлекает элементы массива,
2.  #rest собирает элементы (например, аргументы функции) в массив.

Когда мы видим `"..."` в коде, это могут быть как остаточные параметры, так и оператор расширения
Как отличить их друг от друга:

-   Если `...` располагается в конце списка параметров функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив #rest
-   Если `...` встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива. #spread

Полезно запомнить:
-   Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
-   С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.

#### 27. Как преобразовать список пар ключ-значение в объект.?  
Подробнее: [Object.fromEntries()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)

Метод Object. #fromEntries() преобразует список пар ключ-значение в объект.

Метод `Object.fromEntries()` принимает список пар ключ-значение и возвращает новый объект, свойства которого задаются этими записями. 
Ожидается, что аргумент _iterable_ будет объектом, который реализует метод `@@iterator`, который возвращает объект итератора, который создаёт двухэлементный массивоподобный объект, первый элемент которого является значением, которое будет использоваться в качестве ключа свойства, а второй элемент — значением связанного с этим ключом свойства.

~~~
const entries = new Map([
  ['foo', 'bar'],
  ['baz', 42]
]);

const obj = Object.fromEntries(entries);

console.log(obj);
// Expected output: Object { foo: "bar", baz: 42 }
~~~

##### Синтаксис
Object.fromEntries(iterable);

`iterable` Итерируемый объект, такой как [`Array`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array) или [`Map` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "Currently only available in English (US)") или другие объекты, реализующие [iterable протокол](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol).

##### Возвращаемое значение
Новый объект, свойства которого задаются записями iterable.

#### 28. Можно ли перебирать свойства объекта?  
Подробнее: [[2.1 Объекты]] , [Обьекты: перебор свойств](https://learn.javascript.ru/object-for-in)

Для перебора всех свойств объекта используется цикл `for..in`. 

##### Синтаксис:
~~~
`for (key in object) {   
	// тело цикла выполняется для каждого свойства объекта }`
~~~
К примеру, давайте выведем все свойства объекта `user`:
~~~
`let user = {   
	name: "John",   
	age: 30,   
	isAdmin: true };  

for (let key in user) {   // ключи   
	alert( key );  // name, age, isAdmin   // значения ключей   
	alert( user[key] ); // John, 30, true }`
~~~
Обратите внимание, что все конструкции «for» позволяют нам объявлять переменную внутри цикла, как, например, `let key` здесь.

Кроме того, мы могли бы использовать другое имя переменной. 
Например, часто используется вариант `"for (let prop in obj)"`.

##### Краткие выводы

-   Цикл по ключам: `for (key in obj)`.
-   Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах).
-   Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало `+`, как описано в примере выше, а потом, в процессе обработки, преобразуют такие ключи в числа.

#### 29. Как сделать глубокое копирование объекта?  

Если необходимо полностью скопировать сложную структуру данных, например, массив с объектами, то нужно делать _глубокое_ (deep) или полное копирование данных. JavaScript не содержит функций для глубокого копирования, лучший вариант сделать глубокую копию — сериализовать структуру в [JSON](https://doka.guide/tools/json/) и тут же распарсить.

##### Глубокое копирование, используя методы #JSON

```javascript
const myObj = {
  one: 1,
  two: 2,
  three: 3
}

const newObj = JSON.parse(JSON.stringify(myObj))

console.log(myObj === newObj)
// false
```

##### Глубокое копирование. Важно!

Данный метод не подойдет если в Вашем объекте присутствует структуры данных `Map`, `Set`, классы типа `Date`, `Infinity`, `undefined`, функции, типизированные массивы...

```javascript
const myObj = {
  boolean: true,
  string: "строка",
  number: 12345,
  nul: null,
  undfd: undefined,
  inf: Infinity,
  date: new Date(),
  func: () => console.log("функция")
}

const newObj = JSON.parse(JSON.stringify(myObj))

console.log(newObj)
// {
//  "boolean": true,
//  "string": "строка",
//  "number": 12345,
//  "nul": null,
//  "inf": null,
//  "date": "2020-08-28T22:06:14.982Z"
// }
```

#### 30. Как поверхностно скопировать объект?  

При копировании объектов или массивов JavaScript копирует данные только на один уровень вглубь. Этот тип копирования называется _поверхностным_ (shallow).

##### Поверхностное копирование с помощью метода #spread

```javascript
const myObj = {
  one: 1,
  two: 2,
  three: 3
}

const newObj = { ...myObj }

console.log(myObj === newObj)
// false
```

##### Поверхностное копирование при помощи метода Object. #assign ()

```javascript
const myObj = {
  one: 1,
  two: 2,
  three: 3
}

const newObj = Object.assign({}, myObj)

console.log(myObj === newObj)
// false
```

##### Поверхностное копирование function()

```javascript
const myObj = {
  one: 1,
  two: 2,
  three: 3
}

function shallowCopy(obj) {
  return Object.assign({}, obj)
  // или
  // return { ...obj }
}

const newObj = shallowCopy(myObj)

console.log(newObj)
// {
//  "one": 1,
//  "two": 2,
//  "three": 3
// }

console.log(myObj === newObj)
// false
```

#### 31. Как проверить наличия свойства у объекта? Как отличить отсутствующее свойство от свойства со значением undefined? 
Подробнее: [Метод hasOwnProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)

Метод #hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство.

##### Синтаксис
obj.hasOwnProperty(prop)

##### Параметры
`prop`  Имя проверяемого свойства.

##### Описание
Каждый объект, произошедший от [`Object`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object), наследует метод `hasOwnProperty`. 
Этот метод может использоваться для определения того, содержит ли объект указанное свойство в качестве собственного свойства объекта; в отличие от оператора [`in`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in), этот метод не проверяет существование свойств в цепочке прототипов объекта.

##### Как отличить отсутствующее свойство от свойства со значением undefined?

Если свойство отсутствует, то метод `hasOwnProperty()` вернёт false;
А #undefined будет, когда переменная/ключ заданы, а значения не содержит.

Переменная, не имеющая присвоенного значения, обладает типом `undefined`. 
Также `undefined`возвращают метод или инструкция, если переменная, участвующая в вычислениях, не имеет присвоенного значения. Функция возвращает `undefined`, если она не [возвращает](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/return) какого-либо значения.

___

#### 32. Можно ли удалять что-то из объекта?
Подробнее: [Оператор delete](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/delete)

Оператор #delete удаляет свойство из объекта.

##### Синтаксис
`delete выражение` где результат вычисления _выражения_ должен быть ссылкой на свойство (объекта), например:

~~~
delete object.property
delete object['property']
delete object[index]
delete property // удаляет свойства глобального объекта, или,
                // используя инструкцию with, свойства объекта, на который ссылается инструкция
~~~

Если результат вычисления _выражения_ не является свойством (объекта), `delete` ничего не делает.

##### Параметры
`object`  Имя объекта или выражение, результатом вычисления которого является объект.
`property`  Удаляемое свойство.
`index`  Целое число, представляющее собой индекс массива, который должен быть удалён.

##### Возвращаемое значение

Возвращает false, только если свойство существует в самом объекте, а не в его прототипах, и не может быть удалено. Во всех остальных случаях возвращает true.

##### Удаление элементов массива

Когда с помощью оператора #delete удаляется элемент массива, длина массива не меняется. Например, если вы удалите a[3], a[4] по прежнему a[4], а a[3] не определено. Так будет даже если вы удалите последний элемент массива (`delete a[a.length-1]`).

___