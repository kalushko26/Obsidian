#### 1. Какие есть типы данных в JavaScript?  
Подробнее: [[1.1 Типы данных]]

Есть восемь основных типов данных в JavaScript. 
-   Семь из них называют «примитивными» типами данных:
    -   `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном `±(253-1)`.
    -   `bigint` для целых чисел произвольной длины.
    -   `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
    -   `boolean` для `true`/`false`.
    -   `null` для неизвестных значений – отдельный тип, имеющий одно значение `null`.
    -   `undefined` для неприсвоенных значений – отдельный тип, имеющий одно значение `undefined`.
    -   `symbol` для уникальных идентификаторов.
-   И один не является «примитивным» и стоит особняком:
    -   `object` для более сложных структур данных.

Оператор `typeof` позволяет нам увидеть, какой тип данных сохранён в переменной.

-   Имеет две формы: `typeof x` или `typeof(x)`.
-   Возвращает строку с именем типа. Например, `"string"`.
-   Для `null` возвращается `"object"` – это ошибка в языке, на самом деле это не объект.

#### 2 Как хранятся числа? 
Подробнее: [[1.5 Числа]]

JavaScript-числа всегда хранятся в виде чисел с плавающей запятой двойной точности в соответствии с международным стандартом Института инженеров электротехники и электроники — **IEEE** 754. Этот формат хранит числа в 64 битах, где число (дробь) хранится в битах от 0 до 51, показатель степени - в битах от 52 до 62, а знак - в бите 63.:

#### 3 Почему получаются неточные вычисления 0,1 + 0,2 === 0,3  
Да-да, сумма `0.1` и `0.2` не равна `0.3`.
`alert( 0.1 + 0.2 ); // 0.30000000000000004`

Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как `0.1`, `0.2`, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.
~~~
Другими словами, что такое `0.1`? Это единица делённая на десять — `1/10`, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: `1/3`, которая становится бесконечной дробью `0.33333(3)`.

Деление на `10` гарантированно хорошо работает в десятичной системе, но деление на `3` – нет. По той же причине и в двоичной системе счисления, деление на `2` обязательно сработает, а `1/10` становится бесконечной дробью.
~~~
В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, точно также, как нет возможности хранить одну третью в десятичной системе счисления.

Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует.

Пример:
`alert( 0.1.toFixed(20) ); // 0.10000000000000000555`
И когда мы суммируем 2 числа, их «неточности» тоже суммируются.
Вот почему `0.1 + 0.2` – это не совсем `0.3`.

#### 4 Что такое неявное приведение типов? Как оно работает?  
Подробнее: [[1.4.2 Подробнее про преобразование типов]]

Неявное преобразование происходит, когда мы заставляем JavaScript работать со значениями разных типов. Например, если мы хотим «сложить» число и строку.

Дело в том, как JavaScript пробует эти два типа «сопоставить» друг с другом, чтобы с ними работать.

Когда мы складываем со строкой получаем строку (контатанация строк)
value = 30 + ''_"  // 30 получается неявное преобразование в строку
value = 30 + " _" + 30 // 3030
value = 30 - " " // 30
value = 30 - "asds" // NaN
value = 30 - "5" // 25

const myString = 'abc' // console.log(typeof myString) // строка
const myNumber = 10 // console.log(typeof myNumber) // число
const myBoolean = true // console.log(typeof myBoolean) // boolean
const myNull = null // console.log(typeof myNull) // объект
let myUndefined //  console.log(typeof myUndefined) // underfined
const myObject = {} // console.log(typeof myObject) // обьект
const myArray = [] // console.log(typeof myArray) // обьект
  
#### 5 Какие ошибки бывают и что означают? Логические ошибки останавливают работы скрипта?
Подробнее: [Руководство по обработке ошибок](https://habr.com/ru/company/ruvds/blog/431078/)

* ReferenceError (выполнение программы останавливается)
ReferenceError возникает, когда используется несуществующий идентификатор (имя). Например, если ваша функция возвращает значение константы, но такой константы не существует. Или в каком-нибудь выражении (фрагмент кода, который вычисляется в значение, как формула) используется неизвестный идентификатор.
* typeError
TypeError возникает, когда вы используете неправильный тип. Например, если вы пытаетесь вызвать численную константу как функцию.
* EvalError
Представляет ошибку, которая генерируется при выполнении глобальной функции eval()
* RangeError
Ошибка генерируется, если параметр или переменная, представляют число, которое находится вне некотоого допустимого диапазона
* SyntaxError
Представляет ошибку синтаксиса
* URIError
Ошибка генерируется при передаче функциям encodeURI() и decodeURI() некорректных значений
* AggregateError
Предоставляет ошибку, которая объединяет несколько возникших ошибок

#### 6 Что такое объект? Каким типом может быть ключ, а каким значение?  
Подробнее: [[2.1 Объекты]] 

Объекты {} – это ассоциативные массивы с рядом дополнительных возможностей.
Они хранят свойства (пары ключ-значение), где:
-   Ключи свойств должны быть строками или символами (обычно строками).
-   Значения могут быть любого типа.

#### 7 Какими способами можно получить доступ к свойству/методу объекта?  
Подробнее: [[2.1 Объекты]]

Чтобы получить доступ к свойству, мы можем использовать:
-   Запись через точку: `obj.property`.
-   Квадратные скобки `obj["property"]`. Квадратные скобки позволяют взять ключ из переменной, например, `obj[varWithKey]`.

Дополнительные операторы:
-   Удаление свойства: `delete obj.prop`.
-   Проверка существования свойства: `"key" in obj`.
-   Перебор свойств объекта: цикл for `for (let key in obj)`.

То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто `Object`.

В JavaScript есть много других типов объектов:
-   `Array` для хранения упорядоченных коллекций данных,
-   `Date` для хранения информации о дате и времени,
-   `Error` для хранения информации об ошибке.
-   … и так далее.

#### 8 Что такое ссылочный тип данных? Когда происходит передача по ссылке?  
Подробнее: [[Хранение по ссылке и по значению]]

Переменные (и константы) в JavaScript могут хранить два вида данных: примитивные и ссылочные. К примитивным относятся все примитивные типы: числа, строки, булеан и так далее. К ссылочным – объекты.

В чем разница между ссылочными и примитивными типами данных и почему об этом нужно знать?

Разница проявляется при изменении данных, их передаче и возврате из функций. Мы уже знаем, что массив можно менять, даже если он записан в константу. Здесь как раз и проявляется ссылочная природа. Константа хранит ссылку на массив, а не сам массив, и эта ссылка не меняется. А вот массив поменяться может. С примитивными типами такой трюк не пройдет.

Другой способ убедиться в том, что массивы являются ссылками – создать несколько констант, содержащих один массив, и посмотреть, как они меняются:

```
const items = [1, 2];
// Ссылаются на один и тот же массив
const items2 = items;
items2.push(3);

console.log(items2); // => [1, 2, 3]
console.log(items); // => [1, 2, 3]
items2 === items; // true
```

Сравнение массивов тоже происходит по ссылке. Это может быть очень неожиданно с непривычки. Одинаковые по структуре массивы имеют разные ссылки и не равны друг другу:

```
[1,2,3] === [1,2,3]; // false
```

Более того, если передать массив в какую-то функцию, которая его изменяет, то массив тоже изменится. Ведь в функцию передается именно ссылка на массив. Посмотрите на пример:

```
const f = (coll) => coll.push('wow');

const items = ['one'];
f(items);
console.log(items); // => [ 'one', 'wow' ]
f(items);
console.log(items); // => [ 'one', 'wow', 'wow' ]
```

#### 9 Что такое рекурсия? Что если будет отсутствовать терминальный случай? 
Подробнее: [[3.1 Рекурсия]]

Существует 2 подхода к решению задач программирования: итеративный и рекурсивный.
Рекурсия – это функция, которая сама вызывает себя. 

Рекурсивная функция - это бесконечный цикл (при решении задач итеративным методом использовался бы цикл while) вызывания функцией самой себя, которая никогда не останвится.

```
// WARNING: This function contains an infinite loop!

function countdown(i) {
  console.log(i)
  countdown(i - 1)
}
countdown(5);    // This is the initial call to the function.
```

есть такое понятие, как граничный случай, когда функция перестаёт себя вызывать, предотвращая зацикливание - это манипуляция с условиями if..else.

```
function fact(x) {
  if (x == 1) {  
    return 1;  
  } else {      
    return x * fact(x-1);
  }
}
```

Значение, на котором рекурсия заканчивается, называют **базовый случай** или терминальный сценарий. Если рекурсия не заканчивается, она зацикливается.

#### 10 Что такое чистая функция?  
Подробнее: [Чистые функции](https://habr.com/ru/post/437512/)

Чистые функции — строительные блоки в функциональном программировании.

Для того, чтобы понимать, что перед тобой чистая функция или нет, необходимо обращать внимание на ряд условий:
* Каждый раз функция возвращает одинаковый результат, когда она вызывается с тем же набором аргументов

**Нечистые функции = непостоянные результаты**
~~~
Сравните это:
const add = (x, y) => x + y; 
add(2, 4); // 6

С этим:
let x = 2; 
const add = (y) => { x += y; }; 
add(4); // x === 6 (the first time)
~~~
* Нет побочных эффектов
	1.  Видоизменение входных параметров
	2.  console.log
	3.  HTTP вызовы (AJAX/fetch)
	4.  Изменение в файловой системе
	5.  Запросы DOM

#### 11 Что такое побочный эффект?  
Подробнее: [Чистые функции](https://habr.com/ru/post/437512/)

Побочные эффекты включают: меняющийся вход, HTTP-вызовы, запись на диск, 
вывод на экран.

Вот “нечистая” функция с побочным эффектом.  

```
const impureDouble = (x) => {
  console.log('doubling', x);
  return x * 2;
};
const result = impureDouble(4);
console.log({ result });
```

**console.log** здесь это побочный эффект, но он не повредит. Мы все равно получим те же результаты, учитывая те же данные.  

Однако, это может вызвать проблемы.  
“Нечистое” изменение объекта  

```
const impureAssoc = (key, value, object) => {
  object[key] = value;
};
const person = {
  name: 'Bobo'
};
const result = impureAssoc('shoeSize', 400, person);
console.log({
  person,
  result
});
```

Переменная person была изменена навсегда, потому что функция была объявлена через оператор присваивания.

#### 12 Как проверить переменную на существование? Что будет если вызвать typeof у неинициализированной переменной?  
Подробнее: [[1.2 Переменные]]

#переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.

Использовать console.log(x), если переменная задана, то выведется значение переменной, если нет, то x is not defined.

Оператор `typeof` возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.

У него есть две синтаксические формы:

1.  Синтаксис оператора: `typeof x`.
2.  Синтаксис функции: `typeof(x)`.

typeOf у неинициализированной переменной будет вызывать reference error.

#### 13 В чём разница между var / let / const? Что такое всплытие / hoisting?  
Подробнее: [[1.2.2 В чём разница между var, let и const в JavaScript]]

1. var, let и const обьявляют переменную.
2. Когда в JS создаётся переменная она инициализируется с заданным именем, а ее значение принимается за "underfined" (присваение значения по умолчанию "Hoisting" во время фазы создания)
3. После "инициализации" переменной можно говорить об области видимости. #областьВидимости видимости определяет, где в коде программы будут доступны переменные и функции. В JavaScript есть два типа области видимости — глобальная и локальная (**global scope** и **function scope**).
Когда все стартовые понятия обьяснены можно перейти к обьяснению, в чем разница между var, let и const.

##### VAR
1. Любая переменная, объявленная через **var** вне блока функции, доступна для использования во всем окне.  
2. **Var** является локальной, когда объявлена внутри функции. Это означает, что она доступна и к ней можно обращаться только изнутри этой функции.
3. Переменные **var** могут быть объявлены повторно или обновлены
4.  Переменные **var** поднимаются в верхнюю часть своей области видимости и инициализируются со значением undefined

**Поднятие var:** переменные var поднимаются в верхнюю часть своей области видимости и инициализируются со значением undefined.

##### LET
1. **let** выступает в качестве улучшения объявления через **var**
2. let имеет блочную область видимости (т.е переменная, объявленная в блоке через let, будет доступна только внутри этого блока)
3. Переменные let могут быть обновлены, но не объявлены повторно (в отличие от var, let-переменные нельзя повторно объявить внутри области видимости)

**Поднятие** let Точно так же, как в случае с var, объявления через let перемещаются вверх. Но в отличие от var-переменных, которые инициализируются как undefined, ключевое слово для let не инициализируется. Так что если вы попытаетесь использовать переменную let до того, как она будет объявлена, то получите ошибку обращения к переменной **ReferenceError.**

##### CONST
1. Переменные, объявленные через const, сохраняют постоянные значения. Объявления через const имеют некоторое сходство с объявлениями через let.
2. **const имеет блочную область видимости**
3. Переменные const не могут быть ни обновлены, ни объявлены повторно

##### Всплытие/погружение

Когда некоторый объект инициирует событие, то оно не просто возникает на нём, а распространяется в документе определённым образом.

Согласно стандарту, оно делится на 3 фазы:
1.  Фаза погружения или захвата – от `window` к родителю цели (цель – это объект, который инициировал это событие).
2.  Фаза цели – событие на цели.
3.  Фаза всплытия – обратно, от родителя цели к `window`.

Самое главное для нас, когда событие путешествует по документу, то браузер вызывает обработчики элементов, через которые оно проходит.

###### Если коротко
В HTML DOM существует два способа распространения события - всплытие и погружение:

UseCapture - По умолчанию этот параметр имеет значение false, что задает _всплытие_ события. Если задать ему значение true, то будет использоваться _перехват_.

При _всплытии_ первым обрабатывает событие самый вложенный элемент, затем его родитель и т.д.: таким образом сначала обрабатывать событие "click" будет элемент p, а затем элемент div.

При _перехвате_ все происходит наоборот — сначала событие обрабатывает самый внешний элемент, в нашем случае div, а затем вложенный, т. е. элемент p.


#### 14 Что такое лексическое окружение? Что такое замыкание?  
Подробнее: [[0019 Замыкание]]
В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый _лексическим окружением_ `LexicalEnvironment`.

Объект лексического окружения состоит из двух частей:
1.  _Environment Record_ – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение `this`).
2.  Ссылка на _внешнее лексическое окружение_ – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

~~~
let phrase = "Hello"

function say(name) {
	alert(`&(phrase).&{name}`)
}

say("John"); // Hello, John
~~~

* Внутреннее лексическое окружение соответствует текущему выполнению `say`.
    В нём находится одна переменная `name`, аргумент функции. Мы вызываем `say("John")`, так что значение переменной `name` равно `"John"`.
-   Внешнее лексическое окружение – это глобальное лексическое окружение.
    В нём находятся переменная `phrase` и сама функция.

[Замыкание](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями.

Другими словами – замыкание возникает в том случае, если мы из одной функции возвращаем новую функцию. Тогда мы говорим, что новая функция замкнута на область видимости родительской.
		Еще проще это функция внутри другой функции

![[Pasted image 20221216134913.png]]
42 000

Функция 1 отработала и вернула нам новую функцию 2, тк 2ая функция была вызвана в контексте 1ой, то переменная n была замкнута в той функции, которую мы возвращаем.
Поэтому в функции 8 хранится значение n. Её замкнуло. Поэтому, мы получаем доступ к этой функции.

![[Pasted image 20221216135256.png]]
1+10

#### 15 Что означает функции высшего порядка?  
Подробнее: [[4.2 Функции высшего порядка.  Перебирающие методы массивов]]

Функции высшего порядка — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их. 

Проще говоря, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.

Функциональное программирование это — подход к программированию, при использовании которого функции можно передавать другим функциям в качестве параметров и использовать функции в качестве значений, возвращаемых другими функциями.

Функции рассматриваются, как обьекты первого класса.
Известно, что функции можно назначать переменным и константам, передавать функцию в виде параметров другой функции.

Исходя из этого, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.  

Применение функций высшего порядка filter, map, reduce

В качестве примера рассмотрим метод filter, который использовался для решения задач в блоке 1.4

Предположим, у нас имеется массив, содержащий объекты, в свойствах которых хранятся сведения об имени и возрасте представителей некой группы людей. Нам надо создать массив, в котором будут сведения только о совершеннолетних представителях этой группы (тех, чей возраст достиг 18 лет).  

https://platform.kata.academy/user/courses/1/1/3/11

#### 16 Как задавать значения в функции по умолчанию?  
Подробнее: [Параметры по умолчанию](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters)

**Параметры по умолчанию** позволяют задавать формальным параметрам функции значения по умолчанию в случае, если функция вызвана без аргументов, или если параметру явным образом передано значение `undefined`.

function multiply(a, b = 1) {
  return a * b;
}

```
function test(num = 1) {
  console.log(typeof num);
}

// num не передано, или передано undefined:
test();          // 'number' (num получил значение 1)
test(undefined); // 'number' (и здесь num получил значение 1)

// num передано значение null или другое "ложное" значение:
test('');        // 'string' (num получил значение '')
test(null);      // 'object' (num получил значение null)
```

#### 17 Какие есть способы создания функции? Что такое анонимная самовызывающаяся функция? 
Подробнее: [Функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)

Функции - ключевая концепция в JavaScript. Важнейшей особенностью языка является [первоклассная поддержка функций](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0 "первоклассная поддержка функций")​ _(functions as first-class citizen)_. Любая **функция это объект,** и следовательно ею можно манипулировать как объектом, в частности:
-   передавать как аргумент и возвращать в качестве результата при вызове других функций ([функций высшего порядка](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%B2%D1%8B%D1%81%D1%88%D0%B5%D0%B3%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B0 "функций высшего порядка"));
- создавать анонимно и присваивать в качестве значений переменных или свойств объектов.

1. Функцию можно обьявить (именная функция)
```
function declaration statement

function square(number) {
  return number * number;
}
```
2. Вызов анонимной функции
Функция вида "function declaration statement" по синтаксису является инструкцией 
(_statement_), ещё функция может быть вида "function definition expression". Такая функция может быть **анонимной** (она не имеет имени). Например, функция `square` может быть вызвана так:

```
function declaration statement

var square = function(number) { return number * number; };
var x = square(4); // x получает значение 16
```

Однако, имя может быть и присвоено для вызова самой себя внутри самой функции и для отладчика (_debugger_) для идентифицированные функции в стек-треках (_stack traces_; "trace" — "след" / "отпечаток").

```
var factorial = function fac(n) { return n < 2 ? 1 : n * fac(n - 1); };

console.log(factorial(3));
```

Функции вида "function definition expression" удобны, когда функция передаётся аргументом другой функции.

nameFunc()

#### 18 В чём разница между стрелочными и обычными функциями?  
Подробнее:
[1. Отличия между стрелочными и обычными функциями](https://doka.guide/js/function/)
[2. 5 отличий между стрелочными и обычными функциям](https://vc.ru/dev/133379-5-otlichiy-mezhdu-obychnymi-i-strelochnymi-funkciyami)

Стрелочная функция записывается намного короче, чем обычная. В самой простой записи ключевое слово `function` и фигурные скобки не требуются.

```
(argument1, argument2, ... argumentN) => {
  // тело функции
}
```

```
const add = (a, b) => a + b;
```

В многострочных стрелочных функциях кода больше, поэтому они имеют фигурные скобки, но в остальном не отличаются:
~~~
const divider = (numerator, denominator) => 
{   const result = numerator / denominator   
return result }`
~~~
##### 1 this
Внутри обыкновенной функции значение _this_ динамическое (в зависимости от контекста исполнения), во время выполнения функции объектом значения _this_ является объект, у которого был вызван метод.

##### 2 Конструкторы
Как следствие того, что стрелочные функции не имеют собственного _this_ они не могут быть использованы для создания объектов. Если попытаться вызвать стрелочную функцию с использованием ключевого слова _new_, JS кинет исключение:
~~~
const Car = (color) => { 
this.color = color; }; 
const redCar = new Car('red'); // TypeError: Car is not a constructor
~~~

##### 3 Неявный return

Ты можешь вернуть значение из стрелочной функции, точно таким же способом, как и из обычной функции, но с одним полезным исключением.

Если стрелочная функция содержит в теле одну инструкцию, и ты опустил фигурные скобки, тогда выражение будет возвращено автоматически.
~~~
const increment = (num) => num + 1; 
increment(41); // => 42
~~~

##### 4 Методы

Ты можешь использовать стрелочные функции как методы, внутри класса.
Сейчас, на контрасте с обыкновенной функцией, метод определенный с использованием стрелочной функции привязывает this к объекту класса.

#### 19 Какой есть метод для работы с фильтрацией массива? Результатом работы является новый массив или отфильтрованный текущий? Что функция предикат должна возвращать, чтобы элемент старого массива попал в отфильтрованный?  
Подробнее: [[2.6 Методы массивов]]

Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, `Array`.
Метод **`filter()`** **создаёт новый массив со всеми элементами**, прошедшими проверку, задаваемую в передаваемой функции.

`callbackFn` Функция-предикат, которая будет вызвана для проверки каждого элемента массива. Если функция возвращает `true`, то элемент остаётся в массиве, если `false`, то удаляется.

Принимает три аргумента `element` Текущий обрабатываемый элемент в массиве

* `index`  // Индекс текущего обрабатываемого элемента в массиве.
* `array` // Обрабатываемый массив, на котором был вызван метод `filter()`.
* `thisArg` //  Значение, используемое в качестве `this` при вызове колбэк-функции `callbackFn`.

[Подробнее про метод filter](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)

#### 20 Метод для обхода массива? Создаётся новый массив или мутируется текущий? Что будет записано в новый массив?  
Подробнее: 

На данный момент есть 5 способов перебора элементов настоящего массива:  
1.  метод `Array.prototype.forEach`;
2.  классический цикл `for`;
3.  «правильно» построенный цикл `for...in`
4. цикл `for...of` (неявное использование итератора);
5.  явное использование итератора.

`forEach` предназначен для перебора всех элементов массива, но кроме него ES6 предлагает еще несколько полезных методов для перебора всех или некоторых элементов плюс выполнения при этом каких-либо действий с ними:  
-   `every` — возвращает `true`, если для каждого элемента массива колбек возвращает значение приводимое к `true`.
-   `some` — возвращает `true`, если хотя бы для одного элемента массива колбек возвращает значение приводимое к `true`.
-   `filter` — создает новый массив, включающий те элементы исходного массива, для которых колбек возвращает `true`.
-   `map` — создает новый массив, состоящий из значений возращаемых колбеком.
-   `reduce` — сводит массив к единственному значению, применяя колбек по очереди к каждому элементу массива, начиная с первого (может быть полезен для вычисления суммы элементов массива и других итоговых функций).
-   `reduceRight` — работает аналогично reduce, но перебирает элементы в обратном порядке.

В зависимости от метода будет создан новый массив и в него будут записаны значения.

#### 21 После filter или map вновь созданный массив будет иметь одинаковую или отличную длину по сравнению со старым массивом?  
Подробнее: 

Длина массива — это количество элементов в нем. Например, в массиве arr= [1, 2, 3] — три элемента, а в массиве arr= [] — ноль элементов.

Длину массива можно узнать через свойство length. Синтаксис такой: arr.length. Например: Получение длинны массива с помощью свойства length var a = [1, 2, 3]; // инициализировали массив a var b = a.length; // задаем переменную b, её значение будет равно длине массива.

Метод `map()` позволяет трансформировать один массив в другой при помощи функций-колбэка. Переданная функция будет вызвана для каждого элемента массива по порядку. Из результатов вызова функции будет собран новый массив.
* `map()` возвращает **новый** массив, при этом исходный массив никак не изменится.

Метод массива `.filter()` позволяет получить новый массив, отфильтровав элементы с помощью переданной колбэк-функции. Колбэк-функция будет вызвана для каждого элемента массива и по результату функции примет решение включать этот элемент в новый массив или нет.
* В новом массиве отфильтрованные элементы будут находиться в том же порядке, в котором они были в исходном массиве.
* `.filter()` возвращает **новый** массив, при этом исходный массив **никак не изменится**.
#### 22 Что делает reduce? Какие аргументы принимает?
Подробнее: [[Подробнее про методы массивов]]

Метод [arr.reduce](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) используется для вычисления какого-нибудь единого значения на основе всего массива.

Синтаксис:
`let value = arr.reduce(function(accumulator, item, index, array) {   // ... }, [initial]);`
Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

Аргументы:
-   `accumulator` – результат предыдущего вызова этой функции, равен `initial` при первом вызове (если передан `initial`),
-   `item` – очередной элемент массива,
-   `index` – его индекс,
-   `array` – сам массив.

При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент.

Звучит сложновато, но всё становится проще, если думать о первом аргументе как «аккумулирующем» результат предыдущих вызовов функции. По окончании он становится результатом `reduce`.

Этот метод проще всего понять на примере.

Тут мы получим сумму всех элементов массива всего одной строкой:
~~~
let arr = [1, 2, 3, 4, 5];  
let result = arr.reduce((sum, current) => sum + current, 0);  
alert(result); // 15`
~~~
Здесь мы использовали наиболее распространённый вариант `reduce`, который использует только 2 аргумента.

Давайте детальнее разберём, как он работает.

1.  При первом запуске `sum` равен `initial` (последний аргумент `reduce`), то есть `0`, а `current` – первый элемент массива, равный `1`. Таким образом, результат функции равен `1`.
2.  При втором запуске `sum = 1`, и к нему мы добавляем второй элемент массива (`2`).
3.  При третьем запуске `sum = 3`, к которому мы добавляем следующий элемент, и так далее…

Поток вычислений получается такой:

![[Pasted image 20230119175431.png]]

Здесь отчётливо видно, как результат предыдущего вызова передаётся в первый аргумент следующего.

Мы также можем опустить начальное значение:
~~~
`let arr = [1, 2, 3, 4, 5];  // убрано начальное значение (нет 0 в конце) 
let result = arr.reduce((sum, current) => sum + current);  
alert( result ); // 15`
~~~
Результат – точно такой же! Это потому, что при отсутствии `initial` в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Таблица вычислений будет такая же за вычетом первой строки.

Но такое использование требует крайней осторожности. 
Если массив пуст, то вызов `reduce` без начального значения выдаст ошибку.

Вот пример:
~~~
`let arr = [];  
// Error: Reduce of empty array with no initial value // если бы существовало начальное значение, reduce вернул бы его для пустого массива. 
arr.reduce((sum, current) => sum + current);`
~~~
Поэтому рекомендуется всегда указывать начальное значение.