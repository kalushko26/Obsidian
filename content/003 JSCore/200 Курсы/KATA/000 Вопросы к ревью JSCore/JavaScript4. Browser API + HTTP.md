 
#### 1. Событийная модель JS? ( #всплытие-события  / #погружение )
 
Подробно: [[5.1 Всплытие и погружение]]

Когда некоторый объект инициирует событие, то оно не просто возникает на нём, а распространяется в документе определённым образом.

Согласно стандарту, оно делится на 3 фазы:
1.  Фаза погружения или захвата – от `window` к родителю цели (цель – это объект, который инициировал это событие).
2.  Фаза цели – событие на цели.
3.  Фаза всплытия – обратно, от родителя цели к `window`.

Самое главное для нас, когда событие путешествует по документу, то браузер вызывает обработчики элементов, через которые оно проходит.

![Фаза погружения события](https://itchief.ru/assets/images/javascript-events-bubbling-capturing/capturing.png)

###### Всплытие

**Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.**

Например, есть 3 вложенных элемента `FORM > DIV > P` с обработчиком на каждом:
~~~
<style>   
	body * {     
		margin: 10px;     
		border: 1px solid blue;   } 
</style>  

<form onclick="alert('form')">FORM   
	<div onclick="alert('div')">DIV     
		<p onclick="alert('p')">P</p>   
	</div> 
</form>`
~~~
Клик по внутреннему `<p>` вызовет обработчик `onclick`:
1.  Сначала на самом `<p>`.
2.  Потом на внешнем `<div>`.
3.  Затем на внешнем `<form>`.
4.  И так далее вверх по цепочке до самого `document`.

Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.

###### Погружение

Существует ещё одна фаза из жизненного цикла события –  #погружение (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.

Стандарт [DOM Events](https://www.w3.org/TR/DOM-Level-3-Events/) описывает 3 фазы прохода события:
1.  Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
2.  Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
3.  Фаза всплытия (bubbling stage) – событие начинает всплывать.

![[Pasted image 20230303211359.png]]

То есть при клике на `<td>` событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики.

**Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.**

Обработчики, добавленные через `on<event>`-свойство или через #HTML-атрибут , или через addEventListener( #event, #handler) с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент #capture вот так:
~~~
elem.addEventListener(..., {capture: true}) // или просто "true", как сокращение для {capture: true} 
elem.addEventListener(..., true)`
~~~
Существуют два варианта значений опции `capture`:

-   Если аргумент `false` (по умолчанию), то событие будет поймано при всплытии.
-   Если аргумент `true`, то событие будет перехвачено при погружении.

Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу («фазу цели»: событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение.

Давайте посмотрим и всплытие и погружение в действии:
~~~
<style>   
	body * {     
		margin: 10px;     
		border: 1px solid blue;   } 
</style>  

<form>FORM   
	<div>DIV     
		<p>P</p>   
	</div> 
</form>  

<script>   
	for(let elem of document.querySelectorAll('*')) {     
		elem.addEventListener("click", e => alert(`Погружение: ${elem.tagName}`), true);     
		elem.addEventListener("click", e => alert(`Всплытие: ${elem.tagName}`));   } 
</script>``
~~~
Здесь обработчики навешиваются на _каждый_ элемент в документе, чтобы увидеть в каком порядке они вызываются по мере прохода события.

Если вы кликните по `<p>`, то последовательность следующая:

1.  `HTML` → `BODY` → `FORM` → `DIV` (фаза погружения, первый обработчик)
2.  `P` (фаза цели, срабатывают обработчики, установленные и на погружение и на всплытие, так что выведется два раза)
3.  `DIV` → `FORM` → `BODY` → `HTML` (фаза всплытия, второй обработчик)

Существует свойство `event.eventPhase`, содержащее номер фазы, на которой событие было поймано. Но оно используется редко, мы обычно и так знаем об этом в обработчике.

Чтобы убрать обработчик `removeEventListener`, нужна та же фаза

Если мы добавили обработчик вот так `addEventListener(..., true)`, то мы должны передать то же значение аргумента `capture` в `removeEventListener(..., true)`, когда снимаем обработчик.

На каждой фазе разные обработчики на одном элементе срабатывают в порядке назначения

Если у нас несколько обработчиков одного события, назначенных `addEventListener` на один элемент, в рамках одной фазы, то их порядок срабатывания – тот же, в котором они установлены:
~~~
elem.addEventListener("click", e => alert(1)); // всегда сработает перед следующим elem.addEventListener("click", e => alert(2));`
~~~

#### 2. Что такое объект #Window / #BOM / #DOM?  
Подробнее: [[1.1 Браузерное окружение]]

Все обьекты JS работают в определенной среде она называется браузерное #окружение 

###### Window

Объект #window представляет собой **окно веб-браузера, в котором размещаются веб-страницы**. window является глобальным объектом, поэтому при доступе к его свойствам и методам необязательно использовать его имя.

На картинке ниже в общих чертах показано, что доступно для JavaScript в браузерном окружении:

![[Pasted image 20230223141906.png]]

Как мы видим, имеется корневой объект #window, который выступает в 2 ролях:
1.  Во-первых, это глобальный объект для JavaScript-кода, об этом говорится в [[0005 Глобальный объект]]
2.  Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.

Например, здесь мы используем `window` как глобальный объект: #глобальный-объект
~~~
function sayHi() {  
	alert("Hello"); }  // глобальные функции доступны как методы глобального объекта: window.sayHi();`
~~~

А здесь мы используем `window` как объект окна браузера, чтобы узнать его высоту:
~~~
alert(window.innerHeight); // внутренняя высота окна браузера`
~~~

###### DOM

#DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. 

Объект #document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.

Например:
~~~
// заменим цвет фона на красный, 
document.body.style.background = "red";  // а через секунду вернём как было 
setTimeout(() => document.body.style.background = "", 1000);`
~~~

Мы использовали в примере только `document.body.style`, но на самом деле возможности по управлению страницей намного шире. 

###### BOM

Объектная модель браузера (Browser Object Model, #BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

Например:
-   Объект [navigator](https://developer.mozilla.org/ru/docs/Web/API/Window/navigator) даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: `navigator.userAgent` – информация о текущем браузере, и `navigator.platform` – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
-   Объект [location](https://developer.mozilla.org/ru/docs/Web/API/Window/location) позволяет получить текущий URL и перенаправить браузер по новому адресу.

Вот как мы можем использовать объект `location`:
~~~
alert(location.href); // показывает текущий URL 
if (confirm("Перейти на Wikipedia?")) {   
	location.href = "https://wikipedia.org"; // перенаправляет браузер на другой URL }`
~~~
Функции `alert/confirm/prompt` тоже являются частью BOM: они не относятся непосредственно к странице, но представляют собой методы объекта окна браузера для коммуникации с пользователем.

#### 3. Что возвращает #fetch? Как получить содержимое ответа? Как обрабатывать ошибки?  
Подробнее: [[1.4 FETCH]]

Метод #fetch() позволяет нам делать запросы, схожие с #XMLHttpRequest ( #XHR). 
Основное отличие заключается в том, что Fetch API использует [Promises (Обещания)](http://habrahabr.ru/post/209662/), 

	которые позволяют использовать более простое и чистое #API, избегать катастрофического количества callback'ов и необходимости помнить API для XMLHttpRequest.
	
Он не поддерживается старыми (можно использовать полифил), но поддерживается всеми современными браузерами.

Базовый синтаксис:
~~~
`let promise = fetch(url, [options])`
~~~
-   **`url`** – URL для отправки запроса.
-   **`options`** – дополнительные параметры: метод, заголовки и так далее
Без `options` это простой #GET -запрос, скачивающий содержимое по адресу `url`.

Процесс получения ответа обычно происходит в два этапа.

1.  #promise выполняется с объектом встроенного класса [Response](https://fetch.spec.whatwg.org/#response-class) в качестве результата, как только сервер пришлёт заголовки ответа.**

	На этом этапе мы можем проверить статус #HTTP-запрос и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа.
	Промис завершается с ошибкой, если `fetch` не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой.
	Мы можем увидеть #HTTP-статус в свойствах ответа:
		-   **`status`** – код статуса HTTP-запроса, например 200.
		-   **`ok`** – логическое значение: будет `true`, если код HTTP-статуса в диапазоне 200-299.

Например:
~~~
let response = await fetch(url);  

if (response.ok) { 
// если HTTP-статус в диапазоне 200-299   
// получаем тело ответа (см. про этот метод ниже)   
	let json = await response.json(); 
} else {   
	alert("Ошибка HTTP: " + response.status); 
}`
~~~

2.  Для получения тела ответа нам нужно использовать дополнительный вызов метода

	#response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:
		-   **`response.text()`** – читает ответ и возвращает как обычный текст,
		-   **`response.json()`** – декодирует ответ в формате JSON,
		-   **`response.formData()`** – возвращает ответ как объект `FormData` (разберём его в [следующей главе](https://learn.javascript.ru/formdata)),
		-   **`response.blob()`** – возвращает объект как [Blob](https://learn.javascript.ru/blob) (бинарные данные с типом),
		-   **`response.arrayBuffer()`** – возвращает ответ как [ArrayBuffer](https://learn.javascript.ru/arraybuffer-binary-arrays) (низкоуровневое представление бинарных данных),
		-   помимо этого, `response.body` – это объект [ReadableStream](https://streams.spec.whatwg.org/#rs-class), с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.

Типичный запрос с помощью `fetch` состоит из двух операторов `await`:
~~~
let response = await fetch(url, options); // завершается с заголовками ответа 
let result = await response.json(); // читать тело ответа в формате JSON`
~~~
Или, без `await`:
~~~
fetch(url, options)   
	.then(response => response.json())   
	.then(result => /* обрабатываем результат */)`
~~~

#### 4. Хранения данных на клиенте в #LocalStorage / #SessionStorage / #Cookie? Особенности работы?  
Подробнее: [[6 LocalStorage, sessionStorage]]

Объекты веб-хранилища #localStorage и #sessionStorage позволяют хранить пары ключ/значение в браузере.

 #sessionStorage   данные, которые в них записаны, сохраняются после обновления страницы
 #localStorage данные, которые в них записаны, сохраняются даже после перезапуска браузера

Объекты хранилища `localStorage` и `sessionStorage` предоставляют одинаковые методы и свойства:
-   `setItem(key, value)` – сохранить пару ключ/значение.
-   `getItem(key)` – получить данные по ключу `key`.
-   `removeItem(key)` – удалить данные с ключом `key`.
-   `clear()` – удалить всё.
-   `key(index)` – получить ключ на заданной позиции.
-   `length` – количество элементов в хранилище.

Ключ и значение должны быть строками. В противном случае они все равно преобразуются в строки.

Используя #localStorage можно решать следующие прикладные задачи:
	1. получать / записывать данные в обычный обьект
	2. перебирать ключи . используя #цикл

#localStorage в синтаксисе идентичен #localStorage , но есть небольшие отличия 
	#sessionStorage существует только в рамках текущей вкладки браузера.
	    -   Другая вкладка с той же страницей будет иметь другое хранилище.
	    -   Но оно разделяется между ифреймами на той же вкладке (при условии, что они из одного и того же источника).
	-   Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.

Событие storage:
-   Срабатывает при вызове `setItem`, `removeItem`, `clear`.
-   Содержит все данные об произошедшем обновлении (`key/oldValue/newValue`), `url` документа и объект хранилища `storageArea`.
-   Срабатывает на всех объектах `window`, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для `sessionStorage`, глобально для `localStorage`).

Отличие от #Cookie :
-   В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Именно поэтому мы можем хранить гораздо больше данных. Большинство современных браузеров могут выделить как минимум 5 мегабайтов данных (или больше), и этот размер можно поменять в настройках.
-   Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
-   Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.

#### 5. Что такое #DNS?  
Подробнее: [[2 Что такое DNS]]

![Что такое DNS-сервер простыми словами](https://guides.hexlet.io/assets/images/dns/structure.jpg)

#DNS (Domain Name System / Система доменных имён), которая была призвана автоматизировать процессы соотнесения IP-адресов и имён компьютеров, а также процессы обновления имён у пользователей без необходимости ручного скачивания файла со стороннего сервера.
 
#DNS имеет множество узлов, каждый из которых ответственен за свою зону. Структура DNS является иерархической, то есть выделяет зоны ответственности, где каждый родитель знает о расположении своего дочернего сервера, и знает зону его ответственности.

![dns, hierarchy](https://guides.hexlet.io/assets/images/dns/hierarchy.jpg)

Основными компонентами DNS являются:
	#domain (доменное имя) — символьное имя для обозначения сервера в сети интернет. Доменные имена являются иерархической структурой, в которой каждый уровень отделяется точкой. Основными уровнями являются:
		Корневой домен, Домены верхнего уровня, Домен второго уровня, Поддомены
	#DNS-сервер — система, ответственная за хранение и поддержание в актуальном состоянии записей о своих дочерних доменах.
	**Ресурсная запись** — единица информации DNS-сервера. Каждая ресурсная запись имеет несколько полей:
		Имя, тип, параметры, значение

Рассмотрим процесс получения IP-адреса по доменному имени на примере домена `ru.hexlet.io`.

Возможны два варианта событий:

1.  Компьютер посылает запрос на известный ему DNS-сервер. Чаще всего им является DNS-сервер поставщика интернет-услуг (провайдера): _какой IP-адрес у домена ru.hexlet.io?_. DNS-сервер провайдера находит в своей базе информацию о том, что домен `ru.hexlet.io` расположен по IP-адресу 104.25.238.104 и возвращает значение нашему компьютеру. Этот процесс похож на то, как использовался файл `hosts.txt`.
2.  Ближайший известный DNS-сервер не имеет записи о том, по какому IP-адресу располагается домен `ru.hexlet.io`. В таком случае запускается цепочка процессов, благодаря которым наш компьютер получит IP-адрес домена:
    -   Так как домен является иерархической структурой, и все DNS-сервера знают IP-адреса корневых DNS-серверов, то к ним и происходит запрос на получение IP-адреса домена.
    -   Корневые DNS-сервера, в соответствии со своей зоной ответственности знают о том, где располагаются DNS-сервера доменов верхнего уровня. Эти адреса возвращаются DNS-серверу нашего провайдера, после чего на нужный DNS-сервер (в нашем случае на DNS-сервер домена .io) посылается запрос на получение IP-адреса домена ru.hexlet.
    -   В соответствии со своей зоной ответственности DNS-сервер домена верхнего уровня возвращает IP-адрес DNS-сервера домена hexlet, на который посылается запрос на получение IP-адреса поддомена ru.
    -   DNS-сервер возвращает IP-адреса поддомена ru, после чего DNS-сервер нашего провайдера возвращает полученный адрес на наш компьютер, который уже может обратиться к домену ru.hexlet.io по его IP-адресу.

В первом случае мы просто послали запрос и получили ответ, а во втором — возникла необходимость идти от самого корневого домена в процессе поиска нужной нам записи. Такой процесс является рекурсивным.

Основными ресурсными записями DNS являются:
	#A-запись — одна из самых важных записей. Именно эта запись указывает на IP-адрес сервера, который привязан к доменному имени.
	#MX-запись — указывает на сервер, который будет использован при отсылке доменной электронной почты.
	#NS-запись — указывает на DNS-сервер домена.
	#CNAME-запись — позволяет одному из поддоменов дублировать DNS-записи своего родителя. Делается это для того, чтобы перенаправить запрос с одного домена на другой (чаще всего для перенаправления домена с поддоменом www на домен без такого поддомена).
	#TXT-запись — в этой записи хранится текстовая информация о домене. Часто используется для подтверждения прав на владение доменом, посредством добавления определённой строки, которую присылает нам интернет-сервис.

В основном ресурсные записи имеют следующую структуру:

```
Имя записи   TTL   Класс   Тип записи  Значение
```

###### hosts.txt

Для решения задачи разработчики решили использовать словарь, который связывал уникальное имя и IP-адрес каждого компьютера в сети. Таким словарём стал файл #hosts.txt, который и отвечал за привязку IP-адреса к имени компьютера.

Выглядел hosts.txt тогда (да и сейчас) таким образом:

```
192.168.10.36         MIKE-STRATE-PC
Сетевой (IP) адрес    Имя компьютера
```


#### 6. Структура #HTTP запроса и ответа? Основные метаданные от сервера и браузера 
Подробнее: [[3.1 HTTP простым языком]] , [[3.2 Обзор протокола HTTP]]

#HTTP — это [протокол](https://developer.mozilla.org/ru/docs/Glossary/Protocol), позволяющий получать различные ресурсы, например HTML -документы. 

Протокол HTTP предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. После этого клиентское приложение может продолжить отправлять другие запросы, которые будут обработаны аналогичным образом.  

Сообщения, отправленные клиентом, обычно веб-браузером, называются #HTTP-запрос , а сообщения, отправленные сервером, называются #HTTP-ответ.

![HTTP as an application layer protocol, on top of TCP (transport layer) and IP (network layer) and below the presentation layer.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http-layers.png)

Как правило, передача данных по протоколу HTTP осуществляется через #TCP/IP -соединения. 

###### HTTP-запрос

Чтобы сформировать #HTTP-запрос, необходимо составить стартовую строку, а также задать по крайней мере один заголовок — это заголовок #Host, который является обязательным, и должен присутствовать в каждом запросе

#IP-адрес необходимо передать в заголовке Host тк преобразование доменного имени в IP-адрес осуществляется на стороне клиента

Стартовая (начальная) строка запроса для HTTP 1.1 составляется по следующей схеме:  
[Метод](https://habr.com/ru/post/215117/#method) [URI](https://habr.com/ru/post/215117/#uri) HTTP/[Версия](https://habr.com/ru/post/215117/#requestversion)  

Например (такая стартовая строка может указывать на то, что запрашивается главная страница сайта):  
`GET / HTTP/1.1`  
#метод #URI 

![A basic HTTP request](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png)
Запросы содержат следующие элементы:

-   HTTP-[метод](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods), обычно глагол подобно [`GET`](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/GET), [`POST`](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/POST) или существительное, как [`OPTIONS`](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/OPTIONS) или [`HEAD`](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/HEAD), определяющее операцию, которую клиент хочет выполнить. Обычно, клиент хочет получить ресурс (используя `GET`) или передать значения [HTML-формы](https://developer.mozilla.org/ru/docs/Learn/Forms) (используя `POST`), хотя другие операции могут быть необходимы в других случаях.
-   Путь к ресурсу: URL ресурсы лишены элементов, которые очевидны из контекста, например без [протокола](https://developer.mozilla.org/ru/docs/Glossary/Protocol) (`http://`), [домена](https://developer.mozilla.org/ru/docs/Glossary/Domain) (здесь `developer.mozilla.org`), или TCP [порта](https://developer.mozilla.org/ru/docs/Glossary/Port) (здесь `80`).
-   Версию HTTP-протокола.
-   [Заголовки](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers) (опционально), предоставляющие дополнительную информацию для сервера.
-   Или тело, для некоторых методов, таких как `POST`, которое содержит отправленный ресурс.

Для того, чтобы обратиться к веб-странице по определённому адресу (в данном случае путь к ресурсу — это «/»), нам следует отправить следующий запрос:  
  
`GET / HTTP/1.1`  
`Host: alizar.habrahabr.ru`  

###### HTTP-ответ

Стартовая строка ответа имеет следующую структуру:  
HTTP/[Версия](https://habr.com/ru/post/215117/#responseversion) [Код состояния](https://habr.com/ru/post/215117/#statuscode) [Пояснение](https://habr.com/ru/post/215117/#reasonphrase)  
  
**Версия** протокола здесь задаётся так же, как в запросе.  

![](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_response.png)
Ответы содержат следующие элементы:

-   Версию HTTP-протокола.
-   [HTTP код состояния](https://developer.mozilla.org/ru/docs/Web/HTTP/Status), сообщающий об успешности запроса или причине неудачи.
-   Сообщение состояния — краткое описание кода состояния.
-   HTTP [заголовки](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers), подобно заголовкам в запросах.
-   Опционально: тело, содержащее пересылаемый ресурс.

После стартовой строки следуют заголовки, а также тело ответа. Например:  
  
```
HTTP/1.1 200 OK
Server: nginx/1.2.1
Date: Sat, 08 Mar 2014 22:53:46 GMT
Content-Type: application/octet-stream
Content-Length: 7
Last-Modified: Sat, 08 Mar 2014 22:53:30 GMT
Connection: keep-alive
Accept-Ranges: bytes

Wisdom
```

`GET /users/alizar/ HTTP/1.1`  
`Host: habrahabr.ru`  

###### Для чего нужны заголовки?  
Подробнее: [Заголовки HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers)

**Заголовки HTTP** позволяют клиенту и серверу отправлять дополнительную информацию с HTTP запросом или ответом. 

HTTP-заголовки сопровождают обмен данными по протоколу HTTP. 
Они могут содержать описание данных и информацию, необходимую для взаимодействия между клиентом и сервером.

###### Что может быть в теле запроса?  

1. Тело запроса
![A basic HTTP request](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png)
2. Тело ответа
![A basic HTTP request](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png)
###### Основные методы запроса? GET / POST / PUT / DELETE  
Подробнее: [Методы HTTP-запросов](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods)

#HTTP определяет множество **методов запроса**, которые указывают, какое желаемое действие выполнится для данного ресурса.

1. Метод #GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
2. #POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
3. #PUT заменяет все текущие представления ресурса данными запроса.
4. #DELETE удаляет указанный ресурс.

###### Какие группы кодов ответов есть? Что означает коды ответов (200, 201, 204, 301, 302, 40х, 500)?  
Подробнее: [Коды ответа HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Status)

Код ответа (состояния) #HTTP показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:
1.  Информационные 100 - 199
2.  Успешные 200 - 299
3.  Перенаправления 300 - 399
4.  Клиентские ошибки 400 - 499
5.  Серверные ошибки 500 - 599

200 OK "Успешно". Запрос успешно обработан.
201 Created  "Создано". Запрос успешно выполнен и в результате был создан ресурс.
204 No Content  "Нет содержимого". Нет содержимого для ответа на запрос, но заголовки ответа, которые могут быть полезны, присылаются.
301 Moved Permanently  "Перемещён на постоянной основе". Этот код ответа значит, что URI запрашиваемого ресурса был изменён. Возможно, новый URI будет предоставлен в ответе.
302 Found  "Найдено". Этот код ответа значит, что запрошенный ресурс _временно изменён_. Новые изменения в URI могут быть доступны в будущем. Таким образом, этот URI, должен быть использован клиентом в будущих запросах.
40x Клиентские
500 Серверные || Internal Server Error  "Внутренняя ошибка сервера". Сервер столкнулся с ситуацией, которую он не знает как обработать.






#### 7. Что такое куки? Для чего используются? Какие типы куки бывают? Как реализуются сессии на куках?  
Подробнее: [[7 Cookie]]

#Cookie – это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью #HTTP-протокол.

Куки обычно устанавливаются веб-сервером при помощи заголовка #Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка `Cookie`.

-   **`path=/mypath`**
#URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным. По умолчанию используется текущий путь.

#domain определяет, где доступен файл куки. Он позволяет нам разрешить доступ к куки для поддоменов.

По умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера. Такие куки называются сессионными (« #sessionCookies »).

`document.cookie` предоставляет доступ к куки.
-   Операция записи изменяет только то куки, которое было указано.
-   Имя и значение куки должны быть закодированы.
-   Одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).

Настройки куки:
-   `path=/`, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
-   `domain=site.com`, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
-   `expires` или `max-age` устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.
-   `secure` делает куки доступным только при использовании HTTPS.
-   `samesite` запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.

Дополнительно:
-   Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.
-   Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR.

#### 8. Как происходит #авторизация?  Что передаётся в заголовке авторизации?  

Если в системе включена #авторизация, то для начала работы с #API необходимо пройти авторизацию в системе.

Реализованы несколько вариантов авторизации:
-   BASIC авторизация.
-   Авторизация методом #GET по адресу /api/session с получением #token.
-   Авторизация методом #POST по адресу /api/session с получением #token.

-   #BASIC-авторизация — в этом случае при каждом #HTTP-запрос нужно будет отправлять логин и пароль;
-   авторизация с использованием токена — при первом HTTP-запросе передаются логин и пароль, а сервер MS возвращается токен — уникальный идентификатор сессии (access token), который при последующих HTTP-запросах можно будет использовать вместо передачи логина и пароля. Срок действия токена (т.е. сессии) ограничен, поэтому для обновления токена при первом запросе сервер Mobile SMARTS дополнительно возвращает «токен обновления» (refresh token) — он нужен для получения нового токена после истечения срока действия текущего токена.

###### [User and Authentication](https://api.realworld.io/api-docs/#/User%20and%20Authentication)

###### BASIC авторизация

Данный вид авторизации чаще всего используется браузером для доступа к функциям API.
При использовании данного метода необходимо в заголовке каждого запроса указывать:
~~~
Authorization: Basic {login}:{password}
~~~

Допускается base64 при формировании строки {login}:{password}

###### Авторизация методом GET

Еще один способ авторизации — отправить GET запрос по адресу /api/v1/session, при этом в url запросе указать параметры login и password:

[https://localhost:9000/api/v1/session?username=${Username}&password=${Password}](https://localhost:9000/api/v1/session?username=$%7BUsername%7D&password=$%7BPassword%7D)

**Ответ сервера:**
~~~
{  
Access_token:"123123123",
Token_type:"bearer",
Expires_in:86400,
Refresh_token:"321321321",  
}
~~~

###### Авторизация методом POST

Авторизация по логину и паролю происходит путем отправки POST запроса на сервер, в результате которого возвращается access_token и refresh token в формате JSON.

**Пример запроса:**

POST /oauth/token HTTP/1.1  
Host: mobilesmarts.ru/api/session  
Content-Type: application/x-www-form-urlencoded

grant_type=password&client_id=123&client_secret=user&username=[user@domain.ru](mailto:user@domain.ru)&password=123456  

**Ответ сервера:**
~~~
{  
Access_token:"123123123",  
Token_type:"bearer",
Expires_in:86400,
Refresh_token:"321321321",
}
~~~

###### Вызов функций с использованием token

Для того чтобы обратиться к функциям (если не используется Basic авторизация), для которых необходима авторизация, необходимо в заголовке Authorization передавать токен:
~~~
Authorization: Bearer <token>
~~~

Иначе сервер вернет ошибку авторизации 401.

#### 9. Структура #URL - path; query string; fragment?  
Подробнее: [URI — сложно о простом (Часть 1)](https://habr.com/ru/post/232385/)

#URI — последовательность символов, идентифицирующая физический или абстрактный ресурс, который не обязательно должен быть доступен через сеть Интернет, причем, тип ресурса, к которому будет получен доступ, определяется контекстом и/или механизмом._

В современном интернете, чаще всего используется две разновидности `URI` — `URL` и `URN`.  
Основное различие между ними — в задачах: 
-   #URL— _Uniform Resource Locator_, помогает найти какой либо ресурс
-   #URN— _Uniform Resource Name_, помогает этот ресурс идентифицировать

URI составлен из ограниченного набора символов, состоящих из цифр, букв и нескольких графических символов, все эти символы вписываются в кодировку #US-ASCII ( #ASCII).
  
Упрощая: 
`URL` — отвечает на вопрос: «Где и как найти что-то?», 
`URN` — отвечает на вопрос: «Как это что-то идентифицировать».

###### Компоненты URI
-   **Path (Путь)**  
    Компонента пути содержит данные, обычно, организованные в иерархической форме, которые, вместе с данными в неиерархическом компоненте запроса (Query), служит, чтобы идентифицировать ресурс в рамках схемы URI и authority (если таковая компонента указана).  
    Путь начинается со слеша(/) и заканчивается знаком вопроса(?), октоторпом(#) или концом URI  
    Разрешенные символы для пути:  
    
    > ```
    > Не зарезервированные, процентно-кодированные, sub-delims, ":", "@"
    > ```
-   **Query (Запрос)**  
    Компонента запроса содержит данные, организованные в неиерархической форме, которые, вместе с данными в иерархическом компоненте пути (Path), служит, чтобы идентифицировать ресурс в рамках схемы URI и authority (если таковая компонента указана).  
    Запрос начинается с первого знака вопроса(?) и заканчивается октоторпом(#) или концом URI  
    Разрешенные символы для запроса:  
    
    > ```
    > Не зарезервированные, процентно-кодированные, sub-delims, ":", "@", "/", "?"
    > ```
    
    В запросе чаще всего передаются данные в формате key=value (ключ=значение), значение рекомендуется передавать в процентно-кодированном виде, обусловлено это тем, что в значении может встретиться символ "&", который используется для разделения пар ключ-значение, в результате появления такого артефакта дальнейшая последовательность пар ключ-значение может быть нарушена.
-   **Fragment (Фрагмент)**  
    Компонента фрагмент позволяет осуществить косвенную идентификацию вторичного ресурса по отношению к первому.  
    Семантика фрагмента никак не ограничена, фрагмент начинается октоторпом(#) и заканчивается концом URI, при этом может состоять из абсолютно любого набора символов.  
    Примером применения фрагментов является оглавление данной статьи. Оно состоит из относительных ссылок  
    
    ```
    <a href="#someanchor"></a>
    ```
    
    а по статье, в определенных местах, раскиданы т.н. «якоря» — теги
    
    ```
    <anchor>someanchor</anchor>
    ```
    Переходя по указанной в оглавлении ссылке, браузер производит переход ко вторичному ресурсу относительно данной страницы, т.е. скроллит вниз, до появления нужного
    
    ```
    <anchor>
    ```
    
    на экране.
-   **Scheme (схема)**  
    Каждый URI начинается с имени схемы, которое относится к спецификации для присвоения идентификаторов в этой схеме. Также, синтаксис URI — объединенная и расширяемая система именования, причем, спецификация каждой схемы может далее ограничить синтаксис и семантику идентификаторов, использующих эту схему.  
    Название схемы обязательно начинается с буквы и далее может быть продолжено любым количеством разрешенных символов.  
    Разрешенные символы для схемы:  
    
    > ```
    > ALPHA, DIGIT, "+", "-", "."
    > ```
-   **Scheme (схема)**  
    Каждый URI начинается с имени схемы, которое относится к спецификации для присвоения идентификаторов в этой схеме. Также, синтаксис URI — объединенная и расширяемая система именования, причем, спецификация каждой схемы может далее ограничить синтаксис и семантику идентификаторов, использующих эту схему.  
    Название схемы обязательно начинается с буквы и далее может быть продолжено любым количеством разрешенных символов.  
    Разрешенные символы для схемы:  
    
    > ```
    > ALPHA, DIGIT, "+", "-", "."
    > ```


#### 10. #REST #API: что такое ресурс, ограничения, идемпотентность, кэширование?  
Подробнее: [[5.4 REST простыми словами]]

#REST (Representational state transfer) — общие принципы организации взаимодействия приложения/сайта с сервером по #HTTP. #сервер не запоминает состояние пользователя между запросами. В запросах передаётся информация, идентифицирующая пользователя (например #токен ) и параметры для выполнения операции.

Rest позволяет:
-   Масштабируемости взаимодействия компонентов системы (приложения)
-   Общность интерфейсов
-   Независимое внедрение компонентов
-   Промежуточные компоненты, снижающие задержку, усиливающие безопасность

Применяется, когда: 
• Когда есть ограничение пропускной способности соединения
• Если необходимо кэшировать запросы
• Если система предполагает значительное масштабирование
• В сервисах, использующих #AJAX

Чтобы распределенная система считалась сконструированной по REST архитектуре ( #Restful ), необходимо, чтобы она удовлетворяла следующим критериям:

1.  **Client-Server.** Система должна быть разделена на клиентов и на серверов. Разделение интерфейсов означает, что, например, клиенты не связаны с хранением данных, которое остается внутри каждого сервера, так что мобильность кода клиента улучшается. Серверы не связаны с интерфейсом пользователя или состоянием, так что серверы могут быть проще и масштабируемы. Серверы и клиенты могут быть заменяемы и разрабатываться независимо, пока интерфейс не изменяется.
2.  **Stateless.** Сервер не должен хранить какой-либо информации о клиентах. В запросе должна храниться вся необходимая информация для обработки запроса и если необходимо, идентификации клиента.
3.  **Cache․** Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.
4.  **Uniform Interface.** Единый интерфейс определяет интерфейс между клиентами и серверами. Это упрощает и отделяет архитектуру, которая позволяет каждой части развиваться самостоятельно.

**Важно !** Сама архитектура REST не привязана к конкретным технологиям и протоколам, но в реалиях современного Веб, построение #RESTful #API почти всегда подразумевает использование #HTTP и каких-либо распространенных форматов представления ресурсов, например #JSON, или, менее популярного сегодня, #XML.

###### Ресурс

#ресурс — это ключевая абстракция, на которой концентрируется протокол #HTTP. Ресурс — это все, что вы хотите показать внешнему миру через ваше приложение. Например, если мы пишем приложение для управления задачами, экземпляры ресурсов будут следующие:  
-   Конкретный пользователь
-   Конкретная задача
-   Список задач

**URI ресурса**

Когда вы разрабатываете #RESTful сервисы, вы должны сосредоточить свое внимание на ресурсах приложения. Способ, которым мы идентифицируем ресурс для предоставления, состоит в том, чтобы назначить ему #URI — универсальный идентификатор ресурса. Например:  

-   Создать пользователя: #POST /users
-   Удалить пользователя: #DELETE /users/1
-   Получить всех пользователей: #GET /users
-   Получить одного пользователя: #GET /users/1

**REST и Ресурсы**

Важно отметить, что с REST вам нужно думать о приложении с точки зрения ресурсов:  
Определите, какие ресурсы вы хотите открыть для внешнего мира  
Используйте глаголы, уже определенные протоколом HTTP, для выполнения операций с этими ресурсами.  
  
Вот как обычно реализуется служба REST:  
-   **Формат обмена данными**: здесь нет никаких ограничений. JSON — очень популярный формат, хотя можно использовать и другие, такие как XML
-   **Транспорт**: всегда HTTP. REST полностью построен на основе HTTP.
-   **Определение сервиса**: не существует стандарта для этого, а REST является гибким. Это может быть недостатком в некоторых сценариях, поскольку потребляющему приложению может быть необходимо понимать форматы запросов и ответов. Однако широко используются такие языки определения веб-приложений, как WADL (Web Application Definition Language) и Swagger.

REST фокусируется на ресурсах и на том, насколько эффективно вы выполняете операции с ними, используя HTTP.

###### Ограничения

REST определяет 6 ограничений для достижения желаемой оптимизации системы
1. Клиент-сервер
Это ограничение основано на принципе разделения интересов.
Это позволяет компонентам развиваться независимо. Создавая наш API, он действует как сервер, обслуживающий большое количество клиентов.

2. Без гражданства
Связь между клиентом и сервером должна быть без гражданства. Это означает, что каждый запрос от клиента к серверу должен содержать всю необходимую информацию для завершения транзакции.

Основным преимуществом этого ограничения является то, что система способна масштабироваться лучше, потому что серверу не нужно сохранять состояние клиента между запросами. Отсутствие необходимости запоминать информацию о состоянии клиента освобождает ресурсы сервера, поэтому он может обслуживать больше клиентов одновременно.

3. Кэш
Наиболее эффективным сетевым запросом является тот, который не использует сеть.
Когда мы создаем наш API, он не должен игнорировать кеширование.

4. Правильный интерфейс
Чтобы иметь эффективное кэширование в сети, компоненты должны иметь возможность взаимодействовать через единый интерфейс. С единым интерфейсом полезная нагрузка может передаваться в стандартной форме.
	4.1. Идентификация ресурсов
		Это означает, что любая информация, которая может быть названа, может быть ресурсом (изображение, документ или даже набор других ресурсов)
	4.2. Манипулирование ресурсами через представления
		Ресурс может быть представлен различными способами.
		Например, HTML, XML, JSON или даже JPEG-файл.
		Это правило означает, что клиенты взаимодействуют с ресурсами через свои представления, что является мощным средством удержания абстрактных понятий ресурсов от их взаимодействий.
	4.3 В-третьих, самоописательные сообщения
		Это означает, что ресурс может быть описан в сообщении запроса, а сервер может отвечать описательными сообщениями о состоянии. Да, HTTP-заголовки и коды ответов являются хорошими реализациями для этого правила.
	4.4. Hypermedia должна быть двигателем состояния приложения
		Это на самом деле означает, что приложение должно управляться ссылками, позволяя клиентам обнаруживать ресурсы через гиперссылки.
		Как вы можете видеть, многие из этих правил могут быть реализованы в протоколе HTTP. Поэтому, когда API использует HTTP правильно, это огромный шаг к тому, чтобы стать RESTful.

5. Многоуровневая система
В многоуровневой системе посредники, такие как прокси-серверы, могут размещаться между клиентом и сервером, используя единообразный интерфейс сети.

Одним из преимуществ многоуровневой системы является то, что посредники могут затем перехватывать трафик клиент-сервер для определенных целей/ Например, для кэширования.

6. Код по требованию
Это необязательное ограничение и позволяет клиентам загружать программы для выполнения на стороне клиента. Лучший пример для этого - интерфейсные JavaScript-приложения. Это может показаться нам сейчас очень очевидным, но в раннем возрасте Интернета это была эволюционирующая концепция, и это полезная часть интернет-архитектуры.

###### Идемпотентность

С точки зрения RESTful-сервиса, операция (или вызов сервиса) идемпотентна тогда, когда клиенты могут делать один и тот же вызов неоднократно при одном и том же результате на сервере. Другими словами, создание большого количества идентичных запросов имеет такой же эффект, как и один запрос. Заметьте, что в то время, как идемпотентные операции производят один и тот же результат на сервере, ответ сам по себе может не быть тем же самым (например, состояние ресурса может измениться между запросами).

Методы **PUT** и **DELETE** по определению идемпотентны. Тем не менее, есть один нюанс с методом DELETE. Проблема в том, что успешный DELETE-запрос возвращает статус 200 (OK) или 204 (No Content), но для последующих запросов будет все время возвращать 404 (Not Found), Состояние на сервере после каждого вызова DELETE то же самое, но ответы разные.

Методы **GET**, **HEAD**, **OPTIONS** и **TRACE** определены как безопасные. Это означает, что они предназначены только для получения информации и не должны изменять состояние сервера. Они не должны иметь побочных эффектов, за исключением безобидных эффектов, таких как: логирование, кеширование, показ баннерной рекламы или увеличение веб-счетчика.

По определению, **безопасные операции идемпотентны**, так как они приводят к одному и тому же результату на сервере. Безопасные методы реализованы как операции только для чтения. Однако безопасность не означает, что сервер должен возвращать тот же самый результат каждый раз.

###### Кэширование

-   _Self-descriptive messages (само-документируемые сообщения)_. Под само-описательностью имеется ввиду, что запрос и ответ должны хранить в себе всю необходимую информацию для их обработки. Не должны быть дополнительные сообщения или кэши для обработки одного запроса. Другими словами отсутствие состояния, сохраняемого между запросами к ресурсам. Это очень важно для масштабирования системы.
- **Cache․** Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.

#### 11. Что происходит, когда пользователь вводит адрес сайта в адресную строку?
Подробнее: [[229 Что на самом деле происходит, когда пользователь вбивает в браузер адрес google.com]]

##### 1. "g" + enter

1.  При нажатии на клавишу "g" в поиске #браузер будет выполняться большоее количество кода,  рекомендации будут обновляться с каждой новой напечатанной буквой. Выполнится #автоподстановка .
2.  Нажатие клавиши "enter" до конца. 
	* В режиме #ядро происходит преобразование и обработка ввода с клавиатуры.
	* Происходит обработка адресной строки браузера.
	* #API #Windows вызывает #обработчик-событий окна и сообщения.
	* Обработчик окна ( #hWnd) взаимодействует с обработчиком сообщения ( #WM_KEYDOWN) , после чего с ними взаимодействует следующий обработчик #VK_RETURN , который поступил в #sendMessage. ОС понимает, что пользователь нажал клавишу Enter.
3. Сигнал прерывания активирует событие прерывания в драйвере I/O Kit клавиатуры. Сигнал преобразуется в код клавиатуры, а затем передаётся в #WindowServer => событие помещается в очередь. Затем события могут быть прочитаны из этой очереди потоками с достаточными привилегиями, чтобы вызывать функцию `mach_ipc_dispatch`. Чаще всего это происходит и обрабатывается с помощью основного цикла `NSApplication` через `NSEvent` в `NSEventype KeyDown`.  
4. Для получения нажатия клавиши будет использован общий драйвер событий #evdev . Графический #API окна, получившего символ, печатает соответствующий символ шрифта в нужном поле.  

##### 2. Парсинг URL

#браузер имеет информации об #URL : #HTTP и  #resource.

1. Если пользователь не вводит #domain имя , то #браузер осуществляет поисковой запрос.
2. Браузер проверяет список «предзагруженных #HSTS (HTTP Strict Transport Security)». Это список сайтов, которые требуют, чтобы к ним обращались только по #HTTPS.
3. Если нужный сайт есть в этом списке, то браузер отправляет ему запрос через #HTTPS вместо #HTTP. В противном случае, начальный запрос посылается по HTTP. 
4. Проверка браузером имени #hosts 

##### 3. Определение DNS

1. #Браузер проверяет наличие #domain в своём #кэш.
	* Если  домен нет: браузер вызывает библиотечную функцию #gethostbyname для поиска нужного адреса.
	* Если домен не закэширован и отсутствует в файле #hosts :  `gethostbyname` отправляет запрос к сетевому #DNS-сервер
		* #domain в той же подсети: [ARP-запрос](https://ru.wikipedia.org/wiki/ARP) отправляется этому серверу.
		* #domain в другой подсети: #ARP-запрос отправляется на #IP-адрес шлюза по умолчанию.

Для того, чтобы отправить широковещательный #ARP-запрос необходимо отыскать целевой #IP-адрес, а также знать #MAC-адрес интерфейса, который будет использоваться для отправки ARP-запроса.  

ARP-запрос:  
`Sender MAC: interface:mac:address:here`  
`Sender IP: interface.ip.goes.here`  
`Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)`  
`Target IP: target.ip.goes.here`  

ARP-ответ:  
`Sender MAC: target:mac:address:here`  
`Sender IP: target.ip.goes.here`  
`Target MAC: interface:mac:address:here`  
`Target IP: interface.ip.goes.here`  

##### 4. Открытие сокета

Когда браузер получает #IP-адрес конечного сервера, то он берёт эту информацию и данные об используемом порте из #URL (80 порт для #HTTP, 443 для #HTTPS) и осуществляет вызов функции #socket системной библиотеки и запрашивает поток #TCP сокета — `AF_INET` и `SOCK_STREAM`.  

#TCP-сегмент >> Cетевой уровень ( + IP-заголовок , + IP-адрес ) >> Сформирован #пакет 

Пакет передаётся на канальный уровень >> добавляется заголовок кадра, который включает MAC-адрес сетевой карты (NIC) компьютера, а также MAC-адрес шлюза (локального роутера) >> передача через:
  
-   [Ethernet](http://en.wikipedia.org/wiki/IEEE_802.3)
-   [WiFi](https://en.wikipedia.org/wiki/IEEE_802.11)
-   [По сотовой связи](https://en.wikipedia.org/wiki/Cellular_data_communication_protocol)

###### Жизненный цикл TCP-соединения

**a. Клиент выбирает номер начальной последовательности ( #ISN) и отправляет пакет серверу с установленным битом #SYN для открытия соединения.**  
  
**b. Сервер получает пакет с битом SYN и, если готов к установлению соединения, то:**  
  
-   Выбирает собственный номер начальной последовательности;
-   Устанавливает SYN-бит, чтобы сообщить о выборе начальной последовательности;
-   Копирует ISN клиента +1 в поле ACK и добавляет ACK-флаг для обозначения подтверждения получения первого пакета.
 
**c. #клиент подтверждает соединение путём отправки пакета:**  
  
-   Увеличивает номер своей начальной последовательности;
-   Увеличивает номер подтверждения получения;
-   Устанавливает поле ACK.

**d. Данные передаются следующим образом:**  
  
-   Когда одна сторона отправляет N байтов, то увеличивает значение поля SEQ на это число.
-   Когда вторая сторона подтверждает получение этого пакета (или цепочки пакетов), она отправляет пакет ACK, в котором значение поля ACK равняется последней полученной последовательности.

**e. Закрытие соединения:**  
  
-   Сторона, которая хочет закрыть соединение, отправляет пакет FIN;
-   Другая сторона подтверждает FIN (с помощью ACK) и отправляет собственный FIN-пакет;
-   Инициатор прекращения соединения подтверждает получение FIN отправкой собственного ACK.

##### 5. TLS handshake

1. #клиент  сообщения  серверу #ClientHello версией протокола #TLC
2. #сервер отвечает клиенту сообщением #ServerHello  версией протокола #TLC 
3.  Клиент подтверждает #сертификат сервера
4.  Сервер генерирует собственную копию мастер-ключа.
5.  Клиент отправляет сообщение серверу #Finished , шифруя #хеш передачи с помощью симметричного ключа.
6.  Сервер генерирует собственный #хеш , расшифровывает хеш клиента и проверяет совпадение. 
   Если совпадение обнаружено, сервер отправляет клиенту собственный ответ `Finished`, также зашифрованный симметричным ключом.
7.   #TLS-сессия передаёт данные приложения ( #HTTP), зашифрованные с помощью подтверждённого симметричного ключа.

##### 6. Протокол HTTP

#HTTPD (HTTP Daemon) является одним из инструментов обработки запросов/ответов на стороне сервера. Наиболее популярные HTTPD-серверы это #Apache или #Nginx для Linux и #IIS для Windows.  
  
HTTPD (HTTP Daemon) получает запрос.  
— Сервер разбирает запрос по следующим параметрам:  
	-   Метод HTTP-запроса ( #GET, #POST, #HEAD, #PUT или #DELETE). В случае URL-адреса, который пользователь напечатал в строке браузера, мы имеем дело с GET-запросом.
	-   Домен. В нашем случае — google.com.
	-   Запрашиваемые пути/страницы, в нашем случае — `/` (нет запрошенных путей, `/` — это путь по умолчанию).
— Сервер проверяет существование виртуального хоста, который соответствует google.com.  
— Сервер проверяет, что google.com может принимать GET-запросы.  
— Сервер проверяет, имеет ли клиент право использовать этот метод (на основе IP-адреса, аутентификации и прочее).  
— Если на сервере установлен модуль перезаписи (`mod_rewrite` для Apache или `URL Rewrite` для IIS), то он сопоставляет запрос с одним из сконфигурированных правил. Если находится совпадающее правило, то сервер использует его, чтобы переписать запрос.  
— Сервер находит контент, который соответствует запросу, в нашем случае он изучит индексный файл.  
— Далее сервер разбирает («парсит») файл с помощью обработчика. Если Google работает на PHP, то сервер использует #PHP для интерпретации индексного файла и направляет результат клиенту.  

##### 7. За кулисами браузера

#Браузер включает следующие компоненты:  
  
-   **Пользовательский интерфейс**: В него входит адресная строка, кнопки продвижения вперёд/назад, меню закладок и так далее. Сюда относятся все элементы, кроме окна, в котором собственно отображается веб-страница.
-   **« Движок » браузера**: Распределяет действия между движком рендеринга и интерфейсом пользователя.
-   **«Движок» #рендеринг : Отвечает за отображение запрашиваемого контента. К примеру, если запрашивается HTML, то «движок» разбирает код HTML и CSS, а затем отображает полученный контент на экране.
-   **Сетевая часть**: с помощью сетевых функций браузер обрабатывает вызовы, вроде HTTP-запросов, с применением различных реализаций для разных платформ.
-   **Бэкенд интерфейса ( #UI)**: Используется для отрисовки базовых виджетов, вроде комбо-боксов и окон.
-   **Интерпретатор JS : Используется для парсинга и выполнения JavaScript-кода.
-   **Хранилище данных**: Браузеру может понадобиться локально хранить некоторые данные (например, cookie). Кроме того, браузеры поддерживают различные механизмы хранения, такие как #localStorage , #IndexedDB, #WebSQL и #FileSystem.

##### 8. Парсинг HTML

Движок #рендеринг начинает получать содержимое запрашиваемого документа от сетевого механизма браузера. Как правило, контент поступает кусками по 8Кб. Главной задачей HTML-парсера является разбор разметки в специальное #дерево.  
  
Получающееся на выходе дерево («parse tree») — это дерево #DOM-элемент и #DOM-узел атрибутов. #DOM — сокращение от `Document Object Model`. Это модель объектного представления HTML-документа и интерфейс для взаимодействия HTML-элементов с «внешним миром» (например, JavaScript-кодом). Корнем дерева является объект «Документ».  
  
###### Алгоритм разбора

HTML-нельзя «распарсить» с помощью обычных анализаторов (нисходящих или восходящих). Тому есть несколько причин:  
  
-   Прощающая почти что угодно природа языка;
-   Тот факт, что браузеры обладают известной толерантностью к ошибкам и поддерживают популярные ошибки в HTML.
-   Процесс парсинга может заходить в тупик. В других языках код, который требуется разобрать, не меняется в процессе анализа, в то время как в HTML с помощью динамического кода (например, скриптовые элементы, содержащие вызовы `document.write()`) могут добавляться дополнительные токены, в результате чего сам процесс парсинга модифицирует вывод.

Невозможность использования привычных технологий парсинга приводит к тому, что разработчики браузеров реализуют собственные механизмы разбора HTML. Алгоритм парсинга подробно описан в [спецификации HTML5](http://www.w3.org/TR/html5/).  
  
Алгоритм состоит из двух этапов: #токенизация и создания #дерево.  

###### Действия после завершения парсинга

После этого браузер начинает подгружать внешние ресурсы, связанные со страницей (стили, изображения, скрипты и так далее).  
  
На этом этапе браузер помечает документ, как интерактивный и начинает разбирать скрипты, находящиеся в «отложенном» состоянии: то есть те из них, что должны быть исполнены после парсинга. После этого статус документа устанавливается в состояние «`complete`» и инициируется событие загрузки («`load`»).  
  
Важный момент: ошибки `«Invalid Syntax»` при разборе не может быть, поскольку браузеры исправляют любой «невалидный» контент и продолжают работу.  

##### 9. Интерпретация CSS

-   Во время разбора браузер парсит CSS-файлы, содержимое тегов `<style>` и атрибутов «style» c помощью «[лексической и синтаксической грамматики CSS](http://www.w3.org/TR/CSS2/grammar.html)».
-   Каждый CSS-файл разбирается в объект `StyleSheet`, каждый из таких объектов содержит правила CSS с селекторами и объектами в соответствии с грамматикой CSS.
-   #парсер CSS может быть как восходящим, так и нисходящим.

##### 10. #Рендеринг
###### Рендеринг страниц

-   Путём перебора DOM-узлов и вычисления для каждого узла значений CSS-стилей создаётся «Дерево рендера» (Render Tree или Frame Tree).
-   Вычисляется предпочтительная ширина каждого узла в нижней части дерева — для этого суммируются значения предпочтительной ширины дочерних узлов, а также горизонтальные поля, границы и отступы узлов.
-   Вычисляется реальная ширина каждого узла сверху-вниз (доступная ширина каждого узла выделяется его потомкам).
-   Вычисляется высота каждого узла снизу-вверх — для этого применяется перенос текста и суммируются значения полей, высоты, отступов и границ потомков.
-   Вычисляются координаты каждого узла (с использованием ранее полученной информации).
-   Если элементы плавающие или спозиционированы абсолютно или относительно, предпринимаются более сложные действия. Более подробно они описаны [здесь](http://dev.w3.org/csswg/css2/) и [здесь](http://www.w3.org/Style/CSS/current-work).
-   Создаются слои для описания того, какие части страницы можно анимировать без необходимости повторного растрирования. Каждый объект (фрейма или рендера) присваивается слою.
-   Для каждого слоя на странице выделяются текстуры.
-   Объекты (рендеры/фреймы) каждого слоя перебираются и для соответствующих слоёв выполняются команды отрисовки. Растрирование может осуществляться процессором или возможна отрисовка на графическом процессоре (GPU) через D2D/SkiaGL.
-   Все вышеперечисленные шаги могут требовать повторного использования значений, сохранённых с последнего рендеринга страницы, такая инкрементальная работа требует меньше затрат.
-   Слои страницы отправляются процессу-компоновщику, где они комбинируются со слоями для другого видимого контента (интерфейс браузера, iframe-элементы, addon-панели).
-   Вычисляются финальные позиции слоёв и через Direct3D/OpenGL отдаются композитные команды. Командные буферы GPU освобождаются для асинхронного рендеринга и фрейм отправляется для отображения на экран.

###### Рендеринг GPU

-   Во время процесса рендеринга уровни графических вычислений могут использовать процессор компьютера или графический процессор ( #GPU).
-   Во втором случае уровни графического программного обеспечения делят задачу на множество частей, что позволяет использовать параллелизм GPU для вычисления плавающей точки, которое требуется для процесса рендеринга.

###### Вызванное пользователем и пост-рендеринговое исполнение

После завершения рендеринга, браузер исполняет JavaScript-код в результате срабатывания некоего часового механизма (так работают дудлы на странице Google) или в результате действий пользователя (ввод поискового запроса в строку и получение рекомендаций в ответ). Также могут срабатывать плагины вроде #Flash или #Java (но не в рассматриваемом примере с домашней страницей Google). Скрипты могут потребовать обработки дополнительных сетевых запросов, изменять страницу или её шаблон, что приведёт к следующему этапу рендеринга и отрисовки.
\





#### 12. Что такое #JSON? Может ли содержать массив?  
Подробнее: [Что такое JSON](https://habr.com/ru/post/554274/)

#JSON (англ. _JavaScript Object Notation_) — текстовый формат обмена данными, основанный на _JavaScript_. Но при этом формат независим от JS и может использоваться в любом языке программирования.

JSON используется в #REST API.
Возьмем пример из [документации подсказок Дадаты по ФИО](https://confluence.hflabs.ru/pages/viewpage.action?pageId=204669115):

```
{
  "query": "Виктор Иван",
  "count": 7
}
```

И разберемся, что означает эта запись.

Объект заключен в фигурные скобки {}
![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/acd/1a0/b3e/acd1a0b3e42086178942fcc0c0fd8d1b.png)

#JSON-объект — это неупорядоченное множество пар _«ключ:значение»_.

#ключ — это название параметра, который мы передаем серверу. Он служит маркером для принимающей запрос системы: «смотри, здесь у меня значение такого-то параметра!». А иначе как система поймет, где что? Ей нужна подсказка!

Давайте снова начнем с примера. Это массив:

```
[ "MALE", "FEMALE" ]
```

Массив заключен в квадратные скобки []

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5b1/c5f/800/5b1c5f800d9c612a1b27e87be3cc0297.png)

Внутри квадратных скобок идет набор значений. Тут нет ключей, как в объекте, поэтому обращаться к массиву можно только по номеру элемента. И поэтому в случае массива менять местами данные внутри нельзя. Это упорядоченное множество значений.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f7b/4b1/af8/f7b4b1af8f617aa9ca89fe15124863ed.png)

Значения разделены запятыми:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/760/c8f/f7a/760c8ff7ab4e88155efae8faeb46b689.png)

**Значения внутри**
Внутри массива может быть все, что угодно:

**Цифры**
```
[ 1, 5, 10, 33 ]
```

**Строки**
```
[ "MALE", "FEMALE" ]
```

**Смесь**
```
[ 1, "Андрюшка",  10, 33 ]
```

**Объекты**

Да, а почему бы и нет:
```
[1, {a:1, b:2}, "такой вот массивчик"]
```

Или даже что-то более сложное. Вот пример ответа подсказок из Дадаты:
```
[
        {
            "value": "Иванов Виктор",
            "unrestricted_value": "Иванов Виктор",
            "data": {
                "surname": "Иванов",
                "name": "Виктор",
                "patronymic": null,
                "gender": "MALE"
            }
        },
        {
            "value": "Иванченко Виктор",
            "unrestricted_value": "Иванченко Виктор",
            "data": {
                "surname": "Иванченко",
                "name": "Виктор",
                "patronymic": null,
                "gender": "MALE"
            }
        },
        {
            "value": "Виктор Иванович",
            "unrestricted_value": "Виктор Иванович",
            "data": {
                "surname": null,
                "name": "Виктор",
                "patronymic": "Иванович",
                "gender": "MALE"
            }
        }
]
```

Система возвращает массив подсказок. Сколько запросили в параметре _count_, столько и получили. Каждая подсказка — объект, внутри которого еще один объект. И это далеко не сама сложная структура! Уровней вложенности может быть сколько угодно — массив в массиве, который внутри объекта, который внутри массива, который внутри объекта...

Ну и, конечно, можно и наоборот, передать массив в объекте. Вот пример запроса в подсказки:
```
{
"query": "Виктор Иван",
"count": 7,
"parts": ["NAME", "SURNAME"]
}
```

Это объект (так как в фигурных скобках и внутри набор пар «ключ:значение»). А значение ключа _"parts"_ — это массив элементов!

**Итого**

Массив — это просто набор значений, разделенных запятыми. Находится внутри квадратных скобок [].
А вот внутри него может быть все, что угодно:
-   числа
-   строки
-   другие массивы
-   объекты
-   смесь из всего вышеназванного

[Формат JSON, метод toJSON](https://learn.javascript.ru/json)