#### 1. Что такое #VirtualDOM и зачем он нужен?  

Подробнее: [Что такое VirtualDOM](https://habr.com/ru/post/256965/)

##### Краткие выводы

#VirtualDOM — это техника и набор библиотек / алгоритмов, которые позволяют нам улучшить производительность на клиентской стороне, избегая прямой работы с DOM путем взаимодействия с легким JavaScript-объектом, имитирующем DOM-дерево.  

#VirtualDOM копирует реальный #DOM . При изменении какого-либо элемента происходит сравнение измененного виртуального DOM-дерева с этой виртуальной копией, определяется разница и запускается перерисовка того, что было изменено, вносится изменение в реальный #DOM .

> **Когда данные изменяются и нуждается в обновлении (ререндеренге)?**

Когда изменяются #state, #React решает нужно ли обновление #DOM, сравнивая возвращённый элемент с ранее отрендеренным. Если они не равны, React обновит DOM.

Есть такое понятие как первичный рендеринг (монтирование) и повторный ререндеринг.
На этапе монтирования создается наша виртуальная копия DOM, а ререндеринг в следствии изменения обьекта.

#props можно обновить в родительском компоненте, а так они readonly .
#state можно изменять
#key изменение

>> **Алгоритм сравнения (согласования)**
_React сравнивает деревья начиная с их корневых элементов и направляется вниз. 

Таким образом, сравниваются

>>  **Типы (теги) корневых элементов.**
_Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля_

>> **DOM-элементы одного типа**
_При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.

```html
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

_Сравнивая эти элементы, React знает, что нужно модифицировать только `className` у DOM-узла.

>> **Компоненты одного типа**

_Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. React обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает апдейт на базовом экземпляре.

_Далее вызывается метод `render()` и алгоритм сравнения рекурсивно обходит предыдущий и новый результаты._

>> **Рекурсия по дочерним элементам**

_По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React одновременно проходит по обоим спискам потомков и создаёт мутацию, когда находит отличие._

_Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично:_

```
<ul>
  <li>первый</li>
  <li>второй</li>
</ul>

<ul>
  <li>первый</li>
  <li>второй</li>
  <li>третий</li>
</ul>
```

_React сравнит два дерева `<li>первый</li>`, сравнит два дерева `<li>второй</li>`, а затем вставит дерево `<li>третий</li>`._

-->

_При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно. Например, преобразование между этими деревьями работает плохо:_

```
<ul>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>

<ul>
  <li>Ростов-на-Дону</li>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>
```

_React, вместо того чтобы оставить `<li>Санкт-Петербург</li>`  и `<li>Москва</li>` нетронутыми, будет мутировать каждого потомка. Эта неэффективность может стать проблемой._

_Для решения этой проблемы React поддерживает атрибут `key`. Когда у дочерних элементов есть ключи, React воспользуется ими, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. 
Например, если добавить `key` к неэффективному примеру выше, преобразование дерева станет эффективнее:_

```
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
```

Теперь React знает, что элемент с ключом `'2014'` — новый, а элементы с ключами `'2015'` и `'2016'` переместились.

На практике найти ключ обычно несложно. Элемент, который вы хотите отобразить, уже может иметь уникальный идентификатор, и ключ может быть взят из ваших данных:

```
<li key={item.id}>{item.name}</li>
```

Когда уникальное значение отсутствует, вы можете добавить новое свойство идентификатора в вашу модель или прохешировать данные, чтобы сгенерировать ключ. Ключ должен быть уникальным только среди его соседей, а не глобально.

Важно помнить, что алгоритм согласования — это деталь реализации. 
React может повторно рендерить всё приложение на каждое действие, конечный результат будет тем же. Для ясности, повторный рендер в этом контексте означает вызов функции `render` для всех компонентов, но это не означает, что React размонтирует и смонтирует их заново. Он лишь применит различия следуя правилам, которые были обозначены выше.

##### Что такое #DOM и отличие от #VirtualDOM 

#VirtualDOM  - то, почему #React обьект работает так быстро, легковесные обьекты.

Главная проблема #DOM — он никогда не был рассчитан для создания динамического пользовательского интерфейса ( #UI ). Мы можем работать с ним, используя JavaScript и библиотеки наподобие jQuery, но их использование не решает проблем с производительностью.

Можем ли мы решить эту проблему? Похоже, что можем.

#VirtualDOM не является стандартом и в конечном итоге мы по-прежнему взаимодействуем с DOM, но делаем это как можно реже и более эффективно.
Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM.  

При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.  
  
Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM.  

Но только если мы делаем это правильно. 
Есть две проблемы: когда именно делать повторную перерисовку DOM и как это сделать эффективно.

**Когда?**  
Когда данные изменяются и нуждается в обновлении.  
Есть два варианта узнать, что данные изменились:  

-   Первый из них — «dirty checking» (грязная проверка) заключается в том, чтобы опрашивать данные через регулярные промежутки времени и рекурсивно проверять все значения в структуре данных.
-   Второй вариант — «observable» (наблюдаемый) заключается в наблюдении за изменением состояния. Если ничего не изменилось, мы ничего не делаем. Если изменилось, мы точно знаем, что нужно обновить.

**Как?**  
Что делает этот подход действительно быстрым:  

-   Эффективные алгоритмы сравнения
-   Группировка операций чтения/записи при работе с DOM
-   Эффективное обновление только под-деревьев

Как вы понимаете, это не так просто и реализация может оказаться довольно сложной, но есть некоторые библиотеки, которые помогают реализовать этот подход в наших проектах.  
Одной из таких самых известных библиотек является React от команды разработчиков Facebook.  
  
##### Другие библиотеки и фреймворки

-   [virtual-dom](https://github.com/Matt-Esch/virtual-dom) — реализация Virtual DOM от Matt Esch, алгоритм сравнения отличий.
-   [Mithril](http://lhorie.github.io/mithril/) — Javascript-фреймворк для создания ярких приложений.
-   [Bobril](https://github.com/Bobris/Bobril) — Компонент-ориентированный фреймворк, вдохновленный подходами Mithril и ReactJs.
-   [cito.js](https://github.com/joelrich/citojs) — JavaScript-фреймворк для создания быстрых, масштабируемых и модульных веб-приложений.

#### 2. Что такое #React?  
Подробнее: [[1.1.1 Знакомство с React]]

#React — это декларативная, эффективная и гибкая #JS-библиотека для создания пользовательских интерфейсов. Она позволяет вам собирать сложный #UI из маленьких изолированных кусочков кода, называемых «компонентами».

#React-компонент - это независимые блоки пользовательского интерфейса, которые могут иметь свое собственное поведение

Функции, которые возвращают #React-элемент должны начинаться с большой буквы.
Например, 

~~~
const Header = () = > return <h1>Hi</h1>
~~~

React создает легковесное дерево из JavaScript-объектов для имитации DOM-дерева. Затем он создает из них HTML, который вставляется или добавляется к нужному DOM-элементу, что вызывает перерисовку страницы в браузере.  

React — это библиотека, а не фреймворк, поэтому сравнивать его с Angular или Ember некорректно.  

#### 3. Как добавить #React на страницу?  

1. Для того, чтобы работать в #React необходимо применить скрипт:
```
	npx create-react-app my-app
```

И подготовить директорию к работе, удалив шаблонные файлы проекта.

2. Привязываем терминал к проекту
~~~
cd my-app
~~~

3. Удаляем лишние файлы и подготавливаем наш шаблон к работе
4. Импортируем библиотеку React
~~~
import React, { Component } from 'react';
~~~
5. Импортируем библиотеку react-dom
~~~
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
~~~

createRoot - корневой DOM-узел, тк через него мы управляем React содержимым.

#### 4. Что такое #JSX ? Можем ли мы использовать React без JSX?  
Подробнее: [[0007 Знакомство с JSX]]

JSX производит «элементы» React. 

```
const name = 'Иван-Царевич';
const element = <h1>Здравствуй, {name}!</h1>;
```

JSX допускает использование любых корректных [JavaScript-выражений](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators) внутри фигурных скобок. 

JSX не является обязательным для работы с React. React можно использовать без JSX.
Подробнее [React без JSX](https://ru.reactjs.org/docs/react-without-jsx.html)

Например, вот код с JSX:

```
class Hello extends React.Component {
  render() {
    return <div>Привет, {this.props.toWhat}</div>;
  }
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Hello toWhat="Мир" />);
```

Он может быть превращён в код без JSX:

```
class Hello extends React.Component {
  render() {
    return React.createElement('div', null, `Привет, ${this.props.toWhat}`);
  }
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(React.createElement(Hello, {toWhat: 'Мир'}, null));
```

#### 5. JSX, условный рендеринг, работа с коллекциями
##### Рендеринг

Для рендеринга React-элемента, сперва передайте #DOM-элемент в [`ReactDOM.createRoot()`](https://ru.reactjs.org/docs/react-dom-client.html#createroot), далее передайте #React-элемент в `root.render()`:

```
const root = ReactDOM.createRoot(
  document.getElementById('root')
);
const element = <h1>Hello, world</h1>;
root.render(element);
```

 На практике большинство React-приложений вызывают `root.render()` только один раз. 

##### Условный рендеринг
Подробнее: [Условный рендеринг](https://ru.reactjs.org/docs/conditional-rendering.html)

Условный рендеринг в React работает так же, как условные выражения работают в JavaScript. Бывает нужно объяснить React, как состояние влияет на то, какие компоненты требуется скрыть, а какие — отрендерить, и как именно. В таких ситуациях используйте [условный оператор](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80) JavaScript или выражения подобные [`if`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/if...else).

Рассмотрим два компонента:

```
function UserGreeting(props) {
  return <h1>С возвращением!</h1>;
}

function GuestGreeting(props) {
  return <h1>Войдите, пожалуйста.</h1>;
}
```

Можно создать компонент `Greeting`, который отражает один из этих компонентов в зависимости от того, выполнен ли вход на сайт:

```
function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) {    
		return <UserGreeting />;  }  
	return <GuestGreeting />;}

const root = ReactDOM.createRoot(document.getElementById('root')); 
// Попробуйте заменить на isLoggedIn={true}:

root.render(<Greeting isLoggedIn={false} />);
```

В этом примере рендерится различное приветствие в зависимости от значения пропа `isLoggedIn`.

В редких случаях может потребоваться позволить компоненту спрятать себя, хотя он уже и отрендерен другим компонентом. Чтобы этого добиться, верните `null` вместо того, что обычно возвращается на рендеринг.

##### Работа с коллекциями
Подробнее: [Работа с коллекциями](https://ru.hexlet.io/courses/js-react/lessons/jsx-collections/theory_unit)

#### 6. Зачем нужен #key ?  
Подробнее: [Ключи](https://ru.react.js.org/docs/lists-and-keys.html#%D0%9A%D0%BB%D1%8E%D1%87%D0%B8)

Каждому #JSX элементу в массиве нужно уникальное свойство #key 

key нужен для того , чтобы реакт отрисовывал элменты лучше.

#React использует #key , чтобы эффективно сравнивать элементы при обновлении
Не стоит делать ключи из индексов массива. Ключ типа #key считается одним из самых идеальных ключей, потому что он уникален для #React обьекта.

~~~
      <Task
        {...itemProps}
        key={id} // !
        id={id}
        deleteItem={() => deleteItem(id)}
        editItem={() => editItem(id)}
        onSubmitEdit={(event) => onSubmitEdit(event, id)}
        done={item.done}
        onToggleDone={() => onToggleDone(id)}
      />
~~~

Для решения этой проблемы React поддерживает атрибут `key`. Когда у дочерних элементов есть ключи, React воспользуется ими, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. Например, если добавить `key` к неэффективному примеру выше, преобразование дерева станет эффективнее:

```
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
```

Теперь React знает, что элемент с ключом `'2014'` — новый, а элементы с ключами `'2015'` и `'2016'` переместились.

На практике найти ключ обычно несложно. Элемент, который вы хотите отобразить, уже может иметь уникальный идентификатор, и ключ может быть взят из ваших данных:

```
<li key={item.id}>{item.name}</li>
```

Когда уникальное значение отсутствует, вы можете добавить новое свойство идентификатора в вашу модель или прохешировать данные, чтобы сгенерировать ключ. Ключ должен быть уникальным только среди его соседей, а не глобально.

В крайнем случае вы можете передать индекс элемента массива в качестве ключа. Это работает хорошо в случае, если элементы никогда не меняют порядок. Перестановки элементов вызывают замедление.

Вдобавок перестановки элементов могут вызвать проблемы с состоянием компонента, когда в качестве ключей используются индексы. Экземпляры компонента обновляются и повторно используются на основе своих ключей. Если ключ является индексом, то перемещение элемента изменяет его. В результате состояние компонента для таких элементов, как неуправляемые `<input>`, может смешаться и обновиться неожиданным образом.
#### 7. Какие различия между компонентом-классом и функциональным компонентом?  
Подробнее: [[0006 React - компоненты]] , [[0010 Компоненты и пропсы]] ,  [[0014 Компоненты-классы]], [Чем функциональные компоненты React отличаются от компонентов, основанных на классах?](https://habr.com/ru/company/ruvds/blog/444348/)

Функции, которые возвращают #React-элемент должны начинаться с большой буквы.
Например, 

~~~
const Header = () = > return <h1>Hi</h1>
~~~

Это имя затем можно использовать в #JSXX как будто это HTML-тег

##### Функциональный компонент

Функциональный компонент - это обычная функция JavaScript, возвращающая #JSX.

```
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}
```

Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и возвращает React-элемент. Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.

##### namespace

Основные фишки #namespace в том, что они могут быть иерархическими, а реализацию одного пространства имён можно раскидывать по разным файлам. Модуль это просто вырожденный случай, где файл образует отдельный одноуровневый #namespace.

##### Компонент класса

Компонент класса - это расширяемый класс JavaScript, #React.

~~~
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
~~~

Классы используются, когда нужно хранить состояние через #props . Пропсы доступны через this.props.

Классы наследуют React.component , а через метод render() возвращается элемент.

##### Преобразование функционального компонента в классовый компонент

1.  Создаём [ES6-класс](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes) с таким же именем, указываем `React.Component` в качестве родительского класса
2.  Добавим в класс пустой метод `render()`
3.  Перенесём тело функции в метод `render()`
4.  Заменим `props` на `this.props` в теле `render()`
5.  Удалим оставшееся пустое объявление функции

```
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, [функциональный он или классовый](https://ru.reactjs.org/docs/components-and-props.html#function-and-class-components).

#### 8. Что такое #children в #props?  
Подробнее: [краткое введение в props.children в React](https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891)

Кратко:
`React.Children` предоставляет функции для работы с непрозрачной структурой данных `this.props.children`.

Предположим, что у нас есть компонент `<Grid />`, который может содержать в себе компоненты `<Row />`. Мы бы написали это так:

```css
<Grid>
  <Row />
  <Row />
  <Row />
</Grid>
```
Эти три компонента `Row` передаются компоненту `Grid` как `props.children`.
Используя контейнер для выражения {} родители могут рендерить свои дочерние элементы:
```javascript
class Grid extends React.Component {
  render() {
    return <div>{this.props.children}</div>
  }
}
```
`Children` в React не обязательно быть компонентами, они могут быть всем, чем угодно. Для примера, мы можем передать нашему вышеупомянутому компоненту `<Grid />` какой-либо текст в виде `children` и всё будет прекрасно работать:

```javascript
<Grid>Hello world!</Grid>
```

Мы можем передать любое JavaScript выражение, как дочерний элемент. И функции не исключение.

Чтобы показать то, как это выглядит, посмотрите на этот компонент, который выполняет функцию, которая была передана как дочерний элемент:

```javascript
class Executioner extends React.Component {
  render() {
    // Обратите внимание на то, как мы вызываем дочерний элемент,    как функцию?
    // ↓
    return this.props.children()
  }
}
```

 `props.children` может быть любым типом данных, например таким как массив, функция, объект и тп. В общем, это может быть всем чем угодно.

В React есть несколько вспомогательных функций, которые могут помочь управлять `children` довольно легко и без лишних заморочек. Доступны они в `React.Children`.
[[0030 Теория JSX - синтаксис . Передача контента]]



Это еще один способ передачи данных внутрь компонента.
Например у меня есть несколько самозакрывающихся тегов. в один из них, надо передать внутрь какое то свойство

Для того, чтобы обработать можно сделать шаблон с ключевым свойством children .
В данном обьекте будет хранится свойство color


{this.props.children}

```javascript
render() {
  if (this.props.appLoaded) {
    return (
      <div>
        <Header
          appName={this.props.appName}
          currentUser={this.props.currentUser}
        />
        {this.props.children}
      </div>
    );
  }
}
```

`this.props.children` заключается в том, что  используется для отображения всего, что вы включаете между открывающим и закрывающим тегами при вызове компонента.

Простой пример:

> Вот пример функции без сохранения состояния, которая используется для создания компонента. Опять же, поскольку это функция, здесь нет `this`ключевого слова, поэтому просто используйте`props.children`

```javascript
const Picture = (props) => {
  return (
    <div>
      <img src={props.src}/>
      {props.children}
    </div>
  )
}
```

> Этот компонент содержит объект `<img>`, который получает некоторые данные `props`, а затем отображает файлы `{props.children}`.

> Всякий раз, когда этот компонент вызывается, `{props.children}`он также будет отображаться, и это просто ссылка на то, что находится между открывающим и закрывающим тегами компонента.

```javascript
//App.js
render () {
  return (
    <div className='container'>
      <Picture key={picture.id} src={picture.src}>
          //what is placed here is passed as props.children  
      </Picture>
    </div>
  )
}
```

> Вместо того, чтобы вызывать компонент с самозакрывающимся тегом, `<Picture />`если вы вызываете его с полными открывающими и закрывающими тегами, `<Picture> </Picture>`вы можете разместить между ними дополнительный код.

> Это отделяет `<Picture>`компонент от его содержимого и делает его более пригодным для повторного использования.

children является псевдомассивом !!!
передается 2 строки и 2 числа

#### 9. Что делает #setState? Функция setState первым аргументом может принять объект, а может функцию. Зачем нужна функция?  
Подробнее: [[0016 State - состояние компонента]] , 

В #State хранится состояние (свойства) #React элемента, его можно инициализировать в конструкторе или в теле класса.

Одно из самых важных аспектов #React заключается в том, чтобы обновить state используют #setState()

Функция #setState может принимать в виде аргумента функцию, этот аргумент - текущий state.

~~~
this.setState( (state)  => {
	return {
		count: state.count 1}
});
~~~

Происходит асинхронное обновление состояния state в зависимости от предыдущего значения.

#### 10. Как выполнить действие с новым состоянием стейта после #setState?  

##### Как использовать setState

Метод `setState()` планирует изменение объекта состояния (`state`) компонента. Когда состояние меняется, компонент рендерится повторно.

Используя новые состояния #State можно добавлять , удалять и обновлять элементы.

// Удалить элемент
~~~
setState() {
	...
	newArr = […oldArr.slice(0, idx), …oldArr.slice(idx 1)]
	...
}
~~~

// Добавить элемент
~~~
setState() {

	const newArr = [... oldArr , newItem] // добавить элемент в конец массива
	
	const newArr = [newItem, ...oldArr] // добавить элемент в начало массива

}

arr.push () - тоже изменение массива (нельзя выполнять на массивах из #State )
~~~

##### Подробнее про setState

```
setState(updater[, callback])
```
`setState()` добавляет в очередь изменения в состоянии компонента. Также он указывает React, что компонент и его дочерние элементы должны быть повторно отрендерены с обновлённым состоянием. Этот метод используется для обновления интерфейса в ответ на обработчики событий и ответы сервера.

Думайте о `setState()`, как о _запросе_, а не как о команде немедленного обновления компонента. Для увеличения производительности React может задержать его выполнение, а затем обновить несколько компонентов за один проход. In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in [`flushSync`](https://ru.reactjs.org/docs/react-dom.html#flushsync), but this may hurt performance.

Метод `setState()` не всегда обновляет компонент сразу. Он может группировать или откладывать обновление до следующего раза. Это делает чтение `this.state` сразу после вызова `setState()` потенциальной ловушкой. Вместо этого используйте `componentDidUpdate()` или колбэк `setState()` (`setState(updater, callback)`), каждый из которых гарантированно вызывается после того как было применено обновление. Если вам нужно обновить состояние на основе предыдущего, используйте аргумент `updater`, описанный ниже.

`setState()` всегда приводит к повторному рендеру, если только `shouldComponentUpdate()` не возвращает `false`. Если используются мутабельные объекты, и условие рендеринга не может быть реализовано в `shouldComponentUpdate()`, вызывайте `setState()` только при разнице следующего и предыдущего состояния. Это предотвратит ненужные повторные рендеры.

Первым аргументом передаётся функция `updater`, которая имеет следующий вид:

```
(state, props) => stateChange
```

`state` — ссылка на состояние компонента при изменении. Объект состояния не должен мутировать. Изменения должны проявляться в виде нового объекта на основе входных данных из `state` и `props`. Предположим, что мы хотели бы увеличить значение состояния с помощью `props.step`:

```
this.setState((state, props) => {
  return {counter: state.counter + props.step};
});
```

Как `state`, так и `props`, полученные функцией обновления, гарантированно будут обновлены. Результат функции поверхностно объединяется с `state`.

Второй параметр в `setState()` — необязательный колбэк, вызываемый после выполнения `setState` и повторного рендера компонента. Вместо этого в большинстве случаев для такой логики мы рекомендуем использовать `componentDidUpdate()`.

В качестве первого аргумента `setState()`, вместо функции, вы можете передать объект:

```
setState(stateChange[, callback])
```

В нём образуется новое состояние после поверхностного объединения с `stateChange`. Например, установим количество товаров в корзине:

```
this.setState({quantity: 2})
```

Эта форма записи `setState()` также асинхронна, и несколько вызовов в течение одного цикла могут быть объединены вместе. Например, вам нужно увеличить количество элементов несколько раз в одном цикле. Результат этого можно представить так:

```
Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)
```

Последующие вызовы будут переопределять значения из предыдущих вызовов того же цикла. Из-за этого количество увеличится только один раз. В случае, если следующее состояние зависит от текущего, мы рекомендуем использовать форму функции обновления:

```
this.setState((state) => {
  return {quantity: state.quantity + 1};
});
```

##### React.Component
Подробнее: [React.Component](https://ru.reactjs.org/docs/react-component.html)

В качестве первого аргумента `setState()`, вместо функции, вы можете передать объект:

```
setState(stateChange[, callback])
```

В нём образуется новое состояние после поверхностного объединения с `stateChange`. Например, установим количество товаров в корзине:

```
this.setState({quantity: 2})
```

Эта форма записи `setState()` также асинхронна, и несколько вызовов в течение одного цикла могут быть объединены вместе. Например, вам нужно увеличить количество элементов несколько раз в одном цикле. Результат этого можно представить так:

```
Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)
```

Последующие вызовы будут переопределять значения из предыдущих вызовов того же цикла. Из-за этого количество увеличится только один раз. В случае, если следующее состояние зависит от текущего, мы рекомендуем использовать форму функции обновления:

```
this.setState((state) => {
  return {quantity: state.quantity + 1};
});
```

Для более подробной информации смотрите:

-   [Руководство по состоянию и жизненному циклу](https://ru.reactjs.org/docs/state-and-lifecycle.html)
-   [Продвинутый уровень: когда и почему группируются вызовы `setState()`?](https://stackoverflow.com/a/48610973/458193)
-   [Продвинутый уровень: почему `this.state` не обновляется сразу?](https://github.com/facebook/react/issues/11527#issuecomment-360199710)

---

##### Какая разница между `state` и `props`?

[`props`](https://ru.reactjs.org/docs/components-and-props.html) (намеренно сокращённо от англ. «properties» — свойства) и [`state`](https://ru.reactjs.org/docs/state-and-lifecycle.html) — это обычные JavaScript-объекты. Несмотря на то, что оба содержат информацию, которая влияет на то, что увидим после рендера, есть существенное различие: `props` передаётся _в_ компонент (служат как параметры функции), в то время как `state` находится _внутри_ компонента (по аналогии с переменными, которые объявлены внутри функции).

#### 11. Что такое контроллируемый компонент?  
Подробнее: [Контролируемый и неконтролируемый компонент](https://habr.com/ru/post/502034/)

##### Краткое описание

Компонент становится контролируемым, когда вы устанавливаете его значение используя props. 

**Пример**
Например, у меня есть функция добавления задачи onSubmit ,
в ней есть preventDefault и функция очищение формы через setState с пустой " " по факту ввода значения .
setState изменяет состояние а #React понимает что нужно выполнить функцию render и надо выполнить фунцию value и её выполнение не приводит к событию.

На onSubmit - это функция добавления задачи и её очищения после ввода. На изменение **input** мы вешаем обработчик клика, который при каждом новом вводе сет-стейтит новое значение value, полученное из **event**-объекта ;

А при каждой отрисовке значение инпута берется из стейта. Выходит что инпут буквально находится под контролем у стейта — отправляет новые значения в него и читает оттуда же.

##### Подробнее [Контролируемые компоненты](https://makeweb.me/anatomiya-react-dlya-nachinayushhih-urok-9-spiski-i-formy-ne-kontroliruemye-komponenty/)

Компонент становится контролируемым, когда вы устанавливаете его значение используя props. Вот и всё.  

  ![[Pasted image 20230320183637.png]]

onChange() - обновляет state, а state обновляется value элемента.

Давайте посмотрим на пример кода.

```
import React, { Component } from 'react';

class App extends Component {
    state = {
        message: ''
    }
    updateMessage = (newText) => {
        console.log(newText);
        this.setState(() => ({
            message: newText
        }));
    }
    render() {
        return (
            <div classname="App">
                <div classname="container">
                    <input type="text" placeholder="Your message here.." value="{this.state.message}" onchange="{(event)" ==""> this.updateMessage(event.target.value)}
                    />
                    <p>the message is: {this.state.message}</p>
                </div>
            </div>
        );
    }
}

export default App;
```

Если мы посмотрим на код для этого компонента, в строке 4 мы создаем объект состояния. Он содержит единственное свойство, которое называется `message`. Здесь хранится значение, введенное в текстовое поле.

Чтобы сохранить значение, нам нужно событие, которое будет запущено, когда пользователь вводит текст в поле. Как мы это делаем?

Если вы посмотрите на строки 19 и 20 кода, вы увидите, что:

1.  Текстовое поле имеет атрибут value, связанный со свойством сообщения в состоянии.
2.  У нас есть обработчик события `onChange`.

Эти 2 пункта говорят вам, что это контролируемый компонент.

Нам не нужен элемент формы на странице, чтобы компонент был контролируемым компонентом.

Когда вносятся изменения в любой из элементов ввода, имеющих обработчик события, он запускается.

Обработчик вызывает `setState()`, как вы можете видеть в строке 9 выше. Это обновляет состояние внутри компонента.

Вы никогда не должны устанавливать состояние прямо так:

```
this.state.message = 'dont update state like this';
```

Обновление состояния таким способом не вызовет повторную визуализацию компонента, а сделанные пользователем изменения не будут отображаться в пользовательском интерфейсе.

Когда обновление состояния происходит через `setState()`, это вызывает повторную визуализацию компонента, и вновь введенное значение отображается в элементе.

Поток данных является однонаправленным от состояния компонента к элементу ввода.

Работа с контролируемыми компонентами может быть немного громоздкой. Если на странице имеется большое количество элементов ввода, каждый элемент требует настройки с атрибутом значения и обработчиком события.

#### 12. Зачем нужны #eslint и #prettier?  

#ESLint необходим для подсветки ошибок и работы с описанными правилами. 
#Prettier служит для чтения правил и форматирования кода .

-   eslint – главный модуль линтера.
-   eslint-config-airbnb  – готовая конфигурация для использования стайлгайда Airbnb.
-   eslint-config-prettier  – позволяет ESLint и Prettier работать вместе.
-   eslint-plugin-import – предназначен для поддержки синтаксиса импорта/экспорта и управления путями к файлам. Подробнее можно прочитать в [документации плагина](https://github.com/benmosher/eslint-plugin-import).
-   eslint-plugin-jsx-a11y 
-   eslint-plugin-react  – добавляет специфические настройки линтинга для проектов React.
-   eslint-plugin-react-hooks
-   husky _дает возможность зацепиться за хуки git. Это значит, что вы можете выполнять некоторые действия перед тем, как изменения будут закоммичены и отправлены в удаленный репозиторий_ .
-   lint-staged  _позволяет запускать тесты/форматеры на измененных файлах в pre-commit-хуке_

1.  `lint` - проверяет все файлы на ошибки
2.  `lint:fix` - проверяет и исправляет те ошибки, которые может
3.  `format` - форматирует все файлы с помощью prettier

#### 13. Как работать с формами в react?
Подробнее: [[0025 Работа с формами]]

Используем:
#onChange() чтобы получать текущее значение;
#onSubmit() - событие "отправки" формы;
e.preventDefault() - чтобы страница не перезагружалась.

HTML-элемент `<textarea>` в качестве текста отображает дочерний элемент:

```
<textarea>
  Привет! Тут просто немного текста внутри тега textarea
</textarea>
```

В HTML `<select>` создаёт выпадающий список. HTML-код в этом примере создаёт выпадающий список
```
<select>
  <option value="grapefruit">Грейпфрут</option>
  <option value="lime">Лайм</option>
  <option selected value="coconut">Кокос</option>
  <option value="mango">Манго</option>
</select>
```

В HTML `<input type="file">` позволяет пользователю выбрать один или несколько файлов для загрузки с устройства на сервер или управлять им через JavaScript с помощью [File API](https://developer.mozilla.org/ru/docs/Web/API/File/Using_files_from_web_applications)
```
<input type="file" />
```

#### Когда происходит ререндер состояния ?
[Подробнее про ререндер состояния](Существует 4 причины, по которым компонент подвергается ререндерингу: изменение состояния, ререндеринг родительского компонента, изменение контекста и изменение хука. Существует распространенный миф о том, что ререндеринг происходит также при изменении пропов.)

Ререндеринг происходит, когда `React` необходимо обновить приложение некоторыми данными. Обычно, это является результатом действий пользователя, получения ответа на асинхронный запрос.

Существует 4 причины, по которым компонент подвергается ререндерингу: изменение состояния, ререндеринг родительского компонента, изменение контекста и изменение хука. Существует распространенный миф о том, что ререндеринг происходит также при изменении пропов.

Компонент всегда подвергается ререндерингу при изменении его состояния. Обычно, это происходит в функции обратного вызова или в хуке `useEffect`.

_Изменения состояния влекут за собой безусловный (непредотвращаемый) ререндеринг_

![](https://habrastorage.org/r/w1560/webt/qm/9j/ag/qm9jagqd8_b5ajh_yukyjf9svuc.png)
