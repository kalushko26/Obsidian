### Ответ

#### Реализовал `Диаграмма Ганта`

```jsx
import React from 'react';

function GanttChart({ tasks }) {
  // Рассчитываем длительность проекта
  const projectStartDate = tasks.reduce(
    (earliestStartDate, task) =>
      earliestStartDate ? (task.start < earliestStartDate ? task.start : earliestStartDate) : task.start,
    null
  );
  const projectEndDate = tasks.reduce(
    (latestEndDate, task) =>
      latestEndDate ? (task.end > latestEndDate ? task.end : latestEndDate) : task.end,
    null
  );

  // Рассчитываем пропорциональные размеры и позиции задач
  const totalDuration = projectEndDate.diff(projectStartDate, 'days') + 1;
  const taskBars = tasks.map(task => {
    const startOffset = task.start.diff(projectStartDate, 'days');
    const duration = task.end.diff(task.start, 'days') + 1;
    const width = (duration / totalDuration) * 100;
    const left = (startOffset / totalDuration) * 100;

    return (
      <div
        key={task.id}
        className="task-bar"
        style={{ width: `${width}%`, left: `${left}%` }}
      >
        {task.name}
      </div>
    );
  });

  return (
    <div className="gantt-chart">
      <div className="timeline">
        <div className="start-date">{projectStartDate.format('YYYY-MM-DD')}</div>
        <div className="end-date">{projectEndDate.format('YYYY-MM-DD')}</div>
      </div>
      <div className="task-bars-container">{taskBars}</div>
    </div>
  );
}

export default GanttChart;
```

В этом примере компонент GanttChart принимает массив tasks, который содержит информацию о задачах. Компонент рассчитывает длительность проекта, а затем пропорционально распределяет и позиционирует задачи на основе их начальной и конечной даты.

CSS-стили можно определить отдельно для компонента GanttChart и его дочерних элементов, например:

```jsx
.gantt-chart {
  position: relative;
  margin-top: 20px;
}

.timeline {
  position: relative;
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
}

.start-date,
.end-date {
  font-size: 12px;
}

.task-bars-container {
  position: relative;
  height: 40px;
  border: 1px solid #ccc;
}

.task-bar {
  position: absolute;
  top: 0;
  height: 100%;
  background-color: #007bff;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  padding: 4px;
}
```

Вы можете использовать этот компонент GanttChart в вашем приложении React, передавая ему массив задач в качестве пропса.

```jsx
import React from 'react';
import GanttChart from './GanttChart';

function App() {
  const tasks = [
    { id: 1, start: moment('2023-01-01'), end: moment('2023-01-05'), name: 'Task 1' },
    { id: 2, start: moment('2023-01-03'), end: moment('2023-01-10'), name: 'Task 2' },
    { id: 3, start: moment('2023-01-06'), end: moment('2023-01-15'), name: 'Task 3' },
    // Добавьте остальные задачи...
  ];

  return (
    <div>
      <h1>Gantt Chart Example</h1>
      <GanttChart tasks={tasks} />
    </div>
  );
}

export default App;
```

#### [[129 Что такое React Profiler и для чего он используется|Оптимизация React]]

Была такая таска, я работал над фильтрацией активных сменных заданий. Вроде как таску выполнил и её можно было смело закрывать, время еще оставалось. Но заметил, что когда я нажимаю на запуск фильтрации данных, был заметен такой полу-секундный блик.

Я на этом сконцентрировал внимание и стал искать источник проблемы. Сначала я перешел в расширение *React devTools -> Profiler -> Начать запись.* Повторил операцию, на которой у меня происходил блик и нажал на СТОП.

Я узнал время отображения данных в мС. Сколько у меня заняла та или иная операция.

![[Pasted image 20231003002442.png|600]]

Выбираю самую длительную операцию и смотрю на неё.

![[Pasted image 20231003002533.png|600]]

Смотрю, сколько времени ушло на загрузку каждого из Компонентов.

Так вот, когда я узнал самый труднозатратный по времени компонент, я выяснил, что он состоял из подмножества других компонентов и его общее количество рендеров (2 рендера).

Я перешел в код и увидел, что при клике у меня передаривается участок кода, который у меня на веб-странице статичен, не изменяется. Я обернул компонент, в котором находится этот список в `memo()` и повторно использовал `Profiler`. Таким образом, я сократил время загрузки компонента, примерно в 5 раз (с 150мС до 38мС) и количество рендеров стало 1.

В общем, это ситуация из-за возникновения рендеринга слишком большого количества контента (компонентов) и использование `memo` решило проблему с бликом при клике кнопки.

Я противник того, что использовать `memo()` , `useCallback()`, `useMemo()` везде, где только можно, а подхожу к этому вопросу точечно, когда того требует ситуация.

#### Внедрение unit- тестирования на проект

#### Обработка ошибок `Error Boundary` в функциональном компоненте



___
tags: #hh