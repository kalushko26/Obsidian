#### **План работы:**

![](https://www.youtube.com/watch?v=umiT0yIsSrc)

На предыдущем месте работы были 2-х недельные спринты.

Было 3 окружения:
* `developer`: на нём производили тестирования, каждый разработчик мог поднять маленькое окружение, деплоилось на набор тачек в одном большом докер контейнере в котором были все необходимое зависимости.
		* `release`: было условным `pre-production`, там запускалось через `ansible` скрипты в `docker` контейнерах, результаты фронт сборки раздавались с помощью `nginx`, занимались всем этим `devOps` на этой ветке возились тестеры.
* `production`: катились по `release` циклу, ручками собирали пачку фичи веток в одну релизную ветку, проводили `deploy` и после этого сливали в мастер как кодовую базу.

##### **1. `Continues integration (CI)`**

*`developer-ветка` -> создать новую ветку для работы над `task` -> выполняю `task`*

1. `Code` - идёт написание кода, покрытие тестами 
   -> `git commit` -> `git push` -> `git pull/merge request`
Проходит `code-review` от других фронтенд-разработчиков, минимум 2 апрува (одобрения).

2. `Build` - системой наподобие `jenkins` автоматически производится: 
	* сборка приложения ->
	* unit-тестирование ->
	* e2e-тестирование ->
	* esLint ->
	* проверка типизации.
Процесс `CI` тестирования автоматизированный и занимает *в идеале не более 10 минут*. 

Одобряет `mergeRequest` после успешно пройденных тестов - разработчик (если доступы открыты), либо техлид. 

По такой схеме работает каждый участник команды, после каждого `git merge` `developer`-ветка упаковывается и тестируется. Таким образом, мы узнаем об ошибках до того, как выкатили `release`, а следовательно, мы недопустим попадания функциональности, которое ломает приложение на `production` -сервер.

3. `test`: после `mergeRequest` идёт ещё раз проверка `developer`-ветки, где происходит автоматическое тестирование для выявления неявных ошибок при разработке.

Таким образом, на протяжении спринта разработчики осуществляют `mergeRequest` в `production` -ветку для подготовки внесения изменений и добавления новых фич на `release`.

##### **2. `Continues delivery`**

В конце спринта происходит отрезание веток (отрезает ветку - техлид), теперь ветка становится `release` -веткой, на протяжении следующей недели тестировщики проводят над `release`-веткой `регрессионное тестирование` . В случае возникновения багов разработчики производят багфикс. 

**ВАЖНО:** Пока тестировщики проводят регрессионное тестирование, команда продолжает работу над задачами следующего спринта.

4. `release`. После того, как команда ручных тестировщиков проверила все изменения у нас получилась стабильная версия продукта, ей присваивается `номер, тэг` и теперь данные изменения называются **release-кандидатом.**

##### **3. `Continues deployment (CD)`**

5. `deploy`
 Техлид одобряет развёртывания в `production`.  `release` - ветка пушится в `production` .

6. `operate` и `monitoring`: на этом этапе мы следим за развернутой версией продукта и в случае чего фиксим ее и дорабатываем.
   
7. `plan` : планирование новых фич и изменений на основе отзывов клиентов и требований аналитика.

##### Резюме

`git -> developer -> release -> production`


Подробнее: [[004 Что такое CICD|Что такое `CI/CD`?]]  ,[Git Flow](https://habr.com/ru/articles/346066/) , [Делаем простые отчеты в CI с помощью GitLab Pages для Playwright](https://habr.com/ru/companies/selectel/articles/765012/)

____
tags: #git #CI/CD #deploy #devOps #gitFlow 

___

### [[007 Git|Назад]]