____

tags: #Docker #devOps

![](https://www.youtube.com/watch?v=_uZQtRyF6Eg)

_____
## Основы Docker

#Docker - клиент-серверное приложение, которое имеет набор готовых решений для разработки, реализующих упаковку, доставку и запуск приложения (например, веб-сервер, база данных MySQL и др.) со всеми зависимостями в любой операционной системе .

Docker является изолированной средой выполнения, то есть она не затрагивает работу операционной системы и её процессы.

Компоненты экосистемы docker можно разделить на 2 группы:
* системные компоненты ( #Docker-host #Docker-daemon #Docker-client #Docker-compose )
* переменные компоненты ( #Images #Containers #Registry #Dockerfile #Docker-compose-yaml)

## Системные компоненты

#Docker-host - это компьютер или вирутальный сервер, нак котором установлен docker . Мы запускаем docker, используя linux-дистрибутив #WSL .

#Docker-daemon - это центральный системный компонент , который управляет всеми процессами docker' а : создание образов, запуск и остановка контейнеров, скачивание образов. Работает Docker daemon как фоновый процесс (демон) и постоянно следит за состоянием других компонентов.

#Docker-client - это это утилита, предоставляющая API к докер-демону. Клиент может быть консольным (*nix-системы) или графическим (Windows).

## Переменные компоненты

### #Images (Образы)

Образ - это слепок, из которого собирается контейнер. Внутри образа хранится всё необходимое для запуска приложения, помещённого в контейнер: код, среда выполнения, библиотеки, переменные окружения и конфигурационные файлы.

Он создается для реализации какого-то одного конкретного функционала (например, развернуть веб-сервер или базу данных), результат слепка - виртуализация. На самом деле, можно реализовать несколько смыслов внутри одного образа, но это не рекомендуется делать, потому что возникнет путаница, да и это неудобно.

![[Pasted image 20230529222544.png]]
Рисунок 1 - Представление виртуализации в рабочем пространстве docker

Docker-образ создаётся с помощью команды `docker build`, которая считывает конфигурацию создаваемого образа из специального конфигурационного файла — dockerfile.

Тот , кто пользуется образом - не может изменить файлы внутри образа , они недоступны для изменения . Можно подумать об образе Docker , как о файлах, записанных на диске. Вы можете считать их или использовать, но изменить не сможете. #Images статичен.

#### #Layer (слой)

Каждый Image состоит из так называемых слоёв.

#Layer - это составная часть Docker Image, который содержит изменения файловой системы, внесённых в образ на этапе его создания. Все слои образа неизменяемы (block -- readonly).

Каждый образ - это набор слоёв . Каждый слой - это набор файлов или инструкций (запуск скрипта). Базовый слой - это запуск операционной системы . 

Когда Container запускается на основе Image, Docker объединяет все слои в одну файловую систему, которая представляет собой Container. Это позволяет контейнеру работать на основе определенного образа, который содержит все необходимые зависимости и настройки.

![[Pasted image 20230530003321.png]]
Рисунок 2 - Представление слоёв в рабочем пространстве docker


### #Containers (Контейнеры)

Контейнер - это запущенный образ или его instanse, который даёт возможность пользоваться всем предоставленным функционалом. Чтобы использовать функционал образа - нужно запустить контейнер на основе этого образа.

Вы можете запускать любое количество контейнеров на одном компьютере. 

В контейнер можно, что-то поместить (приложение с данными , операционную систему и прочее) и перемещать на нужные компьютеры.

![[Pasted image 20230529222050.png|1500]]
Рисунок 3 - Представление контейнера в рабочем пространстве docker

Для простоты понимания, #Images - это история до момента запуска, а #Containers во время запуска. 

### #Registry (Репозиторий)

Docker Registry - это сервер, который хранит Docker-образы (images) и позволяет их распространять между различными #Docker-host и #Containers . 

Registry может быть как публичным, так и частным, в зависимости от того, кто управляет образами и как они должны быть доступны.

Public Docker Registry - это публичный репозиторий, который содержит большое количество общедоступных Docker-образов, которые могут быть загружены и использованы любым желающим. Например, Docker Hub - это публичный Docker Registry, на котором можно найти тысячи образов, таких как операционные системы, базы данных, веб-серверы и многое другое.

![[Pasted image 20230530001548.png]]
Рисунок 4 - Представление Public Docker Registry в рабочем пространстве docker

Private Docker Registry - это частный репозиторий, который используется для хранения и управления Docker-образами, которые могут быть доступны только для определенных пользователей или организаций. Частный Registry может быть развернут как самостоятельный сервер или использоваться как облачный сервис.

Для загрузки образов в Registry используется команда `"docker push"`, которая отправляет образ на сервер. Для загрузки образов из Registry на хост или контейнер используется команда `"docker pull"`, которая загружает образ с сервера на локальный хост или контейнер.

Когда разработчик создает Docker-образ, он может сохранить его в локальном репозитории на своем хосте. Однако, если нужно использовать этот образ на другом хосте или поделиться им с другими разработчиками, то образ нужно загрузить в Registry.

Registry позволяет управлять версиями образов и контролировать доступ к ним для различных пользователей и групп. Также Registry может использоваться для автоматического обновления образов и контроля их безопасности.

В целом, использование Docker Registry упрощает процесс распространения и управления Docker-образами, что является важным элементом в разработке и развертывании приложений в контейнерах и в различных средах.

### #Dockerfile 

Dockerfile используется для автоматического создания образа на основе определенных инструкций и команд, которые описывают, какие компоненты и зависимости должны быть установлены в образе.

Dockerfile начинается с базового образа, который может быть операционной системой или другим образом. Затем в Dockerfile добавляются инструкции для установки и настройки необходимых компонентов, копирования файлов и настройки окружения.

Пример Dockerfile:

```
# базовый образ
FROM ubuntu:18.04

# установка зависимостей
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip

# копирование файлов
COPY . /app

# установка зависимостей Python
RUN pip3 install -r /app/requirements.txt

# запуск приложения
CMD ["python3", "/app/app.py"]
```

В этом примере Dockerfile использует базовый образ Ubuntu 18.04 и устанавливает Python 3 и pip. Затем копируется текущая директория внутрь образа в папку /app и устанавливаются зависимости Python из файла requirements.txt. Наконец, в команде CMD указывается, какой скрипт нужно запустить при запуске контейнера.

Dля создания Docker-образа на основе Dockerfile используется команда `docker build`, которая запускает процесс сборки образа на основе инструкций из Dockerfile. Пример команды:

```
docker build -t my_image:latest .
```

Здесь "-t" указывает имя тега для образа, "my_image" - имя образа, "latest" - тег образа, а точка в конце означает, что Dockerfile находится в текущей директории.

После того, как Dockerfile был создан и образ был собран, его можно использовать для создания и запуска Docker-контейнеров. Контейнеры создаются на основе образов и запускаются с помощью команды `docker run`.

## Рабочие процессы Docker

На рисунке 5 представлена упрощенная схема взаимодействия клиент-серверного приложения Docker.

![[Pasted image 20230529234116.png]]
Рисунок 5 - Взаимодействие Клиент/Демон/Репозиторий 

Взаимодействие между клиентом, daemon и registry происходит следующим образом:

1. Клиент отправляет запрос в #Docker-host для создания #Images или #Containers ;
2. Сервер обрабатывает запрос в #Docker-daemon , который выполняет команду и управляет созданием или запуском контейнера;
3. Если Images ещё не был создан, Docker daemon загружает зависимости и ресурсы из репозитория Docker, чтобы создать образ;
4. Docker daemon отправляет созданные Images в Docker Registry , где он может быть сохранён и использован позже;
5. Клиент может загружать Images из Registry или запускать Containers на основе уже созданных образов;
6. Клиент может отправлять команды Docker daemon  для управления контейнерами, образами и другими компонентами Docker.

#Docker-engine - это основной компонент Docker, который управляет контейнерами, образами и другими компонентами Docker. Docker Engine собирает воедино весь функционал Docker : 
Daemon + Cli (Клиентские запросы) + rest API + Extensions


## 1. Разворачиваем backend проект на Docker

Предполагается, что Вы уже воспользовались данной [[004 Как начать работать с проектом|инструкцией]] и установили #WSL , 
При установке WSL и #ubuntu возможна следующая [[Исправление ошибки WslRegisterDistribution в Ubuntu|ошибка]] .

1. Запускаем редактор кода #VSCode или #webstorm , запускаем Docker.
2. Переходим в корень вашего backend проекта и вбиваем в терминал скрипт:

```
docker compose up
```

Если видите такую картину, скрипт сработал, Docker запущен, а контейнер развернут.

![[Pasted image 20230530013004.png]]
Рисунок 6 - Запуск проекта

3. Переходим в Docker Images и запускаем backend

![[Pasted image 20230529003402.png]]

## 2. Как правильно обновить backend 

Предполагаю, что вы правильно клонировали бэк по [[004 Как начать работать с проектом|инструкции]] .

Допустим, ситуация, команда backend-разработчиков выкатила обновление проекта, а тебе необходимо обновить бэк для рефакторинга кода, что делать?

1. Переходим в корень нашего бэка и вводим в терминал команду:

```
git pull
```

Вответ получаем результат : __Already up to date__ - двигаемся дальше.

2. Переходим в Docker. Останавливаем и удаляем всё содержимое  #Containers #Images и Volumes , что принадлежат проекту.

![[Pasted image 20230530014353.png]]

Зачем? 
Когда описывал #Images , я рассказывал, что он статичен и, что, если он был однажды запущен, то мы можем только считать с него информацию, но не изменить.
В нашей ситуации , мы обновили бэк, содержимое изменилось, соответственно, необходимо заново запустить процесс создания контейнера на основе образа.

3. Вернёмся к пункту _2. Разворачиваем backend проект на Docker_ 

Поздравляю ! Вы успешно обновили backend и поняли основы работы в Docker !