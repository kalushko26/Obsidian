### Ответ

Их довольно много, но их можно обойти.

**Возможен vendor lock**. Например, два приложения подтягивают общую компоненту. Если они завязаны на определенную версию библиотеки, то можно оказаться в зависимости от этой версии: не сможем обновиться на Host-приложении.

**Слёзы и нервы при разработке/дебаге/поставке**: у нас два разных компонента, которые нужно ставить в продакшн, иногда одновременно, иногда отдельно. Нужны новые подходы с деплоем

**С тестированием пока всё сложно.** Если поменять интерфейс выставленного модуля, то приложение сломается. Последствия изменений такие же, как если бы мы поменяли схему своего REST API. Например, если мы поменяли React-компонент, изменили API, то и Host-приложение может сломаться, потому что завязано на старое API.

Пока схема тестирования такая:
- В модули выносятся только те компоненты, которые можно протестировать самостоятельно, вне иного контекста.
- Каждый модуль тестируется либо unit-тестом, либо Cypress тестом (Cypress фреймворк для Ent-to-End тестирования).
- Также есть интеграционные тесты которые охватывают сразу все приложения и тестируют загружаемые модули.

**Можно увлечься и наимпортировать вагон интерфейсов и библиотек**. Когда мы импортируем шареный модуль, все импорты, которые там используются, тоже попадают в импорт. Можно попасть в такую ситуацию, когда у нас наимпортирована гора библиотек из Remote-приложения.

**SSR есть, но его трудно реализовать**. По SSR уже есть [React 18](https://blog.saeloun.com/2021/07/29/react-18-alpha-behavior-changes-in-suspense) альфа-версия, которая поддерживает асинхронную гидрацию.

**Есть проблемы с асинхронным запуском**. Это bootstrap file, к фреймворку не имеет отношения. Если захотите поэкспериментировать, то прикладываю видео, где Зак [рассказывает как его реализовать](https://youtu.be/d1SS7KAsbdY?t=345).

___
tags: #webpack #module-federation #microfrontend 