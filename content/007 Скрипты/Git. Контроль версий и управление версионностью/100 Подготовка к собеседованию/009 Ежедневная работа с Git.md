____

tags: #Git #Gitlab #git-push #git-pull #git-rebase #git-merge #git-revert 

links: [[001 Git. Инструмент управления версиями]]

___

В данном wiki я постараюсь ответить на следующие вопросы:

1. Зачем делать `commit` в ветке проекта в конце рабочего дня?
2. Как и когда надо обновлять `main` ветку проекта?
3. В чем отличие `git rebase` от `git merge`?
4. Как синхронизировать изменения из одной рабочей ветки в другую?
### Зачем делать commit в ветке задачи (task) в конце рабочего дня?

Допустим вы взяли в работу task. 
Создали отдельную от main ветку и стали писать код. Что делать в конце рабочего дня?

Правильно!

```bash
git push
```

Создание коммита по окончанию дневной работы над проектом несёт ряд преимуществ:
1. *Сохранение текущего состояния проекта:* Вы избегаете риска потери важной информации, если что-то случится с вашим компьютером или веткой проекта.
2. *Хранение изменений в коммитах позволяет лучше разделять работу и получать более чёткие истории изменений.*
3. Если в процессе разработки, что-то пошло не так: обнаружили ошибку или проблему, которую необходимо исправить, но не хотите терять все изменения внесённые в течение дня, то вы можете использовать команду `git revert` для отмены последнего коммита и возврата к предыдущему состоянию ветки.
4. Так как разработчики зачастую работают в команде, создание коммита помогает другим разработчикам понять, что вы закончили работу и что в вашей ветке есть важные изменения, которые могут быть включены в общую ветку проекта. Это позволяет более эффективно координировать работу в команде и избежать конфликтов при слиянии веток.

### Зачем обновлять `main` ветку проекта ?

Рабочий день окончился, вы выключили компьютер, завтра вы начнёте с того места, на котором остановились. С чего мы начнём? - Мы подгрузим изменения с gitLab в нашу локальную ветку main, используя команду:

```bash
git pull
```

Так как мы выполняем task, то для неё мы сделаем дополнительно:
```bash
git rebase
```

В зависимости от задач можно использовать `git merge`

Если сделали какие-то изменения в коде, отправьте коммиты в свою ветку на gitLab, не должно быть такой ситуации, что вы сделал сделали один коммит с полной выполненной задачей, где изменений на миллиард строк, которые будем разбирать командой несколько лет). Задача должна быть разбита на коммиты, а коммиты должны быть атомарными

### В чём отличие `git rebase` от `git merge` ?

Подробнее про [[010 Как создать Merge Request|Git merge]]
Подробнее про [[011 Git Rebase|Git rebase]]

При использовании `git merge` создается новый коммит с объединенными изменениями, который имеет двух родителей, и история коммитов становится более ветвистой. Это полезно, если вы хотите сохранить историю разных веток и хранить их изменения отдельно.

При использовании `git rebase` вы переносите все ваши изменения из текущей веткина вершину другой ветки, а затем создается новый коммит, который содержит все изменения из обеих веток. Это позволяет создавать более линейную историю коммитов, что облегчает отслеживание изменений и упрощает работу с командой.

Решение конфликтов: При использовании `git merge` конфликты, если они возникают, решаются в отдельном коммите, который содержит изменения из обеих веток, а при использовании `git rebase` конфликты разрешаются на лету, когда Git переносит изменения из одной ветки в другую.

### Как синхронизировать изменения из одной рабочей ветки в другую?

Например, ты отправил на код-ревью первую таску , её еще не объединили с main - веткой, а тебе нужно подгрузить изменения с неё (синхронизировать код между двумя рабочими ветками), что делать? 

Используем команду `git rebase`. Эта команда переносит изменения из одной ветки в другую, переписывая историю коммитов в процессе. Например, если вы хотите перенести изменения из ветки `kalushko-feature-popover` в ветку `kalushko-refactor-pagination`, вы можете выполнить следующие команды:

```bash
git checkout kalushko-feature-popover
git rebase kalushko-refactor-pagination
```

Первая команда `git checkout kalushko-feature-popover` переключает вас на ветку `kalushko-feature-popover`. Затем команда `git rebase kalushko-refactor-pagination` переносит изменения из `kalushko-feature-popover` в `kalushko-refactor-pagination`. 

Необходимые изменения подгрузились в новую рабочую ветку и ты можешь продолжить работу над проектом.

____
tags: #git 

___

### [[007 Git|Назад]]