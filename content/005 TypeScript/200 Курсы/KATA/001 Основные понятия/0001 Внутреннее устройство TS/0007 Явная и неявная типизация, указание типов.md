____

tags: #TypeScript #type #aliases

keywords:

_____

## База работа с типами в TS

Тип - это набор значений
В JS всего 8 типов: [[1.1 Типы данных]]

1. TS добавляет слой статических типов
2. Типы существуют при компиляции или проверке исходного кода
3. Каждое место хранения данных имеет статический тип
4. Тип определяет возможные динамические значения.
5. Проверка типов гарантирует, что значения всегда будут соответствовать "прогнозу"
6. Проверка случится ещё до запуска кода

### Аннотация типов

Как сказать, что та или иная сущность принадлежит конкретному типу.
~~~typescript
let x: number;
~~~

TS не читает x, пока мы не назначим ему значение.
В большинстве случаев TS корректно определяет тип.

### Определения типа через выражения

Аннотация типа бывает сложносоставной
При необходимости использовании нескольких вариантов типов для переменной используется оператор |

### Псевдоним типа ( #aliases )

При частом использовании составного типа, ему задают псевдоним
~~~typescript
type Score = number | string
const myScore: Score = 7
~~~
или
~~~typescript
type Score = number | string
const myScore1: Score = '10';
~~~

Имена псевдонимов, как правило, с больших букв.

### Когда аннотация действительно нужна ?

Когда функция возвращает тип any и мы хотим уточнить значение
Когда объявление переменной и присвоение ей значения происходит в разных строчках
Когда мы хотим, чтобы тип был сложносоставной и неопределялся автоматически

## Явная и неявная типизация, указание типов

Мы можем указать тип переменной явно с помощью следующего синтаксиса:

```typescript
let message: string = '5'
```

Объявленная переменная будет иметь тип string, и при попытке присвоить в нее значение другого типа мы получим ошибку.  
   
Несколькими уроками ранее мы говорили, что не всегда нужно явно указывать тип данных. Одна из важнейших концепций TS **—** автоматическое выведение типов.

```typescript
const something = false; // TS: boolean
let message = "hello!"; // TS: string
message = 5;
```

В указанном выше примере мы не задали типы переменным. Тем не менее, TS сам вывел их на основании того, какое значение им было присвоено. При попытке переопределить message значением типа “number” мы получим следующую ошибку:  

![](https://platform.kata.academy/uploads/2022/7/9/Screenshot%202022-08-09%20at%2019.25.23_18_25_44.png)  
  
С помощью механизма автоматического выведения типов мы получаем ряд удобств —
-   Нам не нужно писать слишком много типов вручную: достаточно описать тип в одном месте переданным значением или аннотацией типа и TS сделает всю остальную работу за нас, корректно выводя типы при дальнейшем использовании этой переменной в коде.
-   Мы можем легко изменять типы в одном месте за счет того, что типы не дублируются повсеместно. Если мы изменим тип в изначальном объявлении на некорректный, то во всех местах, где использовалась эта переменная, автоматически выведется новый тип, что может привести к ряду ошибок, по которым мы сможем легко найти места в коде, которые нужно исправить. 

Было до рефакторинга:

```typescript
let message = "hello!"; // TS: string
const anotherMessage = message // TS: string
console.log(anotherMessage.toUpperCase())
```

Стало после рефакторинга:

```typescript
let message: { text: string } = { text: “hello!” }; // TS: string
const anotherMessage = message // TS: string
 console.log(anotherMessage.toUpperCase())
```

Возникла ошибка:

![](https://platform.kata.academy/uploads/2022/7/9/Screenshot%202022-08-09%20at%2019.27.59_18_28_20.png)
