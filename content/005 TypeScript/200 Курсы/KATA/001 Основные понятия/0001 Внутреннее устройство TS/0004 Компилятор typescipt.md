____

tags: #TypeScript #tsconfig

keywords:
В компиляторы представлены 6 блоков для редактирования:

* #extends говорит о том, что наш config может быть разбит на части;
* #files подходит для небольших проектов
* #include #exclude - путь для компиляции // исключить из компиляции
```json
"include": ["src"],
"exclude": [
	"node_modules",
	"src/**/*.stories.*",
	"src/**/mock/*"
],

"extends": "./tsconfig.json" // Например

```
* #compilerOprions представлены настройки компилятора
* #references 
* #typeAcquisition 

_____

TypeScript помогает нам отлавливать ошибки **—** это здорово, но еще лучше то, что он позволяет нам избегать ошибок. #компилятор-TS знает:
-   какие свойства и методы есть у объекта; 
-   какой тип данных у переменной; 
-   какие аргументы нужно передать функции и т.д.. 

Поэтому он подсказывает эту информацию в момент написания кода. Для этого нам нужен только TS и IDE, которая его поддерживает. #TypeScript будет передавать #IDE информацию о типах, а IDE, в свою очередь, отобразит необходимые подсказки.  
   
Рассмотрим следующий пример:  

![](https://platform.kata.academy/uploads/2022/7/9/Screenshot%202022-08-09%20at%2019.16.12_18_17_56.png)  

В момент написания кода IDE уже подсказала нам, какие методы есть у объекта res. 

Если мы попытаемся обратиться к методу, которого не существует, первым признаком ошибки для нас будет отсутствие подсказки. Если нас это не остановит, и мы введем название несуществующего метода, IDE мгновенно покажет нам ошибку о том, что такого метода нет. 

Нам не нужно даже компилировать проект, чтобы найти ошибку **—** мы видим ее на лету:  

![](https://platform.kata.academy/uploads/2022/7/9/Screenshot%202022-08-09%20at%2019.19.48_18_20_12.png)

Как указывалось ранее, TS **—** компилируемый язык. 
Результатом его компиляции является JS код.  
   
Этап компиляции нам необходим по той причине, что браузеры не могут исполнять 
TS **—** синтаксис этого языка им непонятен. 

Мы преобразуем TS в JS с помощью #aot (ahead-of-time) компиляции **—** этот этап полностью проходит перед исполнением. TS не компилируется и не исполняется в браузере, в момент исполнения наша программа для браузера выглядит как обычный JS код.  
   
Типы TS существуют исключительно на этапе разработки и используются только для нахождения ошибок до исполнения программы, поэтому не следует ожидать, что типы, указанные вами в коде, будут соблюдаться в runtime. Вся информация о типах теряется на стадии компиляции, и браузер уже ничего не знает о типах. Если ваш код удачно скомпилирован в JS, далее на TS полагаться не нужно **—** его типов в коде уже не существует. По этой же причине типы TS никак не влияют, к примеру, на результат JS оператора typeof и не могут ни основываться на том, что происходит в runtime, ни быть использованы там.  
   
Основная задача компиляции TS **—** получение списка ошибок типов в коде и удаление информации о типах, чтобы подготовить код для исполнения браузером. Побочная задача **—** преобразование JS кода в код других версий ECMAScript. 
