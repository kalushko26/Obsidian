---
title: REST API. Что такое ресурс, ограничения, идемпотентность и кэширование?
draft: false
tags:
  - rest
  - RESTful
  - API
  - HTTP
  - HTTP-метод
info:
  - "[[0094 REST простыми словами|REST]]"
---
*REST (Representational state transfer)* — общие принципы организации взаимодействия приложения/сайта с сервером по HTTP. Сервер не запоминает состояние пользователя между запросами. _В запросах передаётся информация, идентифицирующая пользователя (например, токен ) и параметры для выполнения операции._

Rest позволяет:

- Масштабируемости взаимодействия компонентов системы (приложения)
- Общность интерфейсов
- Независимое внедрение компонентов
- Промежуточные компоненты, снижающие задержку, усиливающие безопасность

Применяется, когда:
• Когда есть ограничение пропускной способности соединения
• Если необходимо кэшировать запросы
• Если система предполагает значительное масштабирование
• В сервисах, использующих AJAX

Чтобы распределенная система считалась сконструированной по REST архитектуре ( Restful ), необходимо, чтобы она удовлетворяла следующим критериям:

1.  **Client-Server.** *Система должна быть разделена на клиентов и на серверов.* Разделение интерфейсов означает, что, например, клиенты не связаны с хранением данных, которое остается внутри каждого сервера, так что мобильность кода клиента улучшается. Серверы не связаны с интерфейсом пользователя или состоянием, так что серверы могут быть проще и масштабируемы. Серверы и клиенты могут быть заменяемы и разрабатываться независимо, пока интерфейс не изменяется.
2.  **Stateless.** *Сервер не должен хранить какой-либо информации о клиентах.* В запросе должна храниться вся необходимая информация для обработки запроса и если необходимо, идентификации клиента.
3.  **Cache․** *Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.*
4.  **Uniform Interface.** *Единый интерфейс определяет интерфейс между клиентами и серверами.* Это упрощает и отделяет архитектуру, которая позволяет каждой части развиваться самостоятельно.

**ВАЖНО!** *Сама архитектура REST не привязана к конкретным технологиям и протоколам*, но в реалиях современного Веб, построение RESTful API почти всегда подразумевает использование HTTP и каких-либо распространенных форматов представления ресурсов, например JSON, или, менее популярного сегодня, XML.

###### Ресурс

_Ресурс_ — это ключевая абстракция, на которой концентрируется протокол HTTP. Ресурс — это все, что вы хотите показать внешнему миру через ваше приложение. Например, если мы пишем приложение для управления задачами, экземпляры ресурсов будут следующие:

- Конкретный пользователь
- Конкретная задача
- Список задач

**URI ресурса**

Когда вы разрабатываете RESTful сервисы, вы должны сосредоточить свое внимание на ресурсах приложения. Способ, которым мы идентифицируем ресурс для предоставления, состоит в том, чтобы назначить ему URI — универсальный идентификатор ресурса. Например:

- Создать пользователя: POST /users
- Удалить пользователя: DELETE /users/1
- Получить всех пользователей: GET /users
- Получить одного пользователя: GET /users/1

**REST и Ресурсы**

Важно отметить, что с REST вам нужно думать о приложении с точки зрения ресурсов:  
Определите, какие ресурсы вы хотите открыть для внешнего мира  
Используйте глаголы, уже определенные протоколом HTTP, для выполнения операций с этими ресурсами.

Вот как обычно реализуется служба REST:

- **Формат обмена данными**: здесь нет никаких ограничений. JSON — очень популярный формат, хотя можно использовать и другие, такие как XML
- **Транспорт**: всегда HTTP. REST полностью построен на основе HTTP.
- **Определение сервиса**: не существует стандарта для этого, а REST является гибким. Это может быть недостатком в некоторых сценариях, поскольку потребляющему приложению может быть необходимо понимать форматы запросов и ответов. Однако широко используются такие языки определения веб-приложений, как WADL (Web Application Definition Language) и Swagger.

REST фокусируется на ресурсах и на том, насколько эффективно вы выполняете операции с ними, используя HTTP.

###### Ограничения

REST определяет 6 ограничений для достижения желаемой оптимизации системы

1. _Клиент-сервер_
   Это ограничение основано на принципе разделения интересов.
   Это позволяет компонентам развиваться независимо. Создавая наш API, он действует как сервер, обслуживающий большое количество клиентов.

2. _Без гражданства_
   Связь между клиентом и сервером должна быть без гражданства. Это означает, что каждый запрос от клиента к серверу должен содержать всю необходимую информацию для завершения транзакции.

Основным преимуществом этого ограничения является то, что система способна масштабироваться лучше, потому что серверу не нужно сохранять состояние клиента между запросами. Отсутствие необходимости запоминать информацию о состоянии клиента освобождает ресурсы сервера, поэтому он может обслуживать больше клиентов одновременно.

3. _Кэш_
   Наиболее эффективным сетевым запросом является тот, который не использует сеть.
   Когда мы создаем наш API, он не должен игнорировать кеширование.

4. _Правильный интерфейс_
   Чтобы иметь эффективное кэширование в сети, компоненты должны иметь возможность взаимодействовать через единый интерфейс. С единым интерфейсом полезная нагрузка может передаваться в стандартной форме.
   4.1. Идентификация ресурсов
   Это означает, что любая информация, которая может быть названа, может быть ресурсом (изображение, документ или даже набор других ресурсов)
   4.2. Манипулирование ресурсами через представления
   Ресурс может быть представлен различными способами.
   Например, HTML, XML, JSON или даже JPEG-файл.
   Это правило означает, что клиенты взаимодействуют с ресурсами через свои представления, что является мощным средством удержания абстрактных понятий ресурсов от их взаимодействий.
   4.3 В-третьих, самоописательные сообщения
   Это означает, что ресурс может быть описан в сообщении запроса, а сервер может отвечать описательными сообщениями о состоянии. Да, HTTP-заголовки и коды ответов являются хорошими реализациями для этого правила.
   4.4. Hypermedia должна быть двигателем состояния приложения
   Это на самом деле означает, что приложение должно управляться ссылками, позволяя клиентам обнаруживать ресурсы через гиперссылки.
   Как вы можете видеть, многие из этих правил могут быть реализованы в протоколе HTTP. Поэтому, когда API использует HTTP правильно, это огромный шаг к тому, чтобы стать RESTful.

5. _Многоуровневая система_
   В многоуровневой системе посредники, такие как прокси-серверы, могут размещаться между клиентом и сервером, используя единообразный интерфейс сети.

Одним из преимуществ многоуровневой системы является то, что посредники могут затем перехватывать трафик клиент-сервер для определенных целей/ Например, для кэширования.

6. _Код по требованию_
   Это необязательное ограничение и позволяет клиентам загружать программы для выполнения на стороне клиента. Лучший пример для этого - интерфейсные JavaScript-приложения. Это может показаться нам сейчас очень очевидным, но в раннем возрасте Интернета это была эволюционирующая концепция, и это полезная часть интернет-архитектуры.

###### Идемпотентность

С точки зрения RESTful-сервиса, операция (или вызов сервиса) идемпотентна тогда, когда клиенты могут делать один и тот же вызов неоднократно при одном и том же результате на сервере. Другими словами, создание большого количества идентичных запросов имеет такой же эффект, как и один запрос. Заметьте, что в то время, как идемпотентные операции производят один и тот же результат на сервере, ответ сам по себе может не быть тем же самым (например, состояние ресурса может измениться между запросами).

Методы **PUT** и **DELETE** по определению идемпотентны. Тем не менее, есть один нюанс с методом DELETE. Проблема в том, что успешный DELETE-запрос возвращает статус 200 (OK) или 204 (No Content), но для последующих запросов будет все время возвращать 404 (Not Found), Состояние на сервере после каждого вызова DELETE то же самое, но ответы разные.

Методы **GET**, **HEAD**, **OPTIONS** и **TRACE** определены как безопасные. Это означает, что они предназначены только для получения информации и не должны изменять состояние сервера. Они не должны иметь побочных эффектов, за исключением безобидных эффектов, таких как: логирование, кеширование, показ баннерной рекламы или увеличение веб-счетчика.

По определению, **безопасные операции идемпотентны**, так как они приводят к одному и тому же результату на сервере. Безопасные методы реализованы как операции только для чтения. Однако безопасность не означает, что сервер должен возвращать тот же самый результат каждый раз.

###### Кэширование

- _Self-descriptive messages (само-документируемые сообщения)_. Под само-описательностью имеется ввиду, что запрос и ответ должны хранить в себе всю необходимую информацию для их обработки. Не должны быть дополнительные сообщения или кэши для обработки одного запроса. Другими словами отсутствие состояния, сохраняемого между запросами к ресурсам. Это очень важно для масштабирования системы.
- **Cache․** Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.

---

[[200 Браузерное окружение|Назад]]