---
title: Практические вопросы по typescript
draft: false
tags:
  - TypeScript
---

### 1 Что требуется для ввода числа countWheels в коде приведенном ниже?

~~~ts
interface Vehicle {  
	countWheels(this: Vehicle): () => number;  
}
~~~

Требуется, чтобы countWheels вызывался объектом типа Vehicle.

### 2 Правда или ложь? 

~~~ts
interface Window {  
  name: string;  
}

interface Window {  
  app: string;  
}
~~~

Правда. У interface теперь есть и name, и app.

### 3 Как вы ограничиваете значения, которым может быть присвоена строка?

~~~ts
let stringOptions: ‘optOne’ | ‘optTwo’;
~~~

Просто определите точные строковые значения, которые могут быть присвоены объекту или переменной. Например:

### 4 Что делает ключевое слово #void для функций, когда оно назначается в качестве их возвращаемого значения? Что делает void при использовании в качестве типа переменной?

Когда используется в качестве типа возвращаемого значения, это означает, что нет возвращаемого значения. 

Когда используется в качестве типа переменной, код компилируется, но это бесполезно.

### 5 Каково преимущество использования #generic перед использованием #any?

#generic сохраняют информацию. 
Например, если строка передается в качестве параметра generic, и функция возвращает generic param, то любая вызывающая функция знает, что она получит строку в качестве типа возвращаемого значения.

Еще одна причина заключается в том, что функция может требовать, чтобы переданный generic был расширением интерфейса. Это позволяет гарантировать, что переданный generic должен иметь определенные функции на нем.

### 6 Как называется функция TypeScript, которая позволяет значению быть (например) либо числом, либо строкой?

#union types

### 7 Правда или ложь? 

~~~ts
interface Dog{  
	hair: boolean;  
	bloodType: 'warm';  
}  

interface Snake{  
	scales: boolean;  
	bloodType: 'cold';  
}  

const myCreature = (creature: Dog | Snake) => {  
	console.log(creature.scales);  
}
~~~

False. 
При использовании объединения типов (union types) доступны только общие члены обоих полей.

### 8 Как создать массив, у которого удалены все методы изменения?

Используйте тип #ReadonlyArray 

```ts
let readOnly: ReadonlyArray<string> = ['a','b','c'];
readOnly.push('d'); // Ошибка компиляции
```

### 9 Покажите синтаксис для преобразования 'object' из его существующего типа в строку

`object as unknown as string`.  

Пример использования этого приема - когда вы получаете данные из конечной точки (endpoint) или плохо типизированной библиотеки.

### 10 Как называется техника, при которой вы используете одно поле литеральных типов, чтобы позволить TypeScript сузить возможный текущий тип?

Discriminating #unions (различающие объединения).

### 11 Какой тип возвращается по умолчанию для функции ниже?

```ts
function iFailed() {
  return error("I failed");
}
```

Тип #never

### 12 Если `strictNullChecks` выключен, почему `null` и `undefined` могут быть присвоены переменной типа `string` или `number`?

`null` и `undefined` являются подтипами всех других типов

### 13 Правда или ложь? Оставшиеся параметры ( #rest params) не нужно явно указывать или типизировать в TypeScript?

False. Оставшиеся параметры должны быть обязательно типизированы, например: `...rest: string[]`.

### 14 Правда или ложь? Две следующих приведенных ниже функции имеют одинаковый тип?

~~~ts
function cityState(city: string, state = "Smith") {...}
function cityState(city: string, state? = "Smith") {...}
~~~

True. Параметры по умолчанию являются необязательными.

### 15 Оцените код ниже. Правда или ложь? Значение 'name' в 'person' может быть любым строковым значением

```ts
interface A {
    name: string;
    age: number;
}
interface B {
    name: 'Jon' | 'Jim';
    address: string;
}
// constperson: B & A
```

False. Он должен быть 'Jon' или 'Jim'. Порядок пересечения типов не имеет значения.

### 16 Создайте интерфейс `APIData`, который имеет неизвестное количество ключей и ограничивает значения типами "string" или "number"

```ts
interface APIData {
  [key: string]: string | number
}
```

### 17 Как можно гарантировать, что функция, принимающая обобщенный параметр, будет работать с типами, имеющими свойство `.add`?

```ts
interface Adder {
  add: number;
}

function counter<T extends Adder>(arg: T): T {...}
```

### 18 Какие две причины могут побудить разработчика использовать перечисления ( #enums )?

Для документирования намерений или создания набора отдельных случаев.

### 19 Почему вы можете ограничить тип свойства значением `true`?

Вы можете использовать это для ограничения значений объекта, связанных с типами свойств, которые взаимосвязаны, например:

```ts
interface CallSuccess {
  success: true;
  error: null;
};
interface CallFailure {
  success: false;
  error: string;
};
```

### 20 В чем разница в типе между двумя указанными ниже переменными?

```ts
const myConst = "Hello";
let myLet = "Hello";
```

`myConst` имеет тип "Hello", а `myLet` имеет тип `string`. Это связано с тем, что значение `myLet` может измениться, поэтому тип должен быть более общим.

### 21 Что такое кортеж #tuple ?

Кортеж - это массив с фиксированным количеством элементов, типы которых известны и могут быть одинаковыми или разными.

### 22 Как можно расширить типы?

Напрямую нельзя, но можно через пересечение ( #intersection ), т.е.:
~~~ts
type MotorVehicle = {  
	wheels: number;  
}  

type Car = MotorVehicle & {  
	make: string;  
}  

const car: Car = {  
	wheels: 4,  
	make: 'Toyota'  
}
~~~

### 23 Какой однострочный #typeguard для типов null?

~~~ts
function myFunc(str: string | null): string {  
	return str || 'str was null';  
}
~~~

### 24 Какое значение по умолчанию у необязательного параметра?

Значение по умолчанию - undefined.

### 25 Приведите пример проверки типа объекта.

~~~ts
interface Motorcycle {  
	wheels: string;  
}  

interface Car {  
	windshieldWiperBrand: string;  
}  

function isCar(vehicle: Car | Motorcycle): vehicle is Car{  
	return (vehicle as Car).windshieldWiperBrand !== undefined;  
}
~~~

### 26 Что такое #union Exhaustiveness Checking?

#union Exhaustiveness Checking - это проверка на покрытие всех вариантов дискриминирующего объединения (discriminated union). Например, оператор switch, который проверяет все возможные значения свойства объекта, исчерпывающим образом проверил объединение.

### 27 В чем разница между string[] и [string]?

`string[]`- это массив, который может содержать только строки и имеет неопределенную длину.

`[string]` - это кортеж. 
В этом случае он может содержать только одну строку, но (например) [string, number] позволит ему содержать строку и число. Тип и длина оба фиксированы.

### 28 Что такое #type-assertion и как выглядит его синтаксис?

Type assertion - это оповещение компилятора о том, что объект или переменная имеют определенный тип. Синтаксис может быть таким:

~~~ts
let char0: string = (someValue as string).charAt(0);  
let char0: string = (<string>someValue).charAt(0);
~~~

### 29 Какой единственный синтаксис type assertion совместим с JSX?

JSX требует синтаксис #as для type assertion.

### 30 Что делает #assertNever ?

Он проверяет объект и возвращает true, если тип является #never

### 31 Будет ли скомпилирован следующий код?

~~~ts
declare const iDontKnow: unknown;  

if (typeof iDontKnow === string) {  
	const aString: string = iDontKnow;  
}
~~~

Он не скомпилируется. 
#typeof возвращает строковое значение, в данном случае typeof iDontKnow возвращает значение «string». В остальном код выше в порядке. unknown может быть типом string, и проверка if позволяет iDontKnow присваиваться константе string.

### 32 Как можно типизировать массив объектов, у которых неизвестное количество ключей и значения типа number?

~~~ts
obj: { [key: string]: number }[];
~~~

### 33 Рекомендуется ли TypeScript использовать объекты Number, String и Boolean или примитивы number, string и boolean?

TypeScript рекомендует восновном использовать примитивы. 
См. здесь рекомендации документации.

### 34 Правда или ложь? TypeScript может выводить типы (называемый контекстным типизированием) как для примитивных переменных, так и для функций?

Ответ - верный. Вы можете явно указать тип функции, но компилятор легко выводит тип из назначенного значения функции. 

Читайте здесь для получения более подробной информации.

### 35 Почему разработчику следует избегать использования типа #any ?

Хотя может быть несколько ответов на этот вопрос, "any" в основном следует избегать, потому что теряется типовая безопасность.

Другие возможные ответы могут включать: теряется информация о типах, с которыми вы работаете, другие разработчики теряют метаданные о вашем коде, TypeScript устанавливает правила, чтобы избежать ошибок, и вы не должны обходить эти правила и т.д.

### 36 Правда или ложь? Два типа подряд могут быть объявлены для одной и той же функции, как в приведенном ниже примере

~~~ts
function summingFunction(x: number, y: number): number;  
function summingFunction(x: number, y: number, z: string): {value: number; name: string};
~~~

Ответ - верный. Это называется перегрузкой ( #overload ). 
Перегрузка - это распространенный шаблон в JavaScript; иногда разработчик будет передавать в одну и ту же функцию разные наборы параметров и ожидать разных возвращаемых значений.

### 37 Приведите пример класса, который получает обобщенный тип параметра

~~~ts
class MyClass<T> {...}
~~~

### 38 Приведите пример функции, в которой один типовой параметр ограничен другим типовым параметром

~~~ts
function getString<T, S extends keyof T>(obj: T, key: S) {  
    return obj[key];  
}  

let strObject = { a: 'my', b: 'string', c: 'example' };  
    
getString(strObject, 'a'); 
// возвращает 'my'  
    
getString(strObject, 'd'); 
// ошибка компиляции, так как 'd' не является ключом объекта strObject
~~~

В этом примере типовой параметр S ограничен типовым параметром T, который используется как тип объекта, передаваемого в функцию. Ограничение S extends keyof T гарантирует, что переданный ключ key является ключом объекта T.

### 39 Приведите пример обобщенного типа, ограниченного интерфейсом

~~~ts
interface Currency {  
	name: string;  
	value: number;  
}  

interface Coins extends Currency {  
	material: string  
}  

function printValue<T extends Currency>(currency: T): void {  
	console.log(currency.value);  
}  

let dime: Coins = {  
	name: 'Dime',  
	value: 0.10,  
	material: 'metal'  
}

printValue(dime);
~~~

### 40 В примере из вопроса 39, будет ли скомпилирован код, если вызвать printValue с параметром типа Currency, но не типа Coins?

Будет. 
T extends Currency, и это означает, что T может быть типом Currency, а также чем-то, что расширяетCurrency. См. ниже:

### 41 Правда или ложь? В примере из вопроса 39 код будет скомпилирован, если вызвать printValue с нижеуказанным объектом (dollar).

~~~ts
interface Paper {  
	name: string;  
	value: number;  
	personPictured: string;  
}  

let dollar: Paper = {  
	name: 'Dollar Bill',  
	value: 1,  
	personPictured: 'George Washington'  
}  
~~~

Верно. 
Несмотря на то, что Paper явно не расширяет Currency, он удовлетворяет типовым свойствам Currency. Поэтому dollar может быть передан как объект типа Currency.

### 42 Поддерживает ли TypeScript типы числовых литералов?

Да. 
Ниже приведен пример использования.
~~~ts
interface Student {  
	grade: 1 | 2 | 3 | 4;  
	name: string;  
}
~~~

### 43 Что делает модификатор #protected для свойства класса?

Он ограничивает доступ к этому члену только для классов, производных от (расширяющих) родительский класс.

### 44 Правда или ложь? Абстрактные классы не могут содержать конкретные методы

Неверно. 
Абстрактные классы не могут быть инстанцированы непосредственно, но они могут содержать конкретные методы (методы с деталями реализации), которые будут унаследованы производными классами.

### 45 Каково значение Compass.South в приведенном ниже коде?

~~~ts
enum Compass {  
	North,  
	East,  
	South,  
	West  
}  
~~~

Compass.South равен 2. 
Перечисления по умолчанию начинаются с 0 и автоматически увеличиваются на 1.

### 46 Какова сигнатура метода console.log, когда TypeScript включен?

~~~ts
Console.log(...data: any[]): void  
~~~

Встроенные функции JavaScript типизированы в TypeScript.

### 47 Правда или ложь? Следующий код не cкомпилируется.

~~~ts
enum Compass {  
	North = 0,  
	East= '1',  
	South = 2,  
	West = '3'  
}  
~~~

Неверно, он компилируется. Перечисления могут быть смесью строковых и числовых значений.

### 48 Правда или ложь? #super() должен быть вызван до доступа к свойству this в теле конструктора, если класс расширяет другой класс.

Верно.

### 49 Предположим, что Car расширяет MotorVehicle. Правда или ложь? Следующий код компилируется

~~~ts
let prius: MotorVehicle = new Car(); 
~~~

Верно. Поскольку MotorVehicle является родительским классом Car, prius может быть инициализирован как Car, и это все еще будет тип MotorVehicle.

### 50 Правда или ложь? Модификатор #protected не может быть использован в конструкторе базового класса?

Неверно. Модификатор 'protected' может быть использован в конструкторах и предотвращает создание экземпляра класса другими классами, которые не являются егонаследниками.
