{
	"nodes":[
		{"type":"text","text":"## Что такое `this` ?\n\n`this` - это ключевое слово, которое ссылается на объект, в контексте которого был вызван код. Значение `this` зависит от того, как был вызван код, и может изменяться в разных контекстах.","id":"79c3892d8f230b62","x":-560,"y":-900,"width":601,"height":209,"color":"3"},
		{"type":"text","text":"#### Как определить значение `this`?\n\nНиже алгоритм, который поможет принять верное решение","id":"05d1e6ff66d23220","x":-560,"y":-580,"width":601,"height":120,"color":"4"},
		{"type":"text","text":"##### 1. Мы находимся внутри функции?","id":"2d8cf689542f11ce","x":-560,"y":-360,"width":601,"height":60,"color":"2"},
		{"type":"text","text":"##### 2. Мы находимся внутри стрелочной функции?","id":"a93e4e9b614cc72a","x":-560,"y":-40,"width":601,"height":60,"color":"2"},
		{"type":"text","text":"значение `this` такое же, как и в функции на уровень выше (т.е. содержащей данную). Вернитесь на предыдущий шаг и повторите алгоритм для неё. Если же функция не содержится ни в какой другой, `this` — глобальный объект.\n\n```javascript\nconst obj = {\n  name: 'John',\n  age: 30,\n  greet: () => {\n    console.log(`My name is ${this.name} and I'm ${this.age} years old`);\n  }\n};\n\nobj.greet(); // Output: My name is undefined and I'm undefined years old\n```\n\n##### Комментарий\nОдна из основных особенностей стрелочных функций — это так называемый «лексический `this`». Это значит, что значение `this` в стрелочной функции определяется исключительно тем, где (в каком лексическом контексте) она была создана, и никак не зависит от того, как впоследствии она была вызвана. Иногда это не то, что нам нужно, но чаще всего это делает стрелочные функции очень удобными и предсказуемыми.","id":"88d3f5f438577ccf","x":-1340,"y":-40,"width":601,"height":742},
		{"type":"text","text":"##### 3. Эта функция вызвана как конструктор?","id":"1964e507f8d51462","x":-560,"y":280,"width":601,"height":60,"color":"2"},
		{"type":"text","text":"`this` ссылается на новый объект, находящийся «в процессе конструкции»\n\n```javascript\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nconst person1 = new Person('John', 30);\nconsole.log(person1); // Output: Person { name: \"John\", age: 30 }\n```\n\n##### Комментарий\n\nПожалуй, стоит отдельно оговорить случай, когда речь идёт о конструкторе унаследованного ES6-класса. Тогда до вызова `super()` значения у `this` нет (обращение к нему вызовет ошибку), а после вызова `super()` он равняется новому объекту родительского класса.","id":"dd732289a4652a08","x":200,"y":300,"width":660,"height":500},
		{"type":"text","text":"##### 4. Эта функция создана с помощью метода `bind`?","id":"c2bd664541083dd1","x":-560,"y":620,"width":601,"height":80,"color":"2"},
		{"type":"text","text":"одному Господу известно, чему будет равен this при её вызове. Идите читать документацию по той штуке, которая её станет вызывать.\n\n##### Комментарий\n\nУ не стрелочной и не связанной (bound) функции значение `this` зависит от обстоятельств, в которых она была вызвана. Если вы не вызываете её лично, а передаёте куда-то, то в качестве `this` может быть или не быть подставлено неизвестное вам значение.  \n  \nПримеры:  \n  \n\n```javascript\n`use strict`\n\ndocument.addEventListener('keydown', function(){\n  console.log(this);\n}); // в этом случае this === document. при срабатывании обработчиков DOM-событий this равняется currentTarget\n\n[1, 2, 3].forEach(function(){\n  console.log(this);\n}); // а в этом случае никакого специального значения не будет, будет undefined. почему? об этом в самом конце.\n```","id":"9389f17bcbbfd0c3","x":200,"y":1010,"width":660,"height":649},
		{"type":"text","text":"`this` равен [глобальному объекту](https://developer.mozilla.org/ru/docs/Glossary/Global_object)\n\n```javascript\nconsole.log(this); // Output: Window { ... }\n\nfunction test() {\n  console.log(this);\n}\n\ntest();\n```\n\n##### Комментарий\n\nВ коде верхнего уровня (не находящемся внутри никакой функции) `this` всегда ссылается на глобальный объект. В случае обычного скрипта в браузере это — объект `window`. Но вообще случаи бывают разные.","id":"bea1b732e192f609","x":200,"y":-330,"width":660,"height":470},
		{"type":"text","text":"##### 5. Эта функция передана куда-то в качестве колбэка или обработчика?","id":"9857b043a57764fa","x":-560,"y":1010,"width":601,"height":80,"color":"2"},
		{"type":"text","text":"##### 7. Эта функция получена как значение свойства объекта и сразу же вызвана?","id":"b1bb358409fc00ab","x":-560,"y":1860,"width":601,"height":79,"color":"2"},
		{"type":"text","text":"`this` равняется вышеупомянутому объекту.\n\n##### Комментарий\n\nСобственно, из этого механизма (а также — из опыта работы с другими языками) растут ноги у убеждения, что \"`this` — это объект, чей метод мы вызвали\". Пожалуй, я просто напишу код.  \n  \n```javascript\n'use strict';\n\nconst object1 = {\n  method: function(){\n    console.log(this);\n  }\n}\n\nconst object2 = {\n  method: object1.method\n}\n\nobject1.method(); // в консоли будет object1 - мы получили функцию как свойство этого объекта и немедленно вызвали\nobject1['method'](); // аналогичный результат. этот механизм не специфичен для точечной нотации\nobject2.method(); // в консоли будет object2 - метод \"не помнит\", в каком объекте он был создан, ему важно только у какого объекта он вызван\n```","id":"505ae471890d8029","x":200,"y":1860,"width":660,"height":740},
		{"type":"text","text":"##### 8. Код выполняется в строгом режиме? ('use strict', ES6 модуль)","id":"335b432ecb19567b","x":-560,"y":2260,"width":601,"height":100,"color":"2"},
		{"type":"text","text":"`this` равняется undefined\n\n##### Комментарий\n\nЕсли мы дошли до этого пункта, значит, `this` не задан ни одним из механизмов, которые позволяют его задать. Существуют различные заблуждения относительно того, как ещё может передаваться `this`. Например, на собеседованиях мне часто говорят вот такую вещь:  \n  \n\n```javascript\nconst obj = { \n  test: function(){\n    (function(){\n      console.log(this);\n    })(); //немедленно вызываемая функция внутри другой функции\n  }\n}\n\nobj.test(); // мне говорят, что в консоль выведется obj. это неправда \n```\n\n  \nИли, как я уже говорил в секции «заблуждения», многие считают, что если функция является методом объекта, созданного с помощью классов ES6, то уж в ней-то this всегда будет равен этому объекту. Это тоже неправда.  \n  \nТак вот, если мы дошли до этого пункта, значит, прочие обстоятельства вызова нашей функции не имеют значения. И всё сводится к тому, находимся мы в строгом режиме или нет.  \n  \nИсторически в качестве «дефолтного» `this` в такие функции передавался глобальный объект. Позже этот подход был признан небезопасным. В ES5 появился строгий режим, исправляющий многие проблемы более ранних версий ECMAScript. Он включается директивой 'use strict' в начале файла или функции. В таком режиме «дефолтное» значение `this` — это `undefined`.  \n  \nВ ES6 модулях строгий режим включен по умолчанию.  \n  \nТакже существуют другие механизмы включения строгого режима, например, в NodeJS строгий режим для всех файлов можно включить флагом `--use-strict`.","id":"2e255429cca94bbf","x":-1340,"y":2360,"width":601,"height":1140},
		{"type":"text","text":"`this` равняется глобальному объекту","id":"56dcfd144b98656a","x":-560,"y":2680,"width":601,"height":67},
		{"type":"text","text":"значение `this` равняется значению первого аргумента, который мы передали в метод `bind` при создании данной функции.\n\n```javascript\nconst obj1 = {\n  name: 'John',\n  age: 30\n};\n\nfunction greet() {\n  console.log(`My name is ${this.name} and I'm ${this.age} years old`);\n}\n\nconst boundFunc = greet.bind(obj1);\nboundFunc(); // Output: My name is John and I'm 30 years old\n```\n\n##### Комментарий\n\nМетод `bind` создаёт копию функции, зафиксировав для неё `this` и, опционально, несколько первых аргументов. На самом деле при этом создаётся не просто копия функции, а, цитирую, «экзотический объект BoundFunction». Экзотичность его проявляется, в частности, в том, что повторным вызовом `bind` мы уже не сможем изменить `this`. Поэтому, строго говоря, ответ в этом пункте надо было сформулировать так: если да, то `this` равняется первому аргументу _первого вызова_ `bind`, который привёл к созданию данной функции.","id":"0c989c7f5d216362","x":-1340,"y":740,"width":601,"height":800},
		{"type":"text","text":"##### 6. Эта функция вызвана с помощью метода `apply` или `call`?\n","id":"43d1046cfd04d8ef","x":-560,"y":1540,"width":601,"height":80,"color":"2"},
		{"type":"text","text":"в таком случае `this` равняется первому аргументу, переданному соответствующему методу.\n\n```javascript\nconst obj1 = {\n  name: 'John',\n  age: 30\n};\n\nfunction greet() {\n  console.log(`My name is ${this.name} and I'm ${this.age} years old`);\n}\n\ngreet.call(obj1); // Output: My name is John and I'm 30 years old\n```\n\n##### Комментарий\n\nЕщё один способ явно задать `this`. Точнее, два. Однако в плане `this` разницы между `apply` и `call` нет никакой, разница только в том, как передаются остальные аргументы.","id":"67c79158adf2e1ef","x":-1340,"y":1659,"width":601,"height":601}
	],
	"edges":[
		{"id":"dfb6c1d3007bd6f0","fromNode":"2d8cf689542f11ce","fromSide":"right","toNode":"bea1b732e192f609","toSide":"left","color":"1","label":"нет"},
		{"id":"6ace8c25c6794fcc","fromNode":"2d8cf689542f11ce","fromSide":"bottom","toNode":"a93e4e9b614cc72a","toSide":"top","color":"2","label":"да"},
		{"id":"9e5c2bcf63512d07","fromNode":"1964e507f8d51462","fromSide":"right","toNode":"dd732289a4652a08","toSide":"left","color":"2","label":"да"},
		{"id":"272e524d46a48a49","fromNode":"a93e4e9b614cc72a","fromSide":"bottom","toNode":"1964e507f8d51462","toSide":"top","color":"1","label":"нет"},
		{"id":"0dbb544b146e6add","fromNode":"1964e507f8d51462","fromSide":"bottom","toNode":"c2bd664541083dd1","toSide":"top","color":"1","label":"нет"},
		{"id":"39af30f3e137a1f4","fromNode":"c2bd664541083dd1","fromSide":"left","toNode":"0c989c7f5d216362","toSide":"right","color":"2","label":"да"},
		{"id":"d1b64b1871f0fcfa","fromNode":"c2bd664541083dd1","fromSide":"bottom","toNode":"9857b043a57764fa","toSide":"top","color":"1","label":"нет"},
		{"id":"83266e36452a31a1","fromNode":"9857b043a57764fa","fromSide":"right","toNode":"9389f17bcbbfd0c3","toSide":"left","label":"да"},
		{"id":"4c21ef9557154248","fromNode":"9857b043a57764fa","fromSide":"bottom","toNode":"43d1046cfd04d8ef","toSide":"top","color":"1","label":"нет"},
		{"id":"af9801aa7d799cf5","fromNode":"43d1046cfd04d8ef","fromSide":"bottom","toNode":"b1bb358409fc00ab","toSide":"top","color":"1","label":"нет"},
		{"id":"60c26c367b23a08d","fromNode":"43d1046cfd04d8ef","fromSide":"left","toNode":"67c79158adf2e1ef","toSide":"top","color":"2","label":"да"},
		{"id":"0e575db03ada03bb","fromNode":"b1bb358409fc00ab","fromSide":"right","toNode":"505ae471890d8029","toSide":"left","color":"2","label":"да"},
		{"id":"2ddfecc9be1e27c9","fromNode":"b1bb358409fc00ab","fromSide":"bottom","toNode":"335b432ecb19567b","toSide":"top","color":"1","label":"нет"},
		{"id":"ed1075bef5138763","fromNode":"79c3892d8f230b62","fromSide":"bottom","toNode":"05d1e6ff66d23220","toSide":"top"},
		{"id":"b7740dad4d3938d2","fromNode":"05d1e6ff66d23220","fromSide":"bottom","toNode":"2d8cf689542f11ce","toSide":"top"},
		{"id":"d65d30ffbc85d024","fromNode":"a93e4e9b614cc72a","fromSide":"left","toNode":"88d3f5f438577ccf","toSide":"right","color":"2","label":"да"},
		{"id":"a1935ec21eea420f","fromNode":"335b432ecb19567b","fromSide":"left","toNode":"2e255429cca94bbf","toSide":"right","color":"2","label":"да"},
		{"id":"697d2e37a7430042","fromNode":"335b432ecb19567b","fromSide":"bottom","toNode":"56dcfd144b98656a","toSide":"top","color":"1","label":"нет"}
	]
}