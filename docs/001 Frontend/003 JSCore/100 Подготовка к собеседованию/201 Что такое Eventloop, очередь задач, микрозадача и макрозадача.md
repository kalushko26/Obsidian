---
title: Что такое Eventloop, очередь задач, микрозадача и макрозадача?
draft: false
tags:
  - "#JavaScript"
  - "#EventLoop"
  - "#CallStack"
  - "#microtask"
  - "#macrotask"
info:
  - "[[062 Событийный цикл. Микрозадачи и макрозадачи|Событийный цикл? Микрозадачи и макрозадачи]]"
  - "[[071 Объяснение работы EventLoop в JavaScript|Объяснение работы EventLoop в JavaScript]]"
  - "[[070 Асинхронщина в JS под капотом|Асинхронщина в JS под капотом]]"
  - https://habr.com/ru/post/461401/
  - https://habr.com/ru/articles/762618/
---
##### Что такое цикл событий (event loop) и как он работает?

![Что такое цикл событий (event loop) и как он работает?](https://youtu.be/w-vUj0gHGgg?t=293)

![[Pasted image 20230723135412.png|600]]

JS является однопоточным _(движок JS в 1 единицу времени может выполнять всего 1 операцию, для этого выделяется Стек)_. В стеке хранятся фреймы - это локальные аргументы и переменные, которые хранятся в функции.

Список событий, которые должны обрабатываться формируют очередь событий. Когда стек освобождается движок может обработать любое событие из этой очереди.

Координирование этого процесса и происходит в `EventLoop`.

##### Разница между микро- и макрозадачами в event loop?

![Разница между микро и макрозадачами в event loop?](https://youtu.be/hL5yFo9Pms4?t=249)

![[Pasted image 20230723135740.png|600]]

**EventLoop** - это механизм, используемый браузером или Node.js для управления асинхронным кодом. Он позволяет синхронизировать callstack и очередь задач.

**Микрозадачи** - это задачи, которые добавляются в очередь микрозадач, после того как стек вызовов пуст, но до того, как будут выполнены макрозадачи.

Микрозадачи включают в себя:

- обработчики промисов.
- обработчики notationObserver.
- функции добавленные с помощью queueMicrotask.

**Макрозадачи** - это задачи, которые добавляются в очередь и добавляются после того как очередь задач пуста.

Макрозадачи включают в себя:

- элементы пользовательского ввода;
- таймеры;
- загрузка и ресурсов
- и другие асинхронные задачи.

##### Расскажите о `queueMicrotask`?

![Расскажите о `queueMicrotask`?](https://youtu.be/hL5yFo9Pms4?t=330)

![[Pasted image 20230723140208.png|600]]

**queueMicrotask** - это JS метод, который используется для добавления переданной в неё функции в очередь микрозадач, внутри EventLoop.

##### Решение задач на асинхронность

![](https://www.youtube.com/watch?v=tZXdWzWyp-s)

**[Тестирование задач событийного цикла](https://www.jsv9000.app/)**

1.  Выбрать и исполнить старейшую синхронную задачу
2.  Исполнить все *микрозадачи*:
    - Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
3.  Отрисовать изменения страницы (`requestAnimationFrame`), если они есть.
4.  Если очередь макрозадач пуста – подождать, пока появится макрозадача.
5.  Перейти к шагу 1.

Нюансы событийного цикла, `promise`:

_Если где-то произойдёт ошибка, то отказ пропустит обработчики на выполнение и долетит до ближайшего обработчика отказа, после чего цепочка продолжит работать в штатном режиме._

```js
Promise.resolve()
  .then(() => {
    return Promise.reject(`O_o`)
  })
  .then(() => {
    // Все обработчики будут не выполнены
  })
  .catch((error) => {
    console.log(error) // `O_o`
  })
  .then(() => {
    // Продолжаем выполнять цепочку
  })
```

_Возвращать значение можно и внутри catch, оно будет точно также обработано в цепочке._

```js
Promise.reject("O_o")
  .catch((error) => {
    console.log(error) // O_o
    return "^_^"
  })
  .then((value) => {
    console.log(value) // ^_^
  })
```

Важно понимать, что обработка ошибок работает только тогда, когда цепочка непрерывна. Если опустить `return` и создать обещание, установленное на отказ, то последующий `catch` не сможет его обработать.

```js
Promise.resolve()
  .then(() => {
    Promise.reject("O_o")
  })
  .catch(() => {
    // Будет пропушено
  })
```

Нюансы событийного цикла, `async..await`:

Единственное место, через которое задачи могут попасть в CallStack и выполниться — это EventLoop.
Задачи могут быть трех типов:
_ микрозадача
_ макрозадача (приоритетенее) \* обработка через рендер (визуализация сайта)

![[Pasted image 20230218194535.png]]

Идея событийный-цикл очень проста.
Есть бесконечный цикл, в котором движок JavaScript ожидает задачи _(реагирование на движение мыши, обработка событий мыши, загрузка внешнего скрипта, setTimeout и др.)_, исполняет их и снова ожидает появления новых.

Очередь, которую формируют такие задачи, называют **очередь-макрозадач**

![[Pasted image 20230218132810.png]]
\_Рисунок 2 Очередь макрозадач и событийный цикл

Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл». Когда браузер заканчивает выполнение скрипта, он обрабатывает событие `mousemove`, затем выполняет обработчик, заданный `setTimeout`, и так далее.

Помимо _макрозадач, существуют микрозадачи.

Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь `PromiseJobs`, более известную как **очередь-микрозадач** (microtask queue)».

Микрозадачи приходят только из кода. Обычно они создаются promise : выполнение обработчика `.then/catch/finally` становится микрозадачей. Микрозадачи также используются «под капотом» `await`, т.к. это форма обработки промиса.

Также есть специальная функция `queueMicrotask(func)`, которая помещает `func` в очередь микрозадач.

Если у кого-то из заказчиков не оказалось задач, то Event Loop просто идет к следующему. И, наоборот, если у заказчика задачи занимают много времени, то остальные заказчики будут ждать своей очереди. А если задачи от какого-то заказчика оказались бесконечными, то CallStack переполняется, и браузер начинает ругаться:

![[Pasted image 20230218195348.png]]
\_Рисунок 3 Страница не отвечает

Есть код:

```javascript
let promise = Promise.resolve()
promise.then(() => alert("промис выполнен"))
alert("код выполнен") // этот alert показывается первым`
```

Или, проще говоря, когда промис выполнен, его обработчики `.then/catch/finally` попадают в очередь-микрозадач. Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.

Вот почему сообщение «код выполнен» в примере выше будет показано первым.

На основе этой схемы строится вся работа Event Loop.

---

[[003 JSCore|Назад]]